messages:
- content: You are an AI agent expert in writing unit tests. Your task is to write
    unit tests for the given code files of the repository. Make sure the tests can
    be executed without lint or compile errors.
  role: system
- content: "### Task Information\nBased on the source code, write/rewrite tests to\
    \ cover the source code.\nRepository: NestJS\nSource File Path: packages/core/hooks/on-module-init.hook.ts\n\
    Test File Path: packages/core/test/hooks/on-module-init.hook.spec.ts\nProject\
    \ Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n\
    ### Source File Content:\nimport { OnModuleInit } from '@nestjs/common';\nimport\
    \ { isFunction, isNil } from '@nestjs/common/utils/shared.utils';\nimport { iterate\
    \ } from 'iterare';\nimport {\n  getNonTransientInstances,\n  getTransientInstances,\n\
    } from '../injector/helpers/transient-instances';\nimport { InstanceWrapper }\
    \ from '../injector/instance-wrapper';\nimport { Module } from '../injector/module';\n\
    \n/**\n * Returns true or false if the given instance has a `onModuleInit` function\n\
    \ *\n * @param instance The instance which should be checked\n */\nfunction hasOnModuleInitHook(instance:\
    \ unknown): instance is OnModuleInit {\n  return isFunction((instance as OnModuleInit).onModuleInit);\n\
    }\n\n/**\n * Calls the given instances\n */\nfunction callOperator(instances:\
    \ InstanceWrapper[]): Promise<any>[] {\n  return iterate(instances)\n    .filter(instance\
    \ => !isNil(instance))\n    .filter(hasOnModuleInitHook)\n    .map(async instance\
    \ => (instance as any as OnModuleInit).onModuleInit())\n    .toArray();\n}\n\n\
    /**\n * Calls the `onModuleInit` function on the module and its children\n * (providers\
    \ / controllers).\n *\n * @param module The module which will be initialized\n\
    \ */\nexport async function callModuleInitHook(module: Module): Promise<void>\
    \ {\n  const providers = module.getNonAliasProviders();\n  // Module (class) instance\
    \ is the first element of the providers array\n  // Lifecycle hook has to be called\
    \ once all classes are properly initialized\n  const [_, moduleClassHost] = providers.shift()!;\n\
    \  const instances = [\n    ...module.controllers,\n    ...providers,\n    ...module.injectables,\n\
    \    ...module.middlewares,\n  ];\n\n  const nonTransientInstances = getNonTransientInstances(instances);\n\
    \  await Promise.all(callOperator(nonTransientInstances));\n\n  const transientInstances\
    \ = getTransientInstances(instances);\n  await Promise.all(callOperator(transientInstances));\n\
    \n  // Call the instance itself\n  const moduleClassInstance = moduleClassHost.instance;\n\
    \  if (\n    moduleClassInstance &&\n    hasOnModuleInitHook(moduleClassInstance)\
    \ &&\n    moduleClassHost.isDependencyTreeStatic()\n  ) {\n    await moduleClassInstance.onModuleInit();\n\
    \  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: instance-wrapper.ts\n\
    import { Logger, LoggerService, Provider, Scope, Type } from '@nestjs/common';\n\
    import { EnhancerSubtype } from '@nestjs/common/constants';\nimport { FactoryProvider,\
    \ InjectionToken } from '@nestjs/common/interfaces';\nimport { clc } from '@nestjs/common/utils/cli-colors.util';\n\
    import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';\n\
    import {\n  isNil,\n  isString,\n  isUndefined,\n} from '@nestjs/common/utils/shared.utils';\n\
    import { iterate } from 'iterare';\nimport { UuidFactory } from '../inspector/uuid-factory';\n\
    import { STATIC_CONTEXT } from './constants';\nimport {\n  isClassProvider,\n\
    \  isFactoryProvider,\n  isValueProvider,\n} from './helpers/provider-classifier';\n\
    import { Module } from './module';\nimport { SettlementSignal } from './settlement-signal';\n\
    \nexport const INSTANCE_METADATA_SYMBOL = Symbol.for('instance_metadata:cache');\n\
    export const INSTANCE_ID_SYMBOL = Symbol.for('instance_metadata:id');\n\nexport\
    \ interface HostComponentInfo {\n  /**\n   * Injection token (or class reference)\n\
    \   */\n  token: InjectionToken;\n  /**\n   * Flag that indicates whether DI subtree\
    \ is durable\n   */\n  isTreeDurable: boolean;\n}\n\nexport interface ContextId\
    \ {\n  readonly id: number;\n  payload?: unknown;\n  getParent?(info: HostComponentInfo):\
    \ ContextId;\n}\n\nexport interface InstancePerContext<T> {\n  instance: T;\n\
    \  isResolved?: boolean;\n  isPending?: boolean;\n  donePromise?: Promise<unknown>;\n\
    }\n\nexport interface PropertyMetadata {\n  key: symbol | string;\n  wrapper:\
    \ InstanceWrapper;\n}\n\ninterface InstanceMetadataStore {\n  dependencies?: InstanceWrapper[];\n\
    \  properties?: PropertyMetadata[];\n  enhancers?: InstanceWrapper[];\n}\n\nexport\
    \ class InstanceWrapper<T = any> {\n  public readonly name: any;\n  public readonly\
    \ token: InjectionToken;\n  public readonly async?: boolean;\n  public readonly\
    \ host?: Module;\n  public readonly isAlias: boolean = false;\n  public readonly\
    \ subtype?: EnhancerSubtype;\n  public scope?: Scope = Scope.DEFAULT;\n  public\
    \ metatype: Type<T> | Function | null;\n  public inject?: FactoryProvider['inject']\
    \ | null;\n  public forwardRef?: boolean;\n  public durable?: boolean;\n  public\
    \ initTime?: number;\n  public settlementSignal?: SettlementSignal;\n\n  private\
    \ static logger: LoggerService = new Logger(InstanceWrapper.name);\n\n  private\
    \ readonly values = new WeakMap<ContextId, InstancePerContext<T>>();\n  private\
    \ readonly [INSTANCE_METADATA_SYMBOL]: InstanceMetadataStore = {};\n  private\
    \ readonly [INSTANCE_ID_SYMBOL]: string;\n  private transientMap?:\n    | Map<string,\
    \ WeakMap<ContextId, InstancePerContext<T>>>\n    | undefined;\n  private isTreeStatic:\
    \ boolean | undefined;\n  private isTreeDurable: boolean | undefined;\n\n  constructor(\n\
    \    metadata: Partial<InstanceWrapper<T>> & Partial<InstancePerContext<T>> =\
    \ {},\n  ) {\n    this.initialize(metadata);\n    this[INSTANCE_ID_SYMBOL] =\n\
    \      metadata[INSTANCE_ID_SYMBOL] ?? this.generateUuid();\n  }\n\n  get id():\
    \ string {\n    return this[INSTANCE_ID_SYMBOL];\n  }\n\n  set instance(value:\
    \ T) {\n    this.values.set(STATIC_CONTEXT, { instance: value });\n  }\n\n  get\
    \ instance(): T {\n    const instancePerContext = this.getInstanceByContextId(STATIC_CONTEXT);\n\
    \    return instancePerContext.instance;\n  }\n\n  get isNotMetatype(): boolean\
    \ {\n    return !this.metatype || this.isFactory;\n  }\n\n  get isFactory(): boolean\
    \ {\n    return !!this.metatype && !isNil(this.inject);\n  }\n\n  get isTransient():\
    \ boolean {\n    return this.scope === Scope.TRANSIENT;\n  }\n\n  public getInstanceByContextId(\n\
    \    contextId: ContextId,\n    inquirerId?: string,\n  ): InstancePerContext<T>\
    \ {\n    if (this.scope === Scope.TRANSIENT && inquirerId) {\n      return this.getInstanceByInquirerId(contextId,\
    \ inquirerId);\n    }\n    const instancePerContext = this.values.get(contextId);\n\
    \    return instancePerContext\n      ? instancePerContext\n      : contextId\
    \ !== STATIC_CONTEXT\n        ? this.cloneStaticInstance(contextId)\n        :\
    \ {\n            instance: null as T,\n            isResolved: true,\n       \
    \     isPending: false,\n          };\n  }\n\n  public getInstanceByInquirerId(\n\
    \    contextId: ContextId,\n    inquirerId: string,\n  ): InstancePerContext<T>\
    \ {\n    let collectionPerContext = this.transientMap!.get(inquirerId);\n    if\
    \ (!collectionPerContext) {\n      collectionPerContext = new WeakMap();\n   \
    \   this.transientMap!.set(inquirerId, collectionPerContext);\n    }\n    const\
    \ instancePerContext = collectionPerContext.get(contextId);\n    return instancePerContext\n\
    \      ? instancePerContext\n      : this.cloneTransientInstance(contextId, inquirerId);\n\
    \  }\n\n  public setInstanceByContextId(\n    contextId: ContextId,\n    value:\
    \ InstancePerContext<T>,\n    inquirerId?: string,\n  ) {\n    if (this.scope\
    \ === Scope.TRANSIENT && inquirerId) {\n      return this.setInstanceByInquirerId(contextId,\
    \ inquirerId, value);\n    }\n    this.values.set(contextId, value);\n  }\n\n\
    \  public setInstanceByInquirerId(\n    contextId: ContextId,\n    inquirerId:\
    \ string,\n    value: InstancePerContext<T>,\n  ) {\n    let collection = this.transientMap!.get(inquirerId);\n\
    \    if (!collection) {\n      collection = new WeakMap();\n      this.transientMap!.set(inquirerId,\
    \ collection);\n    }\n    collection.set(contextId, value);\n  }\n\n  public\
    \ removeInstanceByContextId(contextId: ContextId, inquirerId?: string) {\n   \
    \ if (this.scope === Scope.TRANSIENT && inquirerId) {\n      return this.removeInstanceByInquirerId(contextId,\
    \ inquirerId);\n    }\n    this.values.delete(contextId);\n  }\n\n  public removeInstanceByInquirerId(contextId:\
    \ ContextId, inquirerId: string) {\n    const collection = this.transientMap!.get(inquirerId);\n\
    \    if (!collection) {\n      return;\n    }\n    collection.delete(contextId);\n\
    \  }\n\n  public addCtorMetadata(index: number, wrapper: InstanceWrapper) {\n\
    \    if (!this[INSTANCE_METADATA_SYMBOL].dependencies) {\n      this[INSTANCE_METADATA_SYMBOL].dependencies\
    \ = [];\n    }\n    this[INSTANCE_METADATA_SYMBOL].dependencies[index] = wrapper;\n\
    \  }\n\n  public getCtorMetadata(): InstanceWrapper[] {\n    return this[INSTANCE_METADATA_SYMBOL].dependencies!;\n\
    \  }\n\n  public addPropertiesMetadata(key: symbol | string, wrapper: InstanceWrapper)\
    \ {\n    if (!this[INSTANCE_METADATA_SYMBOL].properties) {\n      this[INSTANCE_METADATA_SYMBOL].properties\
    \ = [];\n    }\n    this[INSTANCE_METADATA_SYMBOL].properties.push({\n      key,\n\
    \      wrapper,\n    });\n  }\n\n  public getPropertiesMetadata(): PropertyMetadata[]\
    \ {\n    return this[INSTANCE_METADATA_SYMBOL].properties!;\n  }\n\n  public addEnhancerMetadata(wrapper:\
    \ InstanceWrapper) {\n    if (!this[INSTANCE_METADATA_SYMBOL].enhancers) {\n \
    \     this[INSTANCE_METADATA_SYMBOL].enhancers = [];\n    }\n    this[INSTANCE_METADATA_SYMBOL].enhancers.push(wrapper);\n\
    \  }\n\n  public getEnhancersMetadata(): InstanceWrapper[] {\n    return this[INSTANCE_METADATA_SYMBOL].enhancers!;\n\
    \  }\n\n  public isDependencyTreeDurable(lookupRegistry: string[] = []): boolean\
    \ {\n    if (!isUndefined(this.isTreeDurable)) {\n      return this.isTreeDurable;\n\
    \    }\n    if (this.scope === Scope.REQUEST) {\n      this.isTreeDurable = this.durable\
    \ === undefined ? false : this.durable;\n      if (this.isTreeDurable) {\n   \
    \     this.printIntrospectedAsDurable();\n      }\n      return this.isTreeDurable;\n\
    \    }\n    const isStatic = this.isDependencyTreeStatic();\n    if (isStatic)\
    \ {\n      return false;\n    }\n\n    const isTreeNonDurable = this.introspectDepsAttribute(\n\
    \      (collection, registry) =>\n        collection.some(\n          (item: InstanceWrapper)\
    \ =>\n            !item.isDependencyTreeStatic() &&\n            !item.isDependencyTreeDurable(registry),\n\
    \        ),\n      lookupRegistry,\n    );\n    this.isTreeDurable = !isTreeNonDurable;\n\
    \    if (this.isTreeDurable) {\n      this.printIntrospectedAsDurable();\n   \
    \ }\n    return this.isTreeDurable;\n  }\n\n  public introspectDepsAttribute(\n\
    \    callback: (\n      collection: InstanceWrapper[],\n      lookupRegistry:\
    \ string[],\n    ) => boolean,\n    lookupRegistry: string[] = [],\n  ): boolean\
    \ {\n    if (lookupRegistry.includes(this[INSTANCE_ID_SYMBOL])) {\n      return\
    \ false;\n    }\n    lookupRegistry = lookupRegistry.concat(this[INSTANCE_ID_SYMBOL]);\n\
    \n    const { dependencies, properties, enhancers } =\n      this[INSTANCE_METADATA_SYMBOL];\n\
    \n    let introspectionResult = dependencies\n      ? callback(dependencies, lookupRegistry)\n\
    \      : false;\n\n    if (introspectionResult || !(properties || enhancers))\
    \ {\n      return introspectionResult;\n    }\n    introspectionResult = properties\n\
    \      ? callback(\n          properties.map(item => item.wrapper),\n        \
    \  lookupRegistry,\n        )\n      : false;\n    if (introspectionResult ||\
    \ !enhancers) {\n      return introspectionResult;\n    }\n    return enhancers\
    \ ? callback(enhancers, lookupRegistry) : false;\n  }\n\n  public isDependencyTreeStatic(lookupRegistry:\
    \ string[] = []): boolean {\n    if (!isUndefined(this.isTreeStatic)) {\n    \
    \  return this.isTreeStatic;\n    }\n    if (this.scope === Scope.REQUEST) {\n\
    \      this.isTreeStatic = false;\n      this.printIntrospectedAsRequestScoped();\n\
    \      return this.isTreeStatic;\n    }\n    this.isTreeStatic = !this.introspectDepsAttribute(\n\
    \      (collection, registry) =>\n        collection.some(\n          (item: InstanceWrapper)\
    \ => !item.isDependencyTreeStatic(registry),\n        ),\n      lookupRegistry,\n\
    \    );\n    if (!this.isTreeStatic) {\n      this.printIntrospectedAsRequestScoped();\n\
    \    }\n    return this.isTreeStatic;\n  }\n\n  public cloneStaticInstance(contextId:\
    \ ContextId): InstancePerContext<T> {\n    const staticInstance = this.getInstanceByContextId(STATIC_CONTEXT);\n\
    \    if (this.isDependencyTreeStatic()) {\n      return staticInstance;\n    }\n\
    \    const instancePerContext: InstancePerContext<T> = {\n      ...staticInstance,\n\
    \      instance: undefined!,\n      isResolved: false,\n      isPending: false,\n\
    \    };\n    if (this.isNewable()) {\n      instancePerContext.instance = Object.create(this.metatype!.prototype);\n\
    \    }\n    this.setInstanceByContextId(contextId, instancePerContext);\n    return\
    \ instancePerContext;\n  }\n\n  public cloneTransientInstance(\n    contextId:\
    \ ContextId,\n    inquirerId: string,\n  ): InstancePerContext<T> {\n    const\
    \ staticInstance = this.getInstanceByContextId(STATIC_CONTEXT);\n    const instancePerContext:\
    \ InstancePerContext<T> = {\n      ...staticInstance,\n      instance: undefined!,\n\
    \      isResolved: false,\n      isPending: false,\n    };\n    if (this.isNewable())\
    \ {\n      instancePerContext.instance = Object.create(this.metatype!.prototype);\n\
    \    }\n    this.setInstanceByInquirerId(contextId, inquirerId, instancePerContext);\n\
    \    return instancePerContext;\n  }\n\n  public createPrototype(contextId: ContextId)\
    \ {\n    const host = this.getInstanceByContextId(contextId);\n    if (!this.isNewable()\
    \ || host.isResolved) {\n      return;\n    }\n    return Object.create(this.metatype!.prototype);\n\
    \  }\n\n  public isInRequestScope(\n    contextId: ContextId,\n    inquirer?:\
    \ InstanceWrapper,\n  ): boolean {\n    const isDependencyTreeStatic = this.isDependencyTreeStatic();\n\
    \n    return (\n      !isDependencyTreeStatic &&\n      contextId !== STATIC_CONTEXT\
    \ &&\n      (!this.isTransient || (this.isTransient && !!inquirer))\n    );\n\
    \  }\n\n  public isLazyTransient(\n    contextId: ContextId,\n    inquirer: InstanceWrapper\
    \ | undefined,\n  ): boolean {\n    const isInquirerRequestScoped = !!(\n    \
    \  inquirer && !inquirer.isDependencyTreeStatic()\n    );\n\n    return (\n  \
    \    this.isDependencyTreeStatic() &&\n      contextId !== STATIC_CONTEXT &&\n\
    \      this.isTransient &&\n      isInquirerRequestScoped\n    );\n  }\n\n  public\
    \ isExplicitlyRequested(\n    contextId: ContextId,\n    inquirer?: InstanceWrapper,\n\
    \  ): boolean {\n    const isSelfRequested = inquirer === this;\n    return (\n\
    \      this.isDependencyTreeStatic() &&\n      contextId !== STATIC_CONTEXT &&\n\
    \      (isSelfRequested || !!(inquirer && inquirer.scope === Scope.TRANSIENT))\n\
    \    );\n  }\n\n  public isStatic(\n    contextId: ContextId,\n    inquirer: InstanceWrapper\
    \ | undefined,\n  ): boolean {\n    const isInquirerRequestScoped =\n      inquirer\
    \ && !inquirer.isDependencyTreeStatic();\n    const isStaticTransient = this.isTransient\
    \ && !isInquirerRequestScoped;\n\n    return (\n      this.isDependencyTreeStatic()\
    \ &&\n      contextId === STATIC_CONTEXT &&\n      (!this.isTransient ||\n   \
    \     (isStaticTransient && !!inquirer && !inquirer.isTransient))\n    );\n  }\n\
    \n  public getStaticTransientInstances() {\n    if (!this.transientMap) {\n  \
    \    return [];\n    }\n    const instances = [...this.transientMap.values()];\n\
    \    return iterate(instances)\n      .map(item => item.get(STATIC_CONTEXT))\n\
    \      .filter(item => !!item)\n      .toArray();\n  }\n\n  public mergeWith(provider:\
    \ Provider) {\n    if (isValueProvider(provider)) {\n      this.metatype = null;\n\
    \      this.inject = null;\n\n      this.scope = Scope.DEFAULT;\n\n      this.setInstanceByContextId(STATIC_CONTEXT,\
    \ {\n        instance: provider.useValue,\n        isResolved: true,\n       \
    \ isPending: false,\n      });\n    } else if (isClassProvider(provider)) {\n\
    \      this.inject = null;\n      this.metatype = provider.useClass;\n    } else\
    \ if (isFactoryProvider(provider)) {\n      this.metatype = provider.useFactory;\n\
    \      this.inject = provider.inject || [];\n    }\n  }\n\n  private isNewable():\
    \ boolean {\n    return isNil(this.inject) && this.metatype && this.metatype.prototype;\n\
    \  }\n\n  private initialize(\n    metadata: Partial<InstanceWrapper<T>> & Partial<InstancePerContext<T>>,\n\
    \  ) {\n    const { instance, isResolved, ...wrapperPartial } = metadata;\n  \
    \  Object.assign(this, wrapperPartial);\n\n    this.setInstanceByContextId(STATIC_CONTEXT,\
    \ {\n      instance: instance as T,\n      isResolved,\n    });\n    this.scope\
    \ === Scope.TRANSIENT && (this.transientMap = new Map());\n  }\n\n  private printIntrospectedAsRequestScoped()\
    \ {\n    if (!this.isDebugMode() || this.name === 'REQUEST') {\n      return;\n\
    \    }\n    if (isString(this.name)) {\n      InstanceWrapper.logger.log(\n  \
    \      `${clc.cyanBright(this.name)}${clc.green(\n          ' introspected as\
    \ ',\n        )}${clc.magentaBright('request-scoped')}`,\n      );\n    }\n  }\n\
    \n  private printIntrospectedAsDurable() {\n    if (!this.isDebugMode()) {\n \
    \     return;\n    }\n    if (isString(this.name)) {\n      InstanceWrapper.logger.log(\n\
    \        `${clc.cyanBright(this.name)}${clc.green(\n          ' introspected as\
    \ ',\n        )}${clc.magentaBright('durable')}`,\n      );\n    }\n  }\n\n  private\
    \ isDebugMode(): boolean {\n    return !!process.env.NEST_DEBUG;\n  }\n\n  private\
    \ generateUuid(): string {\n    let key = this.name?.toString() ?? this.token?.toString();\n\
    \    key += this.host?.name ?? '';\n\n    return key ? UuidFactory.get(key) :\
    \ randomStringGenerator();\n  }\n}\n\n\n### Dependency File: module.ts\nimport\
    \ {\n  EnhancerSubtype,\n  ENTRY_PROVIDER_WATERMARK,\n} from '@nestjs/common/constants';\n\
    import {\n  ClassProvider,\n  Controller,\n  DynamicModule,\n  ExistingProvider,\n\
    \  FactoryProvider,\n  Injectable,\n  InjectionToken,\n  NestModule,\n  Provider,\n\
    \  Scope,\n  Type,\n  ValueProvider,\n} from '@nestjs/common/interfaces';\nimport\
    \ { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';\n\
    import {\n  isFunction,\n  isNil,\n  isObject,\n  isString,\n  isSymbol,\n  isUndefined,\n\
    } from '@nestjs/common/utils/shared.utils';\nimport { iterate } from 'iterare';\n\
    import { ApplicationConfig } from '../application-config';\nimport {\n  InvalidClassException,\n\
    \  RuntimeException,\n  UnknownExportException,\n} from '../errors/exceptions';\n\
    import { createContextId } from '../helpers/context-id-factory';\nimport { getClassScope\
    \ } from '../helpers/get-class-scope';\nimport { isDurable } from '../helpers/is-durable';\n\
    import { UuidFactory } from '../inspector/uuid-factory';\nimport { CONTROLLER_ID_KEY\
    \ } from './constants';\nimport { NestContainer } from './container';\nimport\
    \ { ContextId, InstanceWrapper } from './instance-wrapper';\nimport { ModuleRef,\
    \ ModuleRefGetOrResolveOpts } from './module-ref';\n\nexport class Module {\n\
    \  private readonly _id: string;\n  private readonly _imports = new Set<Module>();\n\
    \  private readonly _providers = new Map<\n    InjectionToken,\n    InstanceWrapper<Injectable>\n\
    \  >();\n  private readonly _injectables = new Map<\n    InjectionToken,\n   \
    \ InstanceWrapper<Injectable>\n  >();\n  private readonly _middlewares = new Map<\n\
    \    InjectionToken,\n    InstanceWrapper<Injectable>\n  >();\n  private readonly\
    \ _controllers = new Map<\n    InjectionToken,\n    InstanceWrapper<Controller>\n\
    \  >();\n  private readonly _entryProviderKeys = new Set<InjectionToken>();\n\
    \  private readonly _exports = new Set<InjectionToken>();\n\n  private _distance\
    \ = 0;\n  private _initOnPreview = false;\n  private _isGlobal = false;\n  private\
    \ _token: string;\n\n  constructor(\n    private readonly _metatype: Type<any>,\n\
    \    private readonly container: NestContainer,\n  ) {\n    this.addCoreProviders();\n\
    \    this._id = this.generateUuid();\n  }\n\n  get id(): string {\n    return\
    \ this._id;\n  }\n\n  get token(): string {\n    return this._token;\n  }\n\n\
    \  set token(token: string) {\n    this._token = token;\n  }\n\n  get name() {\n\
    \    return this.metatype.name;\n  }\n\n  get isGlobal() {\n    return this._isGlobal;\n\
    \  }\n\n  set isGlobal(global: boolean) {\n    this._isGlobal = global;\n  }\n\
    \n  get initOnPreview() {\n    return this._initOnPreview;\n  }\n\n  set initOnPreview(initOnPreview:\
    \ boolean) {\n    this._initOnPreview = initOnPreview;\n  }\n\n  get providers():\
    \ Map<InjectionToken, InstanceWrapper<Injectable>> {\n    return this._providers;\n\
    \  }\n\n  get middlewares(): Map<InjectionToken, InstanceWrapper<Injectable>>\
    \ {\n    return this._middlewares;\n  }\n\n  get imports(): Set<Module> {\n  \
    \  return this._imports;\n  }\n\n  get injectables(): Map<InjectionToken, InstanceWrapper<Injectable>>\
    \ {\n    return this._injectables;\n  }\n\n  get controllers(): Map<InjectionToken,\
    \ InstanceWrapper<Controller>> {\n    return this._controllers;\n  }\n\n  get\
    \ entryProviders(): Array<InstanceWrapper<Injectable>> {\n    return Array.from(this._entryProviderKeys).map(\n\
    \      token => this.providers.get(token)!,\n    );\n  }\n\n  get exports(): Set<InjectionToken>\
    \ {\n    return this._exports;\n  }\n\n  get instance(): NestModule {\n    if\
    \ (!this._providers.has(this._metatype)) {\n      throw new RuntimeException();\n\
    \    }\n    const moduleRef = this._providers.get(this._metatype);\n    return\
    \ moduleRef!.instance as NestModule;\n  }\n\n  get metatype(): Type<any> {\n \
    \   return this._metatype;\n  }\n\n  get distance(): number {\n    return this._distance;\n\
    \  }\n\n  set distance(value: number) {\n    this._distance = value;\n  }\n\n\
    \  public addCoreProviders() {\n    this.addModuleAsProvider();\n    this.addModuleRef();\n\
    \    this.addApplicationConfig();\n  }\n\n  public addModuleRef() {\n    const\
    \ moduleRef = this.createModuleReferenceType();\n    this._providers.set(\n  \
    \    ModuleRef,\n      new InstanceWrapper({\n        token: ModuleRef,\n    \
    \    name: ModuleRef.name,\n        metatype: ModuleRef as any,\n        isResolved:\
    \ true,\n        instance: new moduleRef(),\n        host: this,\n      }),\n\
    \    );\n  }\n\n  public addModuleAsProvider() {\n    this._providers.set(\n \
    \     this._metatype,\n      new InstanceWrapper({\n        token: this._metatype,\n\
    \        name: this._metatype.name,\n        metatype: this._metatype,\n     \
    \   isResolved: false,\n        instance: null,\n        host: this,\n      }),\n\
    \    );\n  }\n\n  public addApplicationConfig() {\n    this._providers.set(\n\
    \      ApplicationConfig,\n      new InstanceWrapper({\n        token: ApplicationConfig,\n\
    \        name: ApplicationConfig.name,\n        isResolved: true,\n        instance:\
    \ this.container.applicationConfig,\n        host: this,\n      }),\n    );\n\
    \  }\n\n  public addInjectable<T extends Injectable>(\n    injectable: Provider,\n\
    \    enhancerSubtype: EnhancerSubtype,\n    host?: Type<T>,\n  ) {\n    if (this.isCustomProvider(injectable))\
    \ {\n      return this.addCustomProvider(\n        injectable,\n        this._injectables,\n\
    \        enhancerSubtype,\n      );\n    }\n    let instanceWrapper = this.injectables.get(injectable);\n\
    \    if (!instanceWrapper) {\n      instanceWrapper = new InstanceWrapper({\n\
    \        token: injectable,\n        name: injectable.name,\n        metatype:\
    \ injectable,\n        instance: null,\n        isResolved: false,\n        scope:\
    \ getClassScope(injectable),\n        durable: isDurable(injectable),\n      \
    \  subtype: enhancerSubtype,\n        host: this,\n      });\n      this._injectables.set(injectable,\
    \ instanceWrapper);\n    }\n    if (host) {\n      const hostWrapper =\n     \
    \   this._controllers.get(host) || this._providers.get(host);\n      hostWrapper\
    \ && hostWrapper.addEnhancerMetadata(instanceWrapper);\n    }\n    return instanceWrapper;\n\
    \  }\n\n  public addProvider(provider: Provider): InjectionToken;\n  public addProvider(\n\
    \    provider: Provider,\n    enhancerSubtype: EnhancerSubtype,\n  ): InjectionToken;\n\
    \  public addProvider(provider: Provider, enhancerSubtype?: EnhancerSubtype) {\n\
    \    if (this.isCustomProvider(provider)) {\n      if (this.isEntryProvider(provider.provide))\
    \ {\n        this._entryProviderKeys.add(provider.provide);\n      }\n      return\
    \ this.addCustomProvider(provider, this._providers, enhancerSubtype);\n    }\n\
    \n    const isAlreadyDeclared = this._providers.has(provider);\n    if (\n   \
    \   (this.isTransientProvider(provider) ||\n        this.isRequestScopeProvider(provider))\
    \ &&\n      isAlreadyDeclared\n    ) {\n      return provider;\n    }\n\n    this._providers.set(\n\
    \      provider,\n      new InstanceWrapper({\n        token: provider,\n    \
    \    name: (provider as Type<Injectable>).name,\n        metatype: provider as\
    \ Type<Injectable>,\n        instance: null,\n        isResolved: false,\n   \
    \     scope: getClassScope(provider),\n        durable: isDurable(provider),\n\
    \        host: this,\n      }),\n    );\n\n    if (this.isEntryProvider(provider))\
    \ {\n      this._entryProviderKeys.add(provider);\n    }\n\n    return provider\
    \ as Type<Injectable>;\n  }\n\n  public isCustomProvider(\n    provider: Provider,\n\
    \  ): provider is\n    | ClassProvider\n    | FactoryProvider\n    | ValueProvider\n\
    \    | ExistingProvider {\n    return !isNil(\n      (\n        provider as\n\
    \          | ClassProvider\n          | FactoryProvider\n          | ValueProvider\n\
    \          | ExistingProvider\n      ).provide,\n    );\n  }\n\n  public addCustomProvider(\n\
    \    provider:\n      | ClassProvider\n      | FactoryProvider\n      | ValueProvider\n\
    \      | ExistingProvider,\n    collection: Map<Function | string | symbol, any>,\n\
    \    enhancerSubtype?: EnhancerSubtype,\n  ) {\n    if (this.isCustomClass(provider))\
    \ {\n      this.addCustomClass(provider, collection, enhancerSubtype);\n    }\
    \ else if (this.isCustomValue(provider)) {\n      this.addCustomValue(provider,\
    \ collection, enhancerSubtype);\n    } else if (this.isCustomFactory(provider))\
    \ {\n      this.addCustomFactory(provider, collection, enhancerSubtype);\n   \
    \ } else if (this.isCustomUseExisting(provider)) {\n      this.addCustomUseExisting(provider,\
    \ collection, enhancerSubtype);\n    }\n    return provider.provide;\n  }\n\n\
    \  public isCustomClass(provider: any): provider is ClassProvider {\n    return\
    \ !isUndefined((provider as ClassProvider).useClass);\n  }\n\n  public isCustomValue(provider:\
    \ any): provider is ValueProvider {\n    return (\n      isObject(provider) &&\n\
    \      Object.prototype.hasOwnProperty.call(provider, 'useValue')\n    );\n  }\n\
    \n  public isCustomFactory(provider: any): provider is FactoryProvider {\n   \
    \ return !isUndefined((provider as FactoryProvider).useFactory);\n  }\n\n  public\
    \ isCustomUseExisting(provider: any): provider is ExistingProvider {\n    return\
    \ !isUndefined((provider as ExistingProvider).useExisting);\n  }\n\n  public isDynamicModule(exported:\
    \ any): exported is DynamicModule {\n    return exported && exported.module;\n\
    \  }\n\n  public addCustomClass(\n    provider: ClassProvider,\n    collection:\
    \ Map<InjectionToken, InstanceWrapper>,\n    enhancerSubtype?: EnhancerSubtype,\n\
    \  ) {\n    let { scope, durable } = provider;\n\n    const { useClass } = provider;\n\
    \    if (isUndefined(scope)) {\n      scope = getClassScope(useClass);\n    }\n\
    \    if (isUndefined(durable)) {\n      durable = isDurable(useClass);\n    }\n\
    \n    const token = provider.provide;\n    collection.set(\n      token,\n   \
    \   new InstanceWrapper({\n        token,\n        name: useClass?.name || useClass,\n\
    \        metatype: useClass,\n        instance: null,\n        isResolved: false,\n\
    \        scope,\n        durable,\n        host: this,\n        subtype: enhancerSubtype,\n\
    \      }),\n    );\n  }\n\n  public addCustomValue(\n    provider: ValueProvider,\n\
    \    collection: Map<Function | string | symbol, InstanceWrapper>,\n    enhancerSubtype?:\
    \ EnhancerSubtype,\n  ) {\n    const { useValue: value, provide: providerToken\
    \ } = provider;\n    collection.set(\n      providerToken,\n      new InstanceWrapper({\n\
    \        token: providerToken,\n        name: (providerToken as Function)?.name\
    \ || providerToken,\n        metatype: null!,\n        instance: value,\n    \
    \    isResolved: true,\n        async: value instanceof Promise,\n        host:\
    \ this,\n        subtype: enhancerSubtype,\n      }),\n    );\n  }\n\n  public\
    \ addCustomFactory(\n    provider: FactoryProvider,\n    collection: Map<Function\
    \ | string | symbol, InstanceWrapper>,\n    enhancerSubtype?: EnhancerSubtype,\n\
    \  ) {\n    const {\n      useFactory: factory,\n      inject,\n      scope,\n\
    \      durable,\n      provide: providerToken,\n    } = provider;\n\n    collection.set(\n\
    \      providerToken,\n      new InstanceWrapper({\n        token: providerToken,\n\
    \        name: (providerToken as Function)?.name || providerToken,\n        metatype:\
    \ factory as any,\n        instance: null,\n        isResolved: false,\n     \
    \   inject: inject || [],\n        scope,\n        durable,\n        host: this,\n\
    \        subtype: enhancerSubtype,\n      }),\n    );\n  }\n\n  public addCustomUseExisting(\n\
    \    provider: ExistingProvider,\n    collection: Map<Function | string | symbol,\
    \ InstanceWrapper>,\n    enhancerSubtype?: EnhancerSubtype,\n  ) {\n    const\
    \ { useExisting, provide: providerToken } = provider;\n    collection.set(\n \
    \     providerToken,\n      new InstanceWrapper({\n        token: providerToken,\n\
    \        name: (providerToken as Function)?.name || providerToken,\n        metatype:\
    \ (instance => instance) as any,\n        instance: null,\n        isResolved:\
    \ false,\n        inject: [useExisting],\n        host: this,\n        isAlias:\
    \ true,\n        subtype: enhancerSubtype,\n      }),\n    );\n  }\n\n  public\
    \ addExportedProviderOrModule(\n    toExport: Provider | string | symbol | DynamicModule,\n\
    \  ) {\n    const addExportedUnit = (token: InjectionToken) =>\n      this._exports.add(this.validateExportedProvider(token));\n\
    \n    if (this.isCustomProvider(toExport as any)) {\n      return this.addCustomExportedProvider(toExport\
    \ as any);\n    } else if (isString(toExport) || isSymbol(toExport)) {\n     \
    \ return addExportedUnit(toExport);\n    } else if (this.isDynamicModule(toExport))\
    \ {\n      const { module: moduleClassRef } = toExport;\n      return addExportedUnit(moduleClassRef);\n\
    \    }\n    addExportedUnit(toExport as Type<any>);\n  }\n\n  public addCustomExportedProvider(\n\
    \    provider:\n      | FactoryProvider\n      | ValueProvider\n      | ClassProvider\n\
    \      | ExistingProvider,\n  ) {\n    const provide = provider.provide;\n   \
    \ if (isString(provide) || isSymbol(provide)) {\n      return this._exports.add(this.validateExportedProvider(provide));\n\
    \    }\n    this._exports.add(this.validateExportedProvider(provide));\n  }\n\n\
    \  public validateExportedProvider(token: InjectionToken) {\n    if (this._providers.has(token))\
    \ {\n      return token;\n    }\n    const imports = iterate(this._imports.values())\n\
    \      .filter(item => !!item)\n      .map(({ metatype }) => metatype)\n     \
    \ .filter(metatype => !!metatype)\n      .toArray();\n\n    if (!imports.includes(token\
    \ as Type<unknown>)) {\n      const { name } = this.metatype;\n      const providerName\
    \ = isFunction(token) ? (token as Function).name : token;\n      throw new UnknownExportException(providerName\
    \ as string, name);\n    }\n    return token;\n  }\n\n  public addController(controller:\
    \ Type<Controller>) {\n    this._controllers.set(\n      controller,\n      new\
    \ InstanceWrapper({\n        token: controller,\n        name: controller.name,\n\
    \        metatype: controller,\n        instance: null!,\n        isResolved:\
    \ false,\n        scope: getClassScope(controller),\n        durable: isDurable(controller),\n\
    \        host: this,\n      }),\n    );\n\n    this.assignControllerUniqueId(controller);\n\
    \  }\n\n  public assignControllerUniqueId(controller: Type<Controller>) {\n  \
    \  Object.defineProperty(controller, CONTROLLER_ID_KEY, {\n      enumerable: false,\n\
    \      writable: false,\n      configurable: true,\n      value: randomStringGenerator(),\n\
    \    });\n  }\n\n  public addImport(moduleRef: Module) {\n    this._imports.add(moduleRef);\n\
    \  }\n\n  public replace(toReplace: InjectionToken, options: any) {\n    if (options.isProvider\
    \ && this.hasProvider(toReplace)) {\n      const originalProvider = this._providers.get(toReplace);\n\
    \n      return originalProvider!.mergeWith({ provide: toReplace, ...options });\n\
    \    } else if (!options.isProvider && this.hasInjectable(toReplace)) {\n    \
    \  const originalInjectable = this._injectables.get(toReplace);\n\n      return\
    \ originalInjectable!.mergeWith({\n        provide: toReplace,\n        ...options,\n\
    \      });\n    }\n  }\n\n  public hasProvider(token: InjectionToken): boolean\
    \ {\n    return this._providers.has(token);\n  }\n\n  public hasInjectable(token:\
    \ InjectionToken): boolean {\n    return this._injectables.has(token);\n  }\n\n\
    \  public getProviderByKey<T = any>(name: InjectionToken): InstanceWrapper<T>\
    \ {\n    return this._providers.get(name) as InstanceWrapper<T>;\n  }\n\n  public\
    \ getProviderById<T = any>(id: string): InstanceWrapper<T> | undefined {\n   \
    \ return Array.from(this._providers.values()).find(\n      item => item.id ===\
    \ id,\n    ) as InstanceWrapper<T>;\n  }\n\n  public getControllerById<T = any>(\n\
    \    id: string,\n  ): InstanceWrapper<T> | undefined {\n    return Array.from(this._controllers.values()).find(\n\
    \      item => item.id === id,\n    ) as InstanceWrapper<T>;\n  }\n\n  public\
    \ getInjectableById<T = any>(\n    id: string,\n  ): InstanceWrapper<T> | undefined\
    \ {\n    return Array.from(this._injectables.values()).find(\n      item => item.id\
    \ === id,\n    ) as InstanceWrapper<T>;\n  }\n\n  public getMiddlewareById<T =\
    \ any>(\n    id: string,\n  ): InstanceWrapper<T> | undefined {\n    return Array.from(this._middlewares.values()).find(\n\
    \      item => item.id === id,\n    ) as InstanceWrapper<T>;\n  }\n\n  public\
    \ getNonAliasProviders(): Array<\n    [InjectionToken, InstanceWrapper<Injectable>]\n\
    \  > {\n    return [...this._providers].filter(([_, wrapper]) => !wrapper.isAlias);\n\
    \  }\n\n  public createModuleReferenceType(): Type<ModuleRef> {\n    // eslint-disable-next-line\
    \ @typescript-eslint/no-this-alias\n    const self = this;\n    return class extends\
    \ ModuleRef {\n      constructor() {\n        super(self.container);\n      }\n\
    \n      public get<TInput = any, TResult = TInput>(\n        typeOrToken: Type<TInput>\
    \ | string | symbol,\n        options: ModuleRefGetOrResolveOpts = {},\n     \
    \ ): TResult | Array<TResult> {\n        options.strict ??= true;\n        options.each\
    \ ??= false;\n\n        return this.find<TInput, TResult>(\n          typeOrToken,\n\
    \          options.strict\n            ? {\n                moduleId: self.id,\n\
    \                each: options.each,\n              }\n            : options,\n\
    \        );\n      }\n\n      public resolve<TInput = any, TResult = TInput>(\n\
    \        typeOrToken: Type<TInput> | string | symbol,\n        contextId = createContextId(),\n\
    \        options: ModuleRefGetOrResolveOpts = {},\n      ): Promise<TResult |\
    \ Array<TResult>> {\n        options.strict ??= true;\n        options.each ??=\
    \ false;\n\n        return this.resolvePerContext<TInput, TResult>(\n        \
    \  typeOrToken,\n          self,\n          contextId,\n          options,\n \
    \       );\n      }\n\n      public async create<T = any>(\n        type: Type<T>,\n\
    \        contextId?: ContextId,\n      ): Promise<T> {\n        if (!(type &&\
    \ isFunction(type) && type.prototype)) {\n          throw new InvalidClassException(type);\n\
    \        }\n        return this.instantiateClass<T>(type, self, contextId);\n\
    \      }\n    };\n  }\n\n  private isEntryProvider(metatype: InjectionToken):\
    \ boolean {\n    return typeof metatype === 'function'\n      ? !!Reflect.getMetadata(ENTRY_PROVIDER_WATERMARK,\
    \ metatype)\n      : false;\n  }\n\n  private generateUuid(): string {\n    const\
    \ prefix = 'M_';\n    const key = this.token\n      ? this.token.includes(':')\n\
    \        ? this.token.split(':')[1]\n        : this.token\n      : this.name;\n\
    \n    return key ? UuidFactory.get(`${prefix}_${key}`) : randomStringGenerator();\n\
    \  }\n\n  private isTransientProvider(provider: Type<any>): boolean {\n    return\
    \ getClassScope(provider) === Scope.TRANSIENT;\n  }\n\n  private isRequestScopeProvider(provider:\
    \ Type<any>): boolean {\n    return getClassScope(provider) === Scope.REQUEST;\n\
    \  }\n}\n\n\n### Dependency File: transient-instances.ts\nimport { InjectionToken\
    \ } from '@nestjs/common';\nimport { iterate } from 'iterare';\nimport { InstanceWrapper\
    \ } from '../instance-wrapper';\n\n/**\n * Returns the instances which are transient\n\
    \ * @param instances The instances which should be checked whether they are transient\n\
    \ */\nexport function getTransientInstances(\n  instances: [InjectionToken, InstanceWrapper][],\n\
    ): InstanceWrapper[] {\n  return iterate(instances)\n    .filter(([_, wrapper])\
    \ => wrapper.isDependencyTreeStatic())\n    .map(([_, wrapper]) => wrapper.getStaticTransientInstances())\n\
    \    .flatten()\n    .filter(item => !!item)\n    .map(({ instance }: any) =>\
    \ instance)\n    .toArray() as InstanceWrapper[];\n}\n\n/**\n * Returns the instances\
    \ which are not transient\n * @param instances The instances which should be checked\
    \ whether they are transient\n */\nexport function getNonTransientInstances(\n\
    \  instances: [InjectionToken, InstanceWrapper][],\n): InstanceWrapper[] {\n \
    \ return iterate(instances)\n    .filter(\n      ([key, wrapper]) =>\n       \
    \ wrapper.isDependencyTreeStatic() && !wrapper.isTransient,\n    )\n    .map(([key,\
    \ { instance }]) => instance)\n    .toArray() as InstanceWrapper[];\n}\n\nOutput\
    \ the complete test file, code only, no explanations.\n### Time\nCurrent time:\
    \ 2025-04-11 20:28:34\n"
  role: user
