messages:
- content: You are an AI agent expert in writing unit tests. Your task is to write
    unit tests for the given code files of the repository. Make sure the tests can
    be executed without lint or compile errors.
  role: system
- content: "### Task Information\nBased on the source code, write/rewrite tests to\
    \ cover the source code.\nRepository: fp-ts\nSource File Path: src/Functor.ts\n\
    Test File Path: test/Functor.ts\nProject Programming Language: typescript\nTesting\
    \ Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n\
    \ * A `Functor` is a type constructor which supports a mapping operation `map`.\n\
    \ *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f\
    \ b` whose argument and return types use the type\n * constructor `f` to represent\
    \ some computational context.\n *\n * Instances must satisfy the following laws:\n\
    \ *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa,\
    \ a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nimport\
    \ { pipe } from './function'\nimport { HKT, Kind, Kind2, Kind3, Kind4, URIS, URIS2,\
    \ URIS3, URIS4 } from './HKT'\n\n// -------------------------------------------------------------------------------------\n\
    // model\n// -------------------------------------------------------------------------------------\n\
    \n/**\n * @category model\n * @since 2.0.0\n */\nexport interface Functor<F> {\n\
    \  readonly URI: F\n  readonly map: <A, B>(fa: HKT<F, A>, f: (a: A) => B) => HKT<F,\
    \ B>\n}\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport interface Functor1<F\
    \ extends URIS> {\n  readonly URI: F\n  readonly map: <A, B>(fa: Kind<F, A>, f:\
    \ (a: A) => B) => Kind<F, B>\n}\n\n/**\n * @category model\n * @since 2.0.0\n\
    \ */\nexport interface Functor2<F extends URIS2> {\n  readonly URI: F\n  readonly\
    \ map: <E, A, B>(fa: Kind2<F, E, A>, f: (a: A) => B) => Kind2<F, E, B>\n}\n\n\
    /**\n * @category model\n * @since 2.0.0\n */\nexport interface Functor2C<F extends\
    \ URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly map: <A, B>(fa:\
    \ Kind2<F, E, A>, f: (a: A) => B) => Kind2<F, E, B>\n}\n\n/**\n * @category model\n\
    \ * @since 2.0.0\n */\nexport interface Functor3<F extends URIS3> {\n  readonly\
    \ URI: F\n  readonly map: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => B)\
    \ => Kind3<F, R, E, B>\n}\n\n/**\n * @category model\n * @since 2.2.0\n */\nexport\
    \ interface Functor3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E:\
    \ E\n  readonly map: <R, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => B) => Kind3<F,\
    \ R, E, B>\n}\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport interface\
    \ Functor4<F extends URIS4> {\n  readonly URI: F\n  readonly map: <S, R, E, A,\
    \ B>(fa: Kind4<F, S, R, E, A>, f: (a: A) => B) => Kind4<F, S, R, E, B>\n}\n\n\
    // -------------------------------------------------------------------------------------\n\
    // combinators\n// -------------------------------------------------------------------------------------\n\
    \n/**\n * `map` composition.\n *\n * @since 2.10.0\n */\nexport function map<F\
    \ extends URIS3, G extends URIS>(\n  F: Functor3<F>,\n  G: Functor1<G>\n): <A,\
    \ B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, E, Kind<G, A>>) => Kind3<F, R,\
    \ E, Kind<G, B>>\nexport function map<F extends URIS2, G extends URIS2>(\n  F:\
    \ Functor2<F>,\n  G: Functor2<G>\n): <A, B>(f: (a: A) => B) => <EF, EG>(fa: Kind2<F,\
    \ EF, Kind2<G, EG, A>>) => Kind2<F, EF, Kind2<G, EG, B>>\nexport function map<F\
    \ extends URIS2, G extends URIS>(\n  F: Functor2<F>,\n  G: Functor1<G>\n): <A,\
    \ B>(f: (a: A) => B) => <E>(fa: Kind2<F, E, Kind<G, A>>) => Kind2<F, E, Kind<G,\
    \ B>>\nexport function map<F extends URIS, G extends URIS3>(\n  F: Functor1<F>,\n\
    \  G: Functor3<G>\n): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind<F, Kind3<G, R,\
    \ E, A>>) => Kind<F, Kind3<G, R, E, B>>\nexport function map<F extends URIS, G\
    \ extends URIS2>(\n  F: Functor1<F>,\n  G: Functor2<G>\n): <A, B>(f: (a: A) =>\
    \ B) => <E>(fa: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, B>>\nexport function\
    \ map<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Functor1<G>\n\
    ): <A, B>(f: (a: A) => B) => (fa: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>\n\
    export function map<F, G extends URIS2>(\n  F: Functor<F>,\n  G: Functor2<G>\n\
    ): <A, B>(f: (a: A) => B) => <E>(fa: HKT<F, Kind2<G, E, A>>) => HKT<F, Kind2<G,\
    \ E, B>>\nexport function map<F, G extends URIS>(\n  F: Functor<F>,\n  G: Functor1<G>\n\
    ): <A, B>(f: (a: A) => B) => (fa: HKT<F, Kind<G, A>>) => HKT<F, Kind<G, B>>\n\
    export function map<F, G>(\n  F: Functor<F>,\n  G: Functor<G>\n): <A, B>(f: (a:\
    \ A) => B) => (fa: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>\nexport function map<F,\
    \ G>(\n  F: Functor<F>,\n  G: Functor<G>\n): <A, B>(f: (a: A) => B) => (fa: HKT<F,\
    \ HKT<G, A>>) => HKT<F, HKT<G, B>> {\n  return (f) => (fa) => F.map(fa, (ga) =>\
    \ G.map(ga, f))\n}\n\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport\
    \ function flap<F extends URIS4>(\n  F: Functor4<F>\n): <A>(a: A) => <S, R, E,\
    \ B>(fab: Kind4<F, S, R, E, (a: A) => B>) => Kind4<F, S, R, E, B>\nexport function\
    \ flap<F extends URIS3>(\n  F: Functor3<F>\n): <A>(a: A) => <R, E, B>(fab: Kind3<F,\
    \ R, E, (a: A) => B>) => Kind3<F, R, E, B>\nexport function flap<F extends URIS2>(\n\
    \  F: Functor2<F>\n): <A>(a: A) => <E, B>(fab: Kind2<F, E, (a: A) => B>) => Kind2<F,\
    \ E, B>\nexport function flap<F extends URIS>(F: Functor1<F>): <A>(a: A) => <B>(fab:\
    \ Kind<F, (a: A) => B>) => Kind<F, B>\nexport function flap<F>(F: Functor<F>):\
    \ <A>(a: A) => <B>(fab: HKT<F, (a: A) => B>) => HKT<F, B>\nexport function flap<F>(F:\
    \ Functor<F>): <A>(a: A) => <B>(fab: HKT<F, (a: A) => B>) => HKT<F, B> {\n  return\
    \ (a) => (fab) => F.map(fab, (f) => f(a))\n}\n\n// -------------------------------------------------------------------------------------\n\
    // utils\n// -------------------------------------------------------------------------------------\n\
    \n/**\n * @since 2.10.0\n */\nexport function bindTo<F extends URIS4>(\n  F: Functor4<F>\n\
    ): <N extends string>(name: N) => <S, R, E, A>(fa: Kind4<F, S, R, E, A>) => Kind4<F,\
    \ S, R, E, { readonly [K in N]: A }>\nexport function bindTo<F extends URIS3>(\n\
    \  F: Functor3<F>\n): <N extends string>(name: N) => <R, E, A>(fa: Kind3<F, R,\
    \ E, A>) => Kind3<F, R, E, { readonly [K in N]: A }>\nexport function bindTo<F\
    \ extends URIS3, E>(\n  F: Functor3C<F, E>\n): <N extends string>(name: N) =>\
    \ <R, A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, { readonly [K in N]: A }>\n\
    export function bindTo<F extends URIS2>(\n  F: Functor2<F>\n): <N extends string>(name:\
    \ N) => <E, A>(fa: Kind2<F, E, A>) => Kind2<F, E, { readonly [K in N]: A }>\n\
    export function bindTo<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <N extends\
    \ string>(name: N) => <A>(fa: Kind2<F, E, A>) => Kind2<F, E, { readonly [K in\
    \ N]: A }>\nexport function bindTo<F extends URIS>(\n  F: Functor1<F>\n): <N extends\
    \ string>(name: N) => <A>(fa: Kind<F, A>) => Kind<F, { readonly [K in N]: A }>\n\
    export function bindTo<F>(\n  F: Functor<F>\n): <N extends string>(name: N) =>\
    \ <A>(fa: HKT<F, A>) => HKT<F, { readonly [K in N]: A }>\nexport function bindTo<F>(\n\
    \  F: Functor<F>\n): <N extends string>(name: N) => <A>(fa: HKT<F, A>) => HKT<F,\
    \ { readonly [K in N]: A }> {\n  return (name) => (fa) => F.map(fa, (a) => ({\
    \ [name]: a } as any))\n}\n\n/**\n * @since 2.13.0\n */\nfunction let_<F extends\
    \ URIS4>(\n  F: Functor4<F>\n): <N extends string, A, B>(\n  name: Exclude<N,\
    \ keyof A>,\n  f: (a: A) => B\n) => <S, R, E>(\n  fa: Kind4<F, S, R, E, A>\n)\
    \ => Kind4<F, S, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K]\
    \ : B }>\nfunction let_<F extends URIS3>(\n  F: Functor3<F>\n): <N extends string,\
    \ A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n) => <R, E>(fa: Kind3<F,\
    \ R, E, A>) => Kind3<F, R, E, { readonly [K in keyof A | N]: K extends keyof A\
    \ ? A[K] : B }>\nfunction let_<F extends URIS3, E>(\n  F: Functor3C<F, E>\n):\
    \ <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n\
    ) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, { readonly [K in keyof A | N]:\
    \ K extends keyof A ? A[K] : B }>\nfunction let_<F extends URIS2>(\n  F: Functor2<F>\n\
    ): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n\
    ) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, { readonly [K in keyof A | N]: K extends\
    \ keyof A ? A[K] : B }>\nfunction let_<F extends URIS2, E>(\n  F: Functor2C<F,\
    \ E>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A)\
    \ => B\n) => (fa: Kind2<F, E, A>) => Kind2<F, E, { readonly [K in keyof A | N]:\
    \ K extends keyof A ? A[K] : B }>\nfunction let_<F extends URIS>(\n  F: Functor1<F>\n\
    ): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n\
    ) => (fa: Kind<F, A>) => Kind<F, { readonly [K in keyof A | N]: K extends keyof\
    \ A ? A[K] : B }>\nfunction let_<F>(\n  F: Functor<F>\n): <N extends string, A,\
    \ B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n) => (fa: HKT<F, A>) =>\
    \ HKT<F, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>\nfunction\
    \ let_<F>(\n  F: Functor<F>\n): <N extends string, A, B>(\n  name: Exclude<N,\
    \ keyof A>,\n  f: (a: A) => B\n) => (fa: HKT<F, A>) => HKT<F, { readonly [K in\
    \ keyof A | N]: K extends keyof A ? A[K] : B }> {\n  return (name, f) => (fa)\
    \ => F.map(fa, (a) => Object.assign({}, a, { [name]: f(a) }) as any)\n}\n\nexport\
    \ {\n  /**\n   * @since 2.13.0\n   */\n  let_ as let\n}\n\n// -------------------------------------------------------------------------------------\n\
    // deprecated\n// -------------------------------------------------------------------------------------\n\
    \n/**\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport\
    \ interface FunctorComposition<F, G> {\n  readonly map: <A, B>(fa: HKT<F, HKT<G,\
    \ A>>, f: (a: A) => B) => HKT<F, HKT<G, B>>\n}\n\n/**\n * @category zone of death\n\
    \ * @since 2.0.0\n * @deprecated\n */\nexport interface FunctorCompositionHKT1<F,\
    \ G extends URIS> {\n  readonly map: <A, B>(fa: HKT<F, Kind<G, A>>, f: (a: A)\
    \ => B) => HKT<F, Kind<G, B>>\n}\n\n/**\n * @category zone of death\n * @since\
    \ 2.0.0\n * @deprecated\n */\nexport interface FunctorCompositionHKT2<F, G extends\
    \ URIS2> {\n  readonly map: <E, A, B>(fa: HKT<F, Kind2<G, E, A>>, f: (a: A) =>\
    \ B) => HKT<F, Kind2<G, E, B>>\n}\n\n/**\n * @category zone of death\n * @since\
    \ 2.0.0\n * @deprecated\n */\nexport interface FunctorCompositionHKT2C<F, G extends\
    \ URIS2, E> {\n  readonly map: <A, B>(fa: HKT<F, Kind2<G, E, A>>, f: (a: A) =>\
    \ B) => HKT<F, Kind2<G, E, B>>\n}\n\n/**\n * @category zone of death\n * @since\
    \ 2.0.0\n * @deprecated\n */\nexport interface FunctorComposition11<F extends\
    \ URIS, G extends URIS> {\n  readonly map: <A, B>(fa: Kind<F, Kind<G, A>>, f:\
    \ (a: A) => B) => Kind<F, Kind<G, B>>\n}\n\n/**\n * @category zone of death\n\
    \ * @since 2.0.0\n * @deprecated\n */\nexport interface FunctorComposition12<F\
    \ extends URIS, G extends URIS2> {\n  readonly map: <E, A, B>(fa: Kind<F, Kind2<G,\
    \ E, A>>, f: (a: A) => B) => Kind<F, Kind2<G, E, B>>\n}\n\n/**\n * @category zone\
    \ of death\n * @since 2.0.0\n * @deprecated\n */\nexport interface FunctorComposition12C<F\
    \ extends URIS, G extends URIS2, E> {\n  readonly map: <A, B>(fa: Kind<F, Kind2<G,\
    \ E, A>>, f: (a: A) => B) => Kind<F, Kind2<G, E, B>>\n}\n\n/**\n * @category zone\
    \ of death\n * @since 2.0.0\n * @deprecated\n */\nexport interface FunctorComposition21<F\
    \ extends URIS2, G extends URIS> {\n  readonly map: <E, A, B>(fa: Kind2<F, E,\
    \ Kind<G, A>>, f: (a: A) => B) => Kind2<F, E, Kind<G, B>>\n}\n\n/**\n * @category\
    \ zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport interface FunctorComposition2C1<F\
    \ extends URIS2, G extends URIS, E> {\n  readonly map: <A, B>(fa: Kind2<F, E,\
    \ Kind<G, A>>, f: (a: A) => B) => Kind2<F, E, Kind<G, B>>\n}\n\n/**\n * @category\
    \ zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport interface FunctorComposition22<F\
    \ extends URIS2, G extends URIS2> {\n  readonly map: <FE, GE, A, B>(fa: Kind2<F,\
    \ FE, Kind2<G, GE, A>>, f: (a: A) => B) => Kind2<F, FE, Kind2<G, GE, B>>\n}\n\n\
    /**\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport\
    \ interface FunctorComposition22C<F extends URIS2, G extends URIS2, E> {\n  readonly\
    \ map: <FE, A, B>(fa: Kind2<F, FE, Kind2<G, E, A>>, f: (a: A) => B) => Kind2<F,\
    \ FE, Kind2<G, E, B>>\n}\n\n/**\n * @category zone of death\n * @since 2.2.0\n\
    \ * @deprecated\n */\nexport interface FunctorComposition23<F extends URIS2, G\
    \ extends URIS3> {\n  readonly map: <FE, R, E, A, B>(fa: Kind2<F, FE, Kind3<G,\
    \ R, E, A>>, f: (a: A) => B) => Kind2<F, FE, Kind3<G, R, E, B>>\n}\n\n/**\n *\
    \ @category zone of death\n * @since 2.2.0\n * @deprecated\n */\nexport interface\
    \ FunctorComposition23C<F extends URIS2, G extends URIS3, E> {\n  readonly map:\
    \ <FE, R, A, B>(fa: Kind2<F, FE, Kind3<G, R, E, A>>, f: (a: A) => B) => Kind2<F,\
    \ FE, Kind3<G, R, E, B>>\n}\n\n/**\n * Use [`map`](#map) instead.\n *\n * @category\
    \ zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getFunctorComposition<F\
    \ extends URIS2, G extends URIS3, E>(\n  F: Functor2<F>,\n  G: Functor3C<G, E>\n\
    ): FunctorComposition23C<F, G, E>\n/** @deprecated */\nexport function getFunctorComposition<F\
    \ extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Functor2C<G, E>\n\
    ): FunctorComposition22C<F, G, E>\n/** @deprecated */\nexport function getFunctorComposition<F\
    \ extends URIS2, G extends URIS2>(\n  F: Functor2<F>,\n  G: Functor2<G>\n): FunctorComposition22<F,\
    \ G>\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS2,\
    \ G extends URIS, E>(\n  F: Functor2C<F, E>,\n  G: Functor1<G>\n): FunctorComposition2C1<F,\
    \ G, E>\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS2,\
    \ G extends URIS>(\n  F: Functor2<F>,\n  G: Functor1<G>\n): FunctorComposition21<F,\
    \ G>\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS,\
    \ G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Functor2C<G, E>\n): FunctorComposition12C<F,\
    \ G, E>\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS,\
    \ G extends URIS2>(\n  F: Functor1<F>,\n  G: Functor2<G>\n): FunctorComposition12<F,\
    \ G>\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS,\
    \ G extends URIS>(\n  F: Functor1<F>,\n  G: Functor1<G>\n): FunctorComposition11<F,\
    \ G>\n/** @deprecated */\nexport function getFunctorComposition<F, G>(F: Functor<F>,\
    \ G: Functor<G>): FunctorComposition<F, G>\n/** @deprecated */\nexport function\
    \ getFunctorComposition<F, G>(F: Functor<F>, G: Functor<G>): FunctorComposition<F,\
    \ G> {\n  const _map = map(F, G)\n  return {\n    map: (fga, f) => pipe(fga, _map(f))\n\
    \  }\n}\n\n/** @internal */\nexport function as<F extends URIS4>(\n  F: Functor4<F>\n\
    ): <S, R, E, A, _>(self: Kind4<F, S, R, E, _>, a: A) => Kind4<F, S, R, E, A>\n\
    /** @internal */\nexport function as<F extends URIS3>(F: Functor3<F>): <R, E,\
    \ A, _>(self: Kind3<F, R, E, _>, a: _) => Kind3<F, R, E, A>\n/** @internal */\n\
    export function as<F extends URIS2>(F: Functor2<F>): <E, A, _>(self: Kind2<F,\
    \ E, _>, a: A) => Kind2<F, E, A>\n/** @internal */\nexport function as<F extends\
    \ URIS>(F: Functor1<F>): <A, _>(self: Kind<F, _>, a: A) => Kind<F, A>\n/** @internal\
    \ */\nexport function as<F>(F: Functor<F>): <A, _>(self: HKT<F, _>, a: A) => HKT<F,\
    \ A>\n/** @internal */\nexport function as<F>(F: Functor<F>): <A, _>(self: HKT<F,\
    \ _>, b: A) => HKT<F, A> {\n  return (self, b) => F.map(self, () => b)\n}\n\n\
    /** @internal */\nexport function asUnit<F extends URIS4>(\n  F: Functor4<F>\n\
    ): <S, R, E, _>(self: Kind4<F, S, R, E, _>) => Kind4<F, S, R, E, void>\n/** @internal\
    \ */\nexport function asUnit<F extends URIS3>(F: Functor3<F>): <R, E, _>(self:\
    \ Kind3<F, R, E, _>) => Kind3<F, R, E, void>\n/** @internal */\nexport function\
    \ asUnit<F extends URIS2>(F: Functor2<F>): <E, _>(self: Kind2<F, E, _>) => Kind2<F,\
    \ E, void>\n/** @internal */\nexport function asUnit<F extends URIS>(F: Functor1<F>):\
    \ <_>(self: Kind<F, _>) => Kind<F, void>\n/** @internal */\nexport function asUnit<F>(F:\
    \ Functor<F>): <_>(self: HKT<F, _>) => HKT<F, void>\n/** @internal */\nexport\
    \ function asUnit<F>(F: Functor<F>): <_>(self: HKT<F, _>) => HKT<F, void> {\n\
    \  const asM = as(F)\n  return (self) => asM(self, undefined)\n}\n\n### Source\
    \ File Dependency Files Content\n### Dependency File: function.ts\n/**\n * @since\
    \ 2.0.0\n */\nimport { BooleanAlgebra } from './BooleanAlgebra'\nimport { Monoid\
    \ } from './Monoid'\nimport { Ring } from './Ring'\nimport { Semigroup } from\
    \ './Semigroup'\nimport { Semiring } from './Semiring'\n\n// -------------------------------------------------------------------------------------\n\
    // instances\n// -------------------------------------------------------------------------------------\n\
    \n/**\n * @category instances\n * @since 2.10.0\n */\nexport const getBooleanAlgebra\
    \ =\n  <B>(B: BooleanAlgebra<B>) =>\n  <A = never>(): BooleanAlgebra<(a: A) =>\
    \ B> => ({\n    meet: (x, y) => (a) => B.meet(x(a), y(a)),\n    join: (x, y) =>\
    \ (a) => B.join(x(a), y(a)),\n    zero: () => B.zero,\n    one: () => B.one,\n\
    \    implies: (x, y) => (a) => B.implies(x(a), y(a)),\n    not: (x) => (a) =>\
    \ B.not(x(a))\n  })\n\n/**\n * Unary functions form a semigroup as long as you\
    \ can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate,\
    \ getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n\
    \ *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number>\
    \ = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n\
    \ *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f,\
    \ g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n\
    \ * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f,\
    \ g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport const\
    \ getSemigroup =\n  <S>(S: Semigroup<S>) =>\n  <A = never>(): Semigroup<(a: A)\
    \ => S> => ({\n    concat: (f, g) => (a) => S.concat(f(a), g(a))\n  })\n\n/**\n\
    \ * Unary functions form a monoid as long as you can provide a monoid for the\
    \ codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n\
    \ * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n\
    \ *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number>\
    \ = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n *\
    \ assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f,\
    \ g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f,\
    \ g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category\
    \ instances\n * @since 2.10.0\n */\nexport const getMonoid = <M>(M: Monoid<M>):\
    \ (<A = never>() => Monoid<(a: A) => M>) => {\n  const getSemigroupM = getSemigroup(M)\n\
    \  return <A>() => ({\n    concat: getSemigroupM<A>().concat,\n    empty: () =>\
    \ M.empty\n  })\n}\n\n/**\n * @category instances\n * @since 2.10.0\n */\nexport\
    \ const getSemiring = <A, B>(S: Semiring<B>): Semiring<(a: A) => B> => ({\n  add:\
    \ (f, g) => (x) => S.add(f(x), g(x)),\n  zero: () => S.zero,\n  mul: (f, g) =>\
    \ (x) => S.mul(f(x), g(x)),\n  one: () => S.one\n})\n\n/**\n * @category instances\n\
    \ * @since 2.10.0\n */\nexport const getRing = <A, B>(R: Ring<B>): Ring<(a: A)\
    \ => B> => {\n  const S = getSemiring<A, B>(R)\n  return {\n    add: S.add,\n\
    \    mul: S.mul,\n    one: S.one,\n    zero: S.zero,\n    sub: (f, g) => (x) =>\
    \ R.sub(f(x), g(x))\n  }\n}\n\n// -------------------------------------------------------------------------------------\n\
    // utils\n// -------------------------------------------------------------------------------------\n\
    \n/**\n * @since 2.11.0\n */\nexport const apply =\n  <A>(a: A) =>\n  <B>(f: (a:\
    \ A) => B): B =>\n    f(a)\n\n/**\n * @example\n * import { FunctionN } from 'fp-ts/function'\n\
    \ *\n * export const sum: FunctionN<[number, number], number> = (a, b) => a +\
    \ b\n *\n * @since 2.0.0\n */\nexport interface FunctionN<A extends ReadonlyArray<unknown>,\
    \ B> {\n  (...args: A): B\n}\n\n/**\n * @since 2.0.0\n */\nexport function identity<A>(a:\
    \ A): A {\n  return a\n}\n\n/**\n * @since 2.0.0\n */\nexport const unsafeCoerce:\
    \ <A, B>(a: A) => B = identity as any\n\n/**\n * @since 2.0.0\n */\nexport function\
    \ constant<A>(a: A): LazyArg<A> {\n  return () => a\n}\n\n/**\n * A thunk that\
    \ returns always `true`.\n *\n * @since 2.0.0\n */\nexport const constTrue: LazyArg<boolean>\
    \ = /*#__PURE__*/ constant(true)\n\n/**\n * A thunk that returns always `false`.\n\
    \ *\n * @since 2.0.0\n */\nexport const constFalse: LazyArg<boolean> = /*#__PURE__*/\
    \ constant(false)\n\n/**\n * A thunk that returns always `null`.\n *\n * @since\
    \ 2.0.0\n */\nexport const constNull: LazyArg<null> = /*#__PURE__*/ constant(null)\n\
    \n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\n\
    export const constUndefined: LazyArg<undefined> = /*#__PURE__*/ constant(undefined)\n\
    \n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport\
    \ const constVoid: LazyArg<void> = constUndefined\n\n/**\n * Flips the arguments\
    \ of a curried function.\n *\n * @example\n * import { flip } from 'fp-ts/function'\n\
    \ *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.strictEqual(flip(f)('aaa')(2),\
    \ -1)\n *\n * @since 2.0.0\n */\nexport function flip<A, B, C>(f: (a: A) => (b:\
    \ B) => C): (b: B) => (a: A) => C\n/** @deprecated */\nexport function flip<A,\
    \ B, C>(f: (a: A, b: B) => C): (b: B, a: A) => C\nexport function flip(f: Function):\
    \ Function {\n  return (...args: Array<any>) => {\n    if (args.length > 1) {\n\
    \      return f(args[1], args[0])\n    }\n\n    return (a: any) => f(a)(args[0])\n\
    \  }\n}\n\n/**\n * Performs left-to-right function composition. The first argument\
    \ may have any arity, the remaining arguments must be unary.\n *\n * See also\
    \ [`pipe`](#pipe).\n *\n * @example\n * import { flow } from 'fp-ts/function'\n\
    \ *\n * const len = (s: string): number => s.length\n * const double = (n: number):\
    \ number => n * 2\n *\n * const f = flow(len, double)\n *\n * assert.strictEqual(f('aaa'),\
    \ 6)\n *\n * @since 2.0.0\n */\nexport function flow<A extends ReadonlyArray<unknown>,\
    \ B>(ab: (...a: A) => B): (...a: A) => B\nexport function flow<A extends ReadonlyArray<unknown>,\
    \ B, C>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C\nexport function\
    \ flow<A extends ReadonlyArray<unknown>, B, C, D>(\n  ab: (...a: A) => B,\n  bc:\
    \ (b: B) => C,\n  cd: (c: C) => D\n): (...a: A) => D\nexport function flow<A extends\
    \ ReadonlyArray<unknown>, B, C, D, E>(\n  ab: (...a: A) => B,\n  bc: (b: B) =>\
    \ C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): (...a: A) => E\nexport function\
    \ flow<A extends ReadonlyArray<unknown>, B, C, D, E, F>(\n  ab: (...a: A) => B,\n\
    \  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n\
    ): (...a: A) => F\nexport function flow<A extends ReadonlyArray<unknown>, B, C,\
    \ D, E, F, G>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n\
    \  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): (...a: A) => G\n\
    export function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H>(\n\
    \  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) =>\
    \ E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): (...a: A)\
    \ => H\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F,\
    \ G, H, I>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n \
    \ de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n\
    \  hi: (h: H) => I\n): (...a: A) => I\nexport function flow<A extends ReadonlyArray<unknown>,\
    \ B, C, D, E, F, G, H, I, J>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd:\
    \ (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n \
    \ gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): (...a: A) => J\n\
    export function flow(\n  ab: Function,\n  bc?: Function,\n  cd?: Function,\n \
    \ de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?:\
    \ Function,\n  ij?: Function\n): unknown {\n  switch (arguments.length) {\n  \
    \  case 1:\n      return ab\n    case 2:\n      return function (this: unknown)\
    \ {\n        return bc!(ab.apply(this, arguments))\n      }\n    case 3:\n   \
    \   return function (this: unknown) {\n        return cd!(bc!(ab.apply(this, arguments)))\n\
    \      }\n    case 4:\n      return function (this: unknown) {\n        return\
    \ de!(cd!(bc!(ab.apply(this, arguments))))\n      }\n    case 5:\n      return\
    \ function (this: unknown) {\n        return ef!(de!(cd!(bc!(ab.apply(this, arguments)))))\n\
    \      }\n    case 6:\n      return function (this: unknown) {\n        return\
    \ fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))\n      }\n    case 7:\n \
    \     return function (this: unknown) {\n        return gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this,\
    \ arguments)))))))\n      }\n    case 8:\n      return function (this: unknown)\
    \ {\n        return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))))\n\
    \      }\n    case 9:\n      return function (this: unknown) {\n        return\
    \ ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))))\n      }\n\
    \  }\n  return\n}\n\n/**\n * @since 2.0.0\n */\nexport function tuple<T extends\
    \ ReadonlyArray<any>>(...t: T): T {\n  return t\n}\n\n/**\n * @since 2.0.0\n */\n\
    export function increment(n: number): number {\n  return n + 1\n}\n\n/**\n * @since\
    \ 2.0.0\n */\nexport function decrement(n: number): number {\n  return n - 1\n\
    }\n\n/**\n * @since 2.0.0\n */\nexport function absurd<A>(_: never): A {\n  throw\
    \ new Error('Called `absurd` function which should be uncallable')\n}\n\n/**\n\
    \ * Creates a tupled version of this function: instead of `n` arguments, it accepts\
    \ a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n\
    \ *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1,\
    \ 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled<A extends ReadonlyArray<unknown>,\
    \ B>(f: (...a: A) => B): (a: A) => B {\n  return (a) => f(...a)\n}\n\n/**\n *\
    \ Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled<A\
    \ extends ReadonlyArray<unknown>, B>(f: (a: A) => B): (...a: A) => B {\n  return\
    \ (...a) => f(a)\n}\n\n/**\n * Pipes the value of an expression into a pipeline\
    \ of functions.\n *\n * See also [`flow`](#flow).\n *\n * @example\n * import\
    \ { pipe } from 'fp-ts/function'\n *\n * const len = (s: string): number => s.length\n\
    \ * const double = (n: number): number => n * 2\n *\n * // without pipe\n * assert.strictEqual(double(len('aaa')),\
    \ 6)\n *\n * // with pipe\n * assert.strictEqual(pipe('aaa', len, double), 6)\n\
    \ *\n * @since 2.6.3\n */\nexport function pipe<A>(a: A): A\nexport function pipe<A,\
    \ B>(a: A, ab: (a: A) => B): B\nexport function pipe<A, B, C>(a: A, ab: (a: A)\
    \ => B, bc: (b: B) => C): C\nexport function pipe<A, B, C, D>(a: A, ab: (a: A)\
    \ => B, bc: (b: B) => C, cd: (c: C) => D): D\nexport function pipe<A, B, C, D,\
    \ E>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E):\
    \ E\nexport function pipe<A, B, C, D, E, F>(\n  a: A,\n  ab: (a: A) => B,\n  bc:\
    \ (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n):\
    \ F\nexport function pipe<A, B, C, D, E, F, G>(\n  a: A,\n  ab: (a: A) => B,\n\
    \  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n\
    \  fg: (f: F) => G\n): G\nexport function pipe<A, B, C, D, E, F, G, H>(\n  a:\
    \ A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D)\
    \ => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): H\nexport\
    \ function pipe<A, B, C, D, E, F, G, H, I>(\n  a: A,\n  ab: (a: A) => B,\n  bc:\
    \ (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n \
    \ fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): I\nexport function\
    \ pipe<A, B, C, D, E, F, G, H, I, J>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b:\
    \ B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg:\
    \ (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n):\
    \ J\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K>(\n  a: A,\n  ab: (a:\
    \ A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef:\
    \ (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n \
    \ ij: (i: I) => J,\n  jk: (j: J) => K\n): K\nexport function pipe<A, B, C, D,\
    \ E, F, G, H, I, J, K, L>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n\
    \  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n\
    \  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n\
    \  kl: (k: K) => L\n): L\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K,\
    \ L, M>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n\
    \  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n\
    \  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n\
    \  lm: (l: L) => M\n): M\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K,\
    \ L, M, N>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) =>\
    \ D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G)\
    \ => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k:\
    \ K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N\n): N\nexport function pipe<A,\
    \ B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  a: A,\n  ab: (a: A) => B,\n  bc:\
    \ (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n \
    \ fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n\
    \  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n\
    \  no: (n: N) => O\n): O\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J,\
    \ K, L, M, N, O, P>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c:\
    \ C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh:\
    \ (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n \
    \ kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n\
    \  op: (o: O) => P\n): P\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J,\
    \ K, L, M, N, O, P, Q>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd:\
    \ (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n \
    \ gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n\
    \  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n\
    \  op: (o: O) => P,\n  pq: (p: P) => Q\n): Q\n\nexport function pipe<A, B, C,\
    \ D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(\n  a: A,\n  ab: (a: A) => B,\n\
    \  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n\
    \  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n\
    \  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n\
    \  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R\n\
    ): R\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q,\
    \ R, S>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n\
    \  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n\
    \  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n\
    \  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n\
    \  pq: (p: P) => Q,\n  qr: (q: Q) => R,\n  rs: (r: R) => S\n): S\n\nexport function\
    \ pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(\n  a: A,\n\
    \  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n\
    \  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n\
    \  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n\
    \  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n\
    \  qr: (q: Q) => R,\n  rs: (r: R) => S,\n  st: (s: S) => T\n): T\nexport function\
    \ pipe(\n  a: unknown,\n  ab?: Function,\n  bc?: Function,\n  cd?: Function,\n\
    \  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?:\
    \ Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return\
    \ a\n    case 2:\n      return ab!(a)\n    case 3:\n      return bc!(ab!(a))\n\
    \    case 4:\n      return cd!(bc!(ab!(a)))\n    case 5:\n      return de!(cd!(bc!(ab!(a))))\n\
    \    case 6:\n      return ef!(de!(cd!(bc!(ab!(a)))))\n    case 7:\n      return\
    \ fg!(ef!(de!(cd!(bc!(ab!(a))))))\n    case 8:\n      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))\n\
    \    case 9:\n      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))\n    default:\
    \ {\n      let ret = arguments[0]\n      for (let i = 1; i < arguments.length;\
    \ i++) {\n        ret = arguments[i](ret)\n      }\n      return ret\n    }\n\
    \  }\n}\n\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport const\
    \ hole: <T>() => T = absurd as any\n\n/**\n * @since 2.11.0\n */\nexport const\
    \ SK = <A, B>(_: A, b: B): B => b\n\n// -------------------------------------------------------------------------------------\n\
    // deprecated\n// -------------------------------------------------------------------------------------\n\
    \n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n *\
    \ @since 2.0.0\n * @deprecated\n */\nexport interface Refinement<A, B extends\
    \ A> {\n  (a: A): a is B\n}\n\n/**\n * Use `Predicate` module instead.\n *\n *\
    \ @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport interface\
    \ Predicate<A> {\n  (a: A): boolean\n}\n\n/**\n * Use `Predicate` module instead.\n\
    \ *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport\
    \ function not<A>(predicate: Predicate<A>): Predicate<A> {\n  return (a) => !predicate(a)\n\
    }\n\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n\
    \ * @since 2.0.0\n * @deprecated\n */\nexport interface Endomorphism<A> {\n  (a:\
    \ A): A\n}\n\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone\
    \ of death\n * @since 2.10.0\n * @deprecated\n */\nexport const getEndomorphismMonoid\
    \ = <A = never>(): Monoid<Endomorphism<A>> => ({\n  concat: (first, second) =>\
    \ flow(first, second),\n  empty: identity\n})\n\n/**\n * A lazy argument.\n *\n\
    \ * @since 2.15.0\n */\nexport interface LazyArg<A> {\n  (): A\n}\n\n/** @internal\
    \ */\nexport const dual: {\n  <DataLast extends (...args: Array<any>) => any,\
    \ DataFirst extends (...args: Array<any>) => any>(\n    arity: Parameters<DataFirst>['length'],\n\
    \    body: DataFirst\n  ): DataLast & DataFirst\n  <DataLast extends (...args:\
    \ Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(\n    isDataFirst:\
    \ (args: IArguments) => boolean,\n    body: DataFirst\n  ): DataLast & DataFirst\n\
    } = (arity: any, body: any) => {\n  const isDataFirst: (args: IArguments) => boolean\
    \ = typeof arity === 'number' ? (args) => args.length >= arity : arity\n  return\
    \ function (this: any) {\n    const args = Array.from(arguments)\n    if (isDataFirst(arguments))\
    \ {\n      return body.apply(this, args)\n    }\n    return (self: any) => body(self,\
    \ ...args)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n\
    // lagacy\n// -------------------------------------------------------------------------------------\n\
    \n/**\n * Use `LazyArg` instead.\n *\n * @category lagacy\n * @since 2.0.0\n */\n\
    export interface Lazy<A> {\n  (): A\n}\n\n\n### Dependency File: HKT.ts\n/**\n\
    \ * Type defunctionalization (as describe in [Lightweight higher-kinded polymorphism](https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf))\n\
    \ *\n * @since 2.0.0\n */\n\n/**\n * `* -> *` constructors\n * @since 2.0.0\n\
    \ */\nexport interface HKT<URI, A> {\n  readonly _URI: URI\n  readonly _A: A\n\
    }\n\n/**\n * `* -> * -> *` constructors\n * @since 2.0.0\n */\nexport interface\
    \ HKT2<URI, E, A> extends HKT<URI, A> {\n  readonly _E: E\n}\n\n/**\n * `* ->\
    \ * -> * -> *` constructors\n * @since 2.0.0\n */\nexport interface HKT3<URI,\
    \ R, E, A> extends HKT2<URI, E, A> {\n  readonly _R: R\n}\n\n/**\n * `* -> * ->\
    \ * -> * -> *` constructors\n * @since 2.0.0\n */\nexport interface HKT4<URI,\
    \ S, R, E, A> extends HKT3<URI, R, E, A> {\n  readonly _S: S\n}\n\n//\n// inj:\
    \ type-level dictionaries for HKTs: URI -> concrete type\n//\n\n/**\n * `* ->\
    \ *` constructors\n * @since 2.0.0\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\
    export interface URItoKind<A> {}\n\n/**\n * `* -> * -> *` constructors\n * @since\
    \ 2.0.0\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\
    export interface URItoKind2<E, A> {}\n\n/**\n * `* -> * -> * -> *` constructors\n\
    \ * @since 2.0.0\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\
    export interface URItoKind3<R, E, A> {}\n\n/**\n * `* -> * -> * -> * -> *` constructors\n\
    \ * @since 2.0.0\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\
    export interface URItoKind4<S, R, E, A> {}\n\n//\n// unions of URIs\n//\n\n/**\n\
    \ * `* -> *` constructors\n * @since 2.0.0\n */\nexport type URIS = keyof URItoKind<any>\n\
    \n/**\n * `* -> * -> *` constructors\n * @since 2.0.0\n */\nexport type URIS2\
    \ = keyof URItoKind2<any, any>\n\n/**\n * `* -> * -> * -> *` constructors\n *\
    \ @since 2.0.0\n */\nexport type URIS3 = keyof URItoKind3<any, any, any>\n\n/**\n\
    \ * `* -> * -> * -> * -> *` constructors\n * @since 2.0.0\n */\nexport type URIS4\
    \ = keyof URItoKind4<any, any, any, any>\n\n//\n// prj\n//\n\n/**\n * `* -> *`\
    \ constructors\n * @since 2.0.0\n */\nexport type Kind<URI extends URIS, A> =\
    \ URI extends URIS ? URItoKind<A>[URI] : any\n\n/**\n * `* -> * -> *` constructors\n\
    \ * @since 2.0.0\n */\nexport type Kind2<URI extends URIS2, E, A> = URI extends\
    \ URIS2 ? URItoKind2<E, A>[URI] : any\n\n/**\n * `* -> * -> * -> *` constructors\n\
    \ * @since 2.0.0\n */\nexport type Kind3<URI extends URIS3, R, E, A> = URI extends\
    \ URIS3 ? URItoKind3<R, E, A>[URI] : any\n\n/**\n * `* -> * -> * -> * -> *` constructors\n\
    \ * @since 2.0.0\n */\nexport type Kind4<URI extends URIS4, S, R, E, A> = URI\
    \ extends URIS4 ? URItoKind4<S, R, E, A>[URI] : any\n\nOutput the complete test\
    \ file, code only, no explanations.\n### Time\nCurrent time: 2025-04-03 22:59:11\n"
  role: user
