{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\addSeconds\\addSeconds_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { addMilliseconds } from \"../addMilliseconds/index.js\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\n\n/**\n * The {@link addSeconds} function options.\n */\nexport interface AddSecondsOptions<DateType extends Date = Date>\n  extends ContextOptions<DateType> {}\n\n/**\n * @name addSeconds\n * @category Second Helpers\n * @summary Add the specified number of seconds to the given date.\n *\n * @description\n * Add the specified number of seconds to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of seconds to be added.\n * @param options - An object with options\n *\n * @returns The new date with the seconds added\n *\n * @example\n * // Add 30 seconds to 10 July 2014 12:45:00:\n * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)\n * //=> Thu Jul 10 2014 12:45:30\n */\nexport function addSeconds<\n  DateType extends Date,\n  ResultDate extends Date = DateType,\n>(\n  date: DateArg<DateType>,\n  amount: number,\n  options?: AddSecondsOptions<ResultDate> | undefined,\n): ResultDate {\n  return addMilliseconds(date, amount * 1000, options);\n}\n\n### Source File Dependency Files Content\n### Dependency File: addMilliseconds_index.ts\nimport { constructFrom } from \"../constructFrom/index.js\";\nimport { toDate } from \"../toDate/index.js\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\n/**\n * The {@link addMilliseconds} function options.\n */\nexport interface AddMillisecondsOptions<DateType extends Date = Date>\n  extends ContextOptions<DateType> {}\n\n/**\n * @name addMilliseconds\n * @category Millisecond Helpers\n * @summary Add the specified number of milliseconds to the given date.\n *\n * @description\n * Add the specified number of milliseconds to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of milliseconds to be added.\n * @param options - The options object\n *\n * @returns The new date with the milliseconds added\n *\n * @example\n * // Add 750 milliseconds to 10 July 2014 12:45:30.000:\n * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)\n * //=> Thu Jul 10 2014 12:45:30.750\n */\nexport function addMilliseconds<\n  DateType extends Date,\n  ResultDate extends Date = DateType,\n>(\n  date: DateArg<DateType>,\n  amount: number,\n  options?: AddMillisecondsOptions<ResultDate> | undefined,\n): ResultDate {\n  return constructFrom(options?.in || date, +toDate(date) + amount);\n}\n\n\n### Dependency File: src_types.ts\nimport { type constructFromSymbol } from \"./constants/index.js\";\nimport type { Locale } from \"./locale/types.js\";\n\nexport type * from \"./fp/types.js\";\nexport type * from \"./locale/types.js\";\n\n/**\n * The argument type.\n */\nexport type DateArg<DateType extends Date> = DateType | number | string;\n\n/**\n * Date extension interface that allows to transfer extra properties from\n * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n */\nexport interface ConstructableDate extends Date {\n  [constructFromSymbol]: <DateType extends Date = Date>(\n    value: DateArg<Date> & {},\n  ) => DateType;\n}\n\n/**\n * The generic date constructor. Replicates the Date constructor. Used to build\n * generic functions.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n */\nexport interface GenericDateConstructor<DateType extends Date = Date> {\n  /**\n   * The date constructor. Creates date with the current date and time.\n   *\n   * @returns The date instance\n   */\n  new (): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date, number of\n   * milliseconds or string to parse.\n   *\n   * @param value - The date, number of milliseconds or string to parse\n   *\n   * @returns The date instance\n   */\n  new (value: DateArg<Date> & {}): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date values (year,\n   * month, etc.) Note that the month is 0-indexed.\n   *\n   * @param year - The year\n   * @param month - The month. Note that the month is 0-indexed.\n   * @param date - The day of the month\n   * @param hours - The hours\n   * @param minutes - The minutes\n   * @param seconds - The seconds\n   * @param ms - The milliseconds\n   *\n   * @returns The date instance\n   */\n  new (\n    year: number,\n    month: number,\n    date?: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): DateType;\n}\n\n/**\n * The duration object. Contains the duration in the units specified by the\n * object.\n */\nexport interface Duration {\n  /** The number of years in the duration */\n  years?: number;\n  /** The number of months in the duration */\n  months?: number;\n  /** The number of weeks in the duration */\n  weeks?: number;\n  /** The number of days in the duration */\n  days?: number;\n  /** The number of hours in the duration */\n  hours?: number;\n  /** The number of minutes in the duration */\n  minutes?: number;\n  /** The number of seconds in the duration */\n  seconds?: number;\n}\n\n/**\n * The duration unit type alias.\n */\nexport type DurationUnit = keyof Duration;\n\n/**\n * An object that combines two dates to represent the time interval.\n *\n * @typeParam StartDate - The start `Date` type.\n * @typeParam EndDate - The end `Date` type.\n */\nexport interface Interval<\n  StartType extends DateArg<Date> = DateArg<Date>,\n  EndType extends DateArg<Date> = DateArg<Date>,\n> {\n  /** The start of the interval. */\n  start: StartType;\n  /** The end of the interval. */\n  end: EndType;\n}\n\n/**\n * A version of {@link Interval} that has both start and end resolved to Date.\n */\nexport type NormalizedInterval<DateType extends Date = Date> = Interval<\n  DateType,\n  DateType\n>;\n\n/**\n * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n */\nexport type Era = 0 | 1;\n\n/**\n * The year quarter. Goes from 1 to 4.\n */\nexport type Quarter = 1 | 2 | 3 | 4;\n\n/**\n * The day of the week type alias. Unlike the date (the number of days since\n * the beginning of the month), which begins with 1 and is dynamic (can go up to\n * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at\n * it as an index in an array where Sunday is the first element and Saturday\n * is the last.\n */\nexport type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * The month type alias. Goes from 0 to 11, where 0 is January and 11 is\n * December.\n */\nexport type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n\n/**\n * FirstWeekContainsDate is used to determine which week is the first week of\n * the year, based on what day the January, 1 is in that week.\n *\n * The day in that week can only be 1 (Monday) or 4 (Thursday).\n *\n * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.\n */\nexport type FirstWeekContainsDate = 1 | 4;\n\n/**\n * The date values, used to set or get date object values.\n */\nexport interface DateValues {\n  /** The year */\n  year?: number;\n  /** The month */\n  month?: number;\n  /** The day of the month */\n  date?: number;\n  /** The hours */\n  hours?: number;\n  /** The minutes */\n  minutes?: number;\n  /** The seconds */\n  seconds?: number;\n  /** The milliseconds */\n  milliseconds?: number;\n}\n\n/**\n * The number rounding method.\n */\nexport type RoundingMethod = \"ceil\" | \"floor\" | \"round\" | \"trunc\";\n\n/**\n * The ISO string format.\n *\n * - basic: Minimal number of separators\n * - extended: With separators added to enhance human readability\n */\nexport type ISOStringFormat = \"extended\" | \"basic\";\n\n/**\n * The ISO date representation. Represents which component the string includes,\n * date, time or both.\n */\nexport type ISOStringRepresentation = \"complete\" | \"date\" | \"time\";\n\n/// Function options types\n\n/**\n * The step function options. Used to build function options.\n */\nexport interface StepOptions {\n  /** The step to use when iterating */\n  step?: number;\n}\n\n/**\n * The week function options. Used to build function options.\n */\nexport interface WeekOptions {\n  /** Which day the week starts on. */\n  weekStartsOn?: Day;\n}\n\n/**\n * The first week contains date options. Used to build function options.\n */\nexport interface FirstWeekContainsDateOptions {\n  /** See {@link FirstWeekContainsDate} for more details. */\n  firstWeekContainsDate?: FirstWeekContainsDate;\n}\n\n/**\n * The localized function options. Used to build function options.\n *\n * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.\n */\nexport interface LocalizedOptions<LocaleFields extends keyof Locale> {\n  /** The locale to use in the function. */\n  locale?: Pick<Locale, LocaleFields>;\n}\n\n/**\n * The ISO format function options. Used to build function options.\n */\nexport interface ISOFormatOptions {\n  /** The format to use: basic with minimal number of separators or extended\n   * with separators added to enhance human readability */\n  format?: ISOStringFormat;\n  /** The date representation - what component to format: date, time\\\n   * or both (complete) */\n  representation?: ISOStringRepresentation;\n}\n\n/**\n * The rounding options. Used to build function options.\n */\nexport interface RoundingOptions {\n  /** The rounding method to use */\n  roundingMethod?: RoundingMethod;\n}\n\n/**\n * Additional tokens options. Used to build function options.\n */\nexport interface AdditionalTokensOptions {\n  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalWeekYearTokens?: boolean;\n  /** If true, allows usage of the day of year tokens `D` and `DD`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalDayOfYearTokens?: boolean;\n}\n\n/**\n * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30\n * is nearest half an hour.\n */\nexport type NearestMinutes =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28\n  | 29\n  | 30;\n\n/**\n * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12\n * is nearest half a day.\n */\nexport type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\n/**\n * The nearest minutes function options. Used to build function options.\n *\n * @deprecated Use {@link NearestToUnitOptions} instead.\n */\nexport type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;\n\n/**\n * The nearest unit function options. Used to build function options.\n */\nexport interface NearestToUnitOptions<Unit extends number> {\n  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter\n   * hours. */\n  nearestTo?: Unit;\n}\n\n/**\n * The context options. Used to build function options.\n */\nexport interface ContextOptions<DateType extends Date> {\n  /**\n   * The context to use in the function. It allows to normalize the arguments\n   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\n  in?: ContextFn<DateType> | undefined;\n}\n\n/**\n  /**\n   * The context function type. It's used to normalize the input arguments to\n   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\nexport type ContextFn<DateType extends Date> = (\n  value: DateArg<Date> & {},\n) => DateType;\n\n/**\n * Resolves passed type or array of types.\n */\nexport type MaybeArray<Type> = Type | Type[];\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it } from \"vitest\";\nimport { addSeconds } from \"./index.js\";\nimport { assertType } from \"../_lib/test/index.js\";\nimport { UTCDate } from \"@date-fns/utc\";\nimport { TZDate, tz } from \"@date-fns/tz\";\n\ndescribe(\"addSeconds\", () => {\n  it(\"adds the given number of seconds\", () => {\n    const result = addSeconds(new Date(2014, 6 /* Jul */, 10, 12, 45, 0), 30);\n    expect(result).toEqual(new Date(2014, 6 /* Jul */, 10, 12, 45, 30));\n  });\n\n  it(\"accepts a timestamp\", () => {\n    const result = addSeconds(\n      new Date(2014, 6 /* Jul */, 10, 12, 45, 0).getTime(),\n      20,\n    );\n    expect(result).toEqual(new Date(2014, 6 /* Jul */, 10, 12, 45, 20));\n  });\n\n  it(\"does not mutate the original date\", () => {\n    const date = new Date(2014, 6 /* Jul */, 10, 12, 45, 0);\n    addSeconds(date, 15);\n    expect(date).toEqual(new Date(2014, 6 /* Jul */, 10, 12, 45, 0));\n  });\n\n  it(\"returns `Invalid Date` if the given date is invalid\", () => {\n    const result = addSeconds(new Date(NaN), 30);\n    expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n  });\n\n  it(\"returns `Invalid Date` if the given amount is NaN\", () => {\n    const result = addSeconds(new Date(2014, 6 /* Jul */, 10, 12, 45, 0), NaN);\n    expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n  });\n\n  it(\"resolves the date type by default\", () => {\n    const result = addSeconds(Date.now(), 30);\n    expect(result).toBeInstanceOf(Date);\n    assertType<assertType.Equal<Date, typeof result>>(true);\n  });\n\n  it(\"resolves the argument type if a date extension is passed\", () => {\n    const result = addSeconds(new UTCDate(), 15);\n    expect(result).toBeInstanceOf(UTCDate);\n    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n  });\n\n  describe(\"context\", () => {\n    it(\"allows to specify the context and handles timezones correctly\", () => {\n      expect(\n        addSeconds(new Date(\"2024-08-18T15:00:00Z\"), 18000, {\n          in: tz(\"Asia/Singapore\"),\n        }).toISOString(),\n      ).toEqual(\"2024-08-19T04:00:00.000+08:00\");\n    });\n\n    it(\"resolves the context date type\", () => {\n      const result = addSeconds(\"2024-08-18T15:00:00Z\", 30, {\n        in: tz(\"Asia/Tokyo\"),\n      });\n      expect(result).toBeInstanceOf(TZDate);\n      assertType<assertType.Equal<TZDate, typeof result>>(true);\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\addWeeks\\addWeeks_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { addDays } from \"../addDays/index.js\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\n\n/**\n * The {@link addWeeks} function options.\n */\nexport interface AddWeeksOptions<DateType extends Date = Date>\n  extends ContextOptions<DateType> {}\n\n/**\n * @name addWeeks\n * @category Week Helpers\n * @summary Add the specified number of weeks to the given date.\n *\n * @description\n * Add the specified number of weeks to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of weeks to be added.\n * @param options - An object with options\n *\n * @returns The new date with the weeks added\n *\n * @example\n * // Add 4 weeks to 1 September 2014:\n * const result = addWeeks(new Date(2014, 8, 1), 4)\n * //=> Mon Sep 29 2014 00:00:00\n */\nexport function addWeeks<\n  DateType extends Date,\n  ResultDate extends Date = DateType,\n>(\n  date: DateArg<DateType>,\n  amount: number,\n  options?: AddWeeksOptions<ResultDate> | undefined,\n): ResultDate {\n  return addDays(date, amount * 7, options);\n}\n\n### Source File Dependency Files Content\n### Dependency File: addDays_index.ts\nimport { constructFrom } from \"../constructFrom/index.js\";\nimport { toDate } from \"../toDate/index.js\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\n\n/**\n * The {@link addDays} function options.\n */\nexport interface AddDaysOptions<DateType extends Date = Date>\n  extends ContextOptions<DateType> {}\n\n/**\n * @name addDays\n * @category Day Helpers\n * @summary Add the specified number of days to the given date.\n *\n * @description\n * Add the specified number of days to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of days to be added.\n * @param options - An object with options\n *\n * @returns The new date with the days added\n *\n * @example\n * // Add 10 days to 1 September 2014:\n * const result = addDays(new Date(2014, 8, 1), 10)\n * //=> Thu Sep 11 2014 00:00:00\n */\nexport function addDays<\n  DateType extends Date,\n  ResultDate extends Date = DateType,\n>(\n  date: DateArg<DateType>,\n  amount: number,\n  options?: AddDaysOptions<ResultDate> | undefined,\n): ResultDate {\n  const _date = toDate(date, options?.in);\n  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);\n\n  // If 0 days, no-op to avoid changing times in the hour before end of DST\n  if (!amount) return _date;\n\n  _date.setDate(_date.getDate() + amount);\n  return _date;\n}\n\n\n### Dependency File: src_types.ts\nimport { type constructFromSymbol } from \"./constants/index.js\";\nimport type { Locale } from \"./locale/types.js\";\n\nexport type * from \"./fp/types.js\";\nexport type * from \"./locale/types.js\";\n\n/**\n * The argument type.\n */\nexport type DateArg<DateType extends Date> = DateType | number | string;\n\n/**\n * Date extension interface that allows to transfer extra properties from\n * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n */\nexport interface ConstructableDate extends Date {\n  [constructFromSymbol]: <DateType extends Date = Date>(\n    value: DateArg<Date> & {},\n  ) => DateType;\n}\n\n/**\n * The generic date constructor. Replicates the Date constructor. Used to build\n * generic functions.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n */\nexport interface GenericDateConstructor<DateType extends Date = Date> {\n  /**\n   * The date constructor. Creates date with the current date and time.\n   *\n   * @returns The date instance\n   */\n  new (): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date, number of\n   * milliseconds or string to parse.\n   *\n   * @param value - The date, number of milliseconds or string to parse\n   *\n   * @returns The date instance\n   */\n  new (value: DateArg<Date> & {}): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date values (year,\n   * month, etc.) Note that the month is 0-indexed.\n   *\n   * @param year - The year\n   * @param month - The month. Note that the month is 0-indexed.\n   * @param date - The day of the month\n   * @param hours - The hours\n   * @param minutes - The minutes\n   * @param seconds - The seconds\n   * @param ms - The milliseconds\n   *\n   * @returns The date instance\n   */\n  new (\n    year: number,\n    month: number,\n    date?: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): DateType;\n}\n\n/**\n * The duration object. Contains the duration in the units specified by the\n * object.\n */\nexport interface Duration {\n  /** The number of years in the duration */\n  years?: number;\n  /** The number of months in the duration */\n  months?: number;\n  /** The number of weeks in the duration */\n  weeks?: number;\n  /** The number of days in the duration */\n  days?: number;\n  /** The number of hours in the duration */\n  hours?: number;\n  /** The number of minutes in the duration */\n  minutes?: number;\n  /** The number of seconds in the duration */\n  seconds?: number;\n}\n\n/**\n * The duration unit type alias.\n */\nexport type DurationUnit = keyof Duration;\n\n/**\n * An object that combines two dates to represent the time interval.\n *\n * @typeParam StartDate - The start `Date` type.\n * @typeParam EndDate - The end `Date` type.\n */\nexport interface Interval<\n  StartType extends DateArg<Date> = DateArg<Date>,\n  EndType extends DateArg<Date> = DateArg<Date>,\n> {\n  /** The start of the interval. */\n  start: StartType;\n  /** The end of the interval. */\n  end: EndType;\n}\n\n/**\n * A version of {@link Interval} that has both start and end resolved to Date.\n */\nexport type NormalizedInterval<DateType extends Date = Date> = Interval<\n  DateType,\n  DateType\n>;\n\n/**\n * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n */\nexport type Era = 0 | 1;\n\n/**\n * The year quarter. Goes from 1 to 4.\n */\nexport type Quarter = 1 | 2 | 3 | 4;\n\n/**\n * The day of the week type alias. Unlike the date (the number of days since\n * the beginning of the month), which begins with 1 and is dynamic (can go up to\n * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at\n * it as an index in an array where Sunday is the first element and Saturday\n * is the last.\n */\nexport type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * The month type alias. Goes from 0 to 11, where 0 is January and 11 is\n * December.\n */\nexport type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n\n/**\n * FirstWeekContainsDate is used to determine which week is the first week of\n * the year, based on what day the January, 1 is in that week.\n *\n * The day in that week can only be 1 (Monday) or 4 (Thursday).\n *\n * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.\n */\nexport type FirstWeekContainsDate = 1 | 4;\n\n/**\n * The date values, used to set or get date object values.\n */\nexport interface DateValues {\n  /** The year */\n  year?: number;\n  /** The month */\n  month?: number;\n  /** The day of the month */\n  date?: number;\n  /** The hours */\n  hours?: number;\n  /** The minutes */\n  minutes?: number;\n  /** The seconds */\n  seconds?: number;\n  /** The milliseconds */\n  milliseconds?: number;\n}\n\n/**\n * The number rounding method.\n */\nexport type RoundingMethod = \"ceil\" | \"floor\" | \"round\" | \"trunc\";\n\n/**\n * The ISO string format.\n *\n * - basic: Minimal number of separators\n * - extended: With separators added to enhance human readability\n */\nexport type ISOStringFormat = \"extended\" | \"basic\";\n\n/**\n * The ISO date representation. Represents which component the string includes,\n * date, time or both.\n */\nexport type ISOStringRepresentation = \"complete\" | \"date\" | \"time\";\n\n/// Function options types\n\n/**\n * The step function options. Used to build function options.\n */\nexport interface StepOptions {\n  /** The step to use when iterating */\n  step?: number;\n}\n\n/**\n * The week function options. Used to build function options.\n */\nexport interface WeekOptions {\n  /** Which day the week starts on. */\n  weekStartsOn?: Day;\n}\n\n/**\n * The first week contains date options. Used to build function options.\n */\nexport interface FirstWeekContainsDateOptions {\n  /** See {@link FirstWeekContainsDate} for more details. */\n  firstWeekContainsDate?: FirstWeekContainsDate;\n}\n\n/**\n * The localized function options. Used to build function options.\n *\n * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.\n */\nexport interface LocalizedOptions<LocaleFields extends keyof Locale> {\n  /** The locale to use in the function. */\n  locale?: Pick<Locale, LocaleFields>;\n}\n\n/**\n * The ISO format function options. Used to build function options.\n */\nexport interface ISOFormatOptions {\n  /** The format to use: basic with minimal number of separators or extended\n   * with separators added to enhance human readability */\n  format?: ISOStringFormat;\n  /** The date representation - what component to format: date, time\\\n   * or both (complete) */\n  representation?: ISOStringRepresentation;\n}\n\n/**\n * The rounding options. Used to build function options.\n */\nexport interface RoundingOptions {\n  /** The rounding method to use */\n  roundingMethod?: RoundingMethod;\n}\n\n/**\n * Additional tokens options. Used to build function options.\n */\nexport interface AdditionalTokensOptions {\n  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalWeekYearTokens?: boolean;\n  /** If true, allows usage of the day of year tokens `D` and `DD`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalDayOfYearTokens?: boolean;\n}\n\n/**\n * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30\n * is nearest half an hour.\n */\nexport type NearestMinutes =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28\n  | 29\n  | 30;\n\n/**\n * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12\n * is nearest half a day.\n */\nexport type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\n/**\n * The nearest minutes function options. Used to build function options.\n *\n * @deprecated Use {@link NearestToUnitOptions} instead.\n */\nexport type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;\n\n/**\n * The nearest unit function options. Used to build function options.\n */\nexport interface NearestToUnitOptions<Unit extends number> {\n  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter\n   * hours. */\n  nearestTo?: Unit;\n}\n\n/**\n * The context options. Used to build function options.\n */\nexport interface ContextOptions<DateType extends Date> {\n  /**\n   * The context to use in the function. It allows to normalize the arguments\n   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\n  in?: ContextFn<DateType> | undefined;\n}\n\n/**\n  /**\n   * The context function type. It's used to normalize the input arguments to\n   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\nexport type ContextFn<DateType extends Date> = (\n  value: DateArg<Date> & {},\n) => DateType;\n\n/**\n * Resolves passed type or array of types.\n */\nexport type MaybeArray<Type> = Type | Type[];\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { TZDate, tz } from \"@date-fns/tz\";\nimport { describe, expect, it } from \"vitest\";\nimport { addWeeks } from \"./index.js\";\nimport { assertType } from \"../_lib/test/index.js\";\n\ndescribe(\"addWeeks\", () => {\n  it(\"adds the given number of weeks\", () => {\n    const result = addWeeks(new Date(2014, 8 /* Sep */, 1), 4);\n    expect(result).toEqual(new Date(2014, 8 /* Sep */, 29));\n  });\n\n  it(\"accepts a timestamp\", () => {\n    const result = addWeeks(new Date(2014, 8 /* Sep */, 1).getTime(), 1);\n    expect(result).toEqual(new Date(2014, 8 /* Sep */, 8));\n  });\n\n  it(\"does not mutate the original date\", () => {\n    const date = new Date(2014, 8 /* Sep */, 1);\n    addWeeks(date, 2);\n    expect(date).toEqual(new Date(2014, 8 /* Sep */, 1));\n  });\n\n  it(\"returns `Invalid Date` if the given date is invalid\", () => {\n    const result = addWeeks(new Date(NaN), 4);\n    expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n  });\n\n  it(\"returns `Invalid Date` if the given amount is NaN\", () => {\n    const result = addWeeks(new Date(2014, 8 /* Sep */, 1), NaN);\n    expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n  });\n\n  describe(\"context\", () => {\n    it(\"allows to specify the context\", () => {\n      expect(\n        addWeeks(\"2024-04-01T15:00:00Z\", 1, {\n          in: tz(\"Asia/Singapore\"),\n        }).toISOString(),\n      ).toBe(\"2024-04-08T23:00:00.000+08:00\");\n      expect(\n        addWeeks(\"2024-04-01T16:00:00Z\", 1, {\n          in: tz(\"Asia/Singapore\"),\n        }).toISOString(),\n      ).toBe(\"2024-04-09T00:00:00.000+08:00\");\n    });\n\n    it(\"resolves the context date type\", () => {\n      const result = addWeeks(new Date(\"2014-09-01T00:00:00Z\"), 1, {\n        in: tz(\"Asia/Tokyo\"),\n      });\n      expect(result).toBeInstanceOf(TZDate);\n      assertType<assertType.Equal<TZDate, typeof result>>(true);\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\addYears\\addYears_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { addMonths } from \"../addMonths/index.js\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\n\n/**\n * The {@link addYears} function options.\n */\nexport interface AddYearsOptions<DateType extends Date = Date>\n  extends ContextOptions<DateType> {}\n\n/**\n * @name addYears\n * @category Year Helpers\n * @summary Add the specified number of years to the given date.\n *\n * @description\n * Add the specified number of years to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type.\n *\n * @param date - The date to be changed\n * @param amount - The amount of years to be added.\n * @param options - The options\n *\n * @returns The new date with the years added\n *\n * @example\n * // Add 5 years to 1 September 2014:\n * const result = addYears(new Date(2014, 8, 1), 5)\n * //=> Sun Sep 01 2019 00:00:00\n */\nexport function addYears<\n  DateType extends Date,\n  ResultDate extends Date = DateType,\n>(\n  date: DateArg<DateType>,\n  amount: number,\n  options?: AddYearsOptions<ResultDate> | undefined,\n): ResultDate {\n  return addMonths(date, amount * 12, options);\n}\n\n### Source File Dependency Files Content\n### Dependency File: addMonths_index.ts\nimport { constructFrom } from \"../constructFrom/index.js\";\nimport { toDate } from \"../toDate/index.js\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\n\n/**\n * The {@link addMonths} function options.\n */\nexport interface AddMonthsOptions<DateType extends Date = Date>\n  extends ContextOptions<DateType> {}\n\n/**\n * @name addMonths\n * @category Month Helpers\n * @summary Add the specified number of months to the given date.\n *\n * @description\n * Add the specified number of months to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of months to be added.\n * @param options - The options object\n *\n * @returns The new date with the months added\n *\n * @example\n * // Add 5 months to 1 September 2014:\n * const result = addMonths(new Date(2014, 8, 1), 5)\n * //=> Sun Feb 01 2015 00:00:00\n *\n * // Add one month to 30 January 2023:\n * const result = addMonths(new Date(2023, 0, 30), 1)\n * //=> Tue Feb 28 2023 00:00:00\n */\nexport function addMonths<\n  DateType extends Date,\n  ResultDate extends Date = DateType,\n>(\n  date: DateArg<DateType>,\n  amount: number,\n  options?: AddMonthsOptions<ResultDate> | undefined,\n): ResultDate {\n  const _date = toDate(date, options?.in);\n  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);\n  if (!amount) {\n    // If 0 months, no-op to avoid changing times in the hour before end of DST\n    return _date;\n  }\n  const dayOfMonth = _date.getDate();\n\n  // The JS Date object supports date math by accepting out-of-bounds values for\n  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and\n  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we\n  // want except that dates will wrap around the end of a month, meaning that\n  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So\n  // we'll default to the end of the desired month by adding 1 to the desired\n  // month and using a date of 0 to back up one day to the end of the desired\n  // month.\n  const endOfDesiredMonth = constructFrom(options?.in || date, _date.getTime());\n  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);\n  const daysInMonth = endOfDesiredMonth.getDate();\n  if (dayOfMonth >= daysInMonth) {\n    // If we're already at the end of the month, then this is the correct date\n    // and we're done.\n    return endOfDesiredMonth;\n  } else {\n    // Otherwise, we now know that setting the original day-of-month value won't\n    // cause an overflow, so set the desired day-of-month. Note that we can't\n    // just set the date of `endOfDesiredMonth` because that object may have had\n    // its time changed in the unusual case where where a DST transition was on\n    // the last day of the month and its local time was in the hour skipped or\n    // repeated next to a DST transition.  So we use `date` instead which is\n    // guaranteed to still have the original time.\n    _date.setFullYear(\n      endOfDesiredMonth.getFullYear(),\n      endOfDesiredMonth.getMonth(),\n      dayOfMonth,\n    );\n    return _date;\n  }\n}\n\n\n### Dependency File: src_types.ts\nimport { type constructFromSymbol } from \"./constants/index.js\";\nimport type { Locale } from \"./locale/types.js\";\n\nexport type * from \"./fp/types.js\";\nexport type * from \"./locale/types.js\";\n\n/**\n * The argument type.\n */\nexport type DateArg<DateType extends Date> = DateType | number | string;\n\n/**\n * Date extension interface that allows to transfer extra properties from\n * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n */\nexport interface ConstructableDate extends Date {\n  [constructFromSymbol]: <DateType extends Date = Date>(\n    value: DateArg<Date> & {},\n  ) => DateType;\n}\n\n/**\n * The generic date constructor. Replicates the Date constructor. Used to build\n * generic functions.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n */\nexport interface GenericDateConstructor<DateType extends Date = Date> {\n  /**\n   * The date constructor. Creates date with the current date and time.\n   *\n   * @returns The date instance\n   */\n  new (): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date, number of\n   * milliseconds or string to parse.\n   *\n   * @param value - The date, number of milliseconds or string to parse\n   *\n   * @returns The date instance\n   */\n  new (value: DateArg<Date> & {}): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date values (year,\n   * month, etc.) Note that the month is 0-indexed.\n   *\n   * @param year - The year\n   * @param month - The month. Note that the month is 0-indexed.\n   * @param date - The day of the month\n   * @param hours - The hours\n   * @param minutes - The minutes\n   * @param seconds - The seconds\n   * @param ms - The milliseconds\n   *\n   * @returns The date instance\n   */\n  new (\n    year: number,\n    month: number,\n    date?: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): DateType;\n}\n\n/**\n * The duration object. Contains the duration in the units specified by the\n * object.\n */\nexport interface Duration {\n  /** The number of years in the duration */\n  years?: number;\n  /** The number of months in the duration */\n  months?: number;\n  /** The number of weeks in the duration */\n  weeks?: number;\n  /** The number of days in the duration */\n  days?: number;\n  /** The number of hours in the duration */\n  hours?: number;\n  /** The number of minutes in the duration */\n  minutes?: number;\n  /** The number of seconds in the duration */\n  seconds?: number;\n}\n\n/**\n * The duration unit type alias.\n */\nexport type DurationUnit = keyof Duration;\n\n/**\n * An object that combines two dates to represent the time interval.\n *\n * @typeParam StartDate - The start `Date` type.\n * @typeParam EndDate - The end `Date` type.\n */\nexport interface Interval<\n  StartType extends DateArg<Date> = DateArg<Date>,\n  EndType extends DateArg<Date> = DateArg<Date>,\n> {\n  /** The start of the interval. */\n  start: StartType;\n  /** The end of the interval. */\n  end: EndType;\n}\n\n/**\n * A version of {@link Interval} that has both start and end resolved to Date.\n */\nexport type NormalizedInterval<DateType extends Date = Date> = Interval<\n  DateType,\n  DateType\n>;\n\n/**\n * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n */\nexport type Era = 0 | 1;\n\n/**\n * The year quarter. Goes from 1 to 4.\n */\nexport type Quarter = 1 | 2 | 3 | 4;\n\n/**\n * The day of the week type alias. Unlike the date (the number of days since\n * the beginning of the month), which begins with 1 and is dynamic (can go up to\n * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at\n * it as an index in an array where Sunday is the first element and Saturday\n * is the last.\n */\nexport type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * The month type alias. Goes from 0 to 11, where 0 is January and 11 is\n * December.\n */\nexport type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n\n/**\n * FirstWeekContainsDate is used to determine which week is the first week of\n * the year, based on what day the January, 1 is in that week.\n *\n * The day in that week can only be 1 (Monday) or 4 (Thursday).\n *\n * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.\n */\nexport type FirstWeekContainsDate = 1 | 4;\n\n/**\n * The date values, used to set or get date object values.\n */\nexport interface DateValues {\n  /** The year */\n  year?: number;\n  /** The month */\n  month?: number;\n  /** The day of the month */\n  date?: number;\n  /** The hours */\n  hours?: number;\n  /** The minutes */\n  minutes?: number;\n  /** The seconds */\n  seconds?: number;\n  /** The milliseconds */\n  milliseconds?: number;\n}\n\n/**\n * The number rounding method.\n */\nexport type RoundingMethod = \"ceil\" | \"floor\" | \"round\" | \"trunc\";\n\n/**\n * The ISO string format.\n *\n * - basic: Minimal number of separators\n * - extended: With separators added to enhance human readability\n */\nexport type ISOStringFormat = \"extended\" | \"basic\";\n\n/**\n * The ISO date representation. Represents which component the string includes,\n * date, time or both.\n */\nexport type ISOStringRepresentation = \"complete\" | \"date\" | \"time\";\n\n/// Function options types\n\n/**\n * The step function options. Used to build function options.\n */\nexport interface StepOptions {\n  /** The step to use when iterating */\n  step?: number;\n}\n\n/**\n * The week function options. Used to build function options.\n */\nexport interface WeekOptions {\n  /** Which day the week starts on. */\n  weekStartsOn?: Day;\n}\n\n/**\n * The first week contains date options. Used to build function options.\n */\nexport interface FirstWeekContainsDateOptions {\n  /** See {@link FirstWeekContainsDate} for more details. */\n  firstWeekContainsDate?: FirstWeekContainsDate;\n}\n\n/**\n * The localized function options. Used to build function options.\n *\n * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.\n */\nexport interface LocalizedOptions<LocaleFields extends keyof Locale> {\n  /** The locale to use in the function. */\n  locale?: Pick<Locale, LocaleFields>;\n}\n\n/**\n * The ISO format function options. Used to build function options.\n */\nexport interface ISOFormatOptions {\n  /** The format to use: basic with minimal number of separators or extended\n   * with separators added to enhance human readability */\n  format?: ISOStringFormat;\n  /** The date representation - what component to format: date, time\\\n   * or both (complete) */\n  representation?: ISOStringRepresentation;\n}\n\n/**\n * The rounding options. Used to build function options.\n */\nexport interface RoundingOptions {\n  /** The rounding method to use */\n  roundingMethod?: RoundingMethod;\n}\n\n/**\n * Additional tokens options. Used to build function options.\n */\nexport interface AdditionalTokensOptions {\n  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalWeekYearTokens?: boolean;\n  /** If true, allows usage of the day of year tokens `D` and `DD`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalDayOfYearTokens?: boolean;\n}\n\n/**\n * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30\n * is nearest half an hour.\n */\nexport type NearestMinutes =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28\n  | 29\n  | 30;\n\n/**\n * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12\n * is nearest half a day.\n */\nexport type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\n/**\n * The nearest minutes function options. Used to build function options.\n *\n * @deprecated Use {@link NearestToUnitOptions} instead.\n */\nexport type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;\n\n/**\n * The nearest unit function options. Used to build function options.\n */\nexport interface NearestToUnitOptions<Unit extends number> {\n  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter\n   * hours. */\n  nearestTo?: Unit;\n}\n\n/**\n * The context options. Used to build function options.\n */\nexport interface ContextOptions<DateType extends Date> {\n  /**\n   * The context to use in the function. It allows to normalize the arguments\n   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\n  in?: ContextFn<DateType> | undefined;\n}\n\n/**\n  /**\n   * The context function type. It's used to normalize the input arguments to\n   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\nexport type ContextFn<DateType extends Date> = (\n  value: DateArg<Date> & {},\n) => DateType;\n\n/**\n * Resolves passed type or array of types.\n */\nexport type MaybeArray<Type> = Type | Type[];\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { TZDate, tz } from \"@date-fns/tz\";\nimport { UTCDate } from \"@date-fns/utc\";\nimport { describe, expect, it } from \"vitest\";\nimport { assertType } from \"../_lib/test/index.js\";\nimport { addYears } from \"./index.js\";\n\ndescribe(\"addYears\", () => {\n  it(\"adds the given number of years\", () => {\n    const result = addYears(new Date(2014, 8 /* Sep */, 1), 5);\n    expect(result).toEqual(new Date(2019, 8 /* Sep */, 1));\n  });\n\n  it(\"accepts a timestamp\", () => {\n    const result = addYears(new Date(2014, 8 /* Sep */, 1).getTime(), 12);\n    expect(result).toEqual(new Date(2026, 8 /* Sep */, 1));\n  });\n\n  it(\"does not mutate the original date\", () => {\n    const date = new Date(2014, 8 /* Sep */, 1);\n    addYears(date, 12);\n    expect(date).toEqual(new Date(2014, 8 /* Sep */, 1));\n  });\n\n  it(\"handles the leap years properly\", () => {\n    const result = addYears(new Date(2016, 1 /* Feb */, 29), 1);\n    expect(result).toEqual(new Date(2017, 1 /* Feb */, 28));\n  });\n\n  it(\"handles dates before 100 AD\", () => {\n    const initialDate = new Date(0);\n    initialDate.setFullYear(0, 1 /* Feb */, 29);\n    initialDate.setHours(0, 0, 0, 0);\n    const expectedResult = new Date(0);\n    expectedResult.setFullYear(1, 1 /* Feb */, 28);\n    expectedResult.setHours(0, 0, 0, 0);\n    const result = addYears(initialDate, 1);\n    expect(result).toEqual(expectedResult);\n  });\n\n  it(\"returns `Invalid Date` if the given date is invalid\", () => {\n    const result = addYears(new Date(NaN), 5);\n    expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n  });\n\n  it(\"returns `Invalid Date` if the given amount is NaN\", () => {\n    const result = addYears(new Date(2014, 8 /* Sep */, 1), NaN);\n    expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n  });\n\n  it(\"resolves the date type by default\", () => {\n    const result = addYears(Date.now(), 5);\n    expect(result).toBeInstanceOf(Date);\n    assertType<assertType.Equal<Date, typeof result>>(true);\n  });\n\n  it(\"resolves the argument type if a date extension is passed\", () => {\n    const result = addYears(new UTCDate(), 5);\n    expect(result).toBeInstanceOf(UTCDate);\n    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n  });\n\n  describe(\"context\", () => {\n    it(\"allows specifying the context\", () => {\n      expect(\n        addYears(\"2024-04-10T07:00:00Z\", 5, {\n          in: tz(\"America/Los_Angeles\"),\n        }).toISOString(),\n      ).toBe(\"2029-04-10T00:00:00.000-07:00\");\n    });\n\n    it(\"resolves the context date type\", () => {\n      const result = addYears(\"2014-09-01T00:00:00Z\", 1, {\n        in: tz(\"Asia/Tokyo\"),\n      });\n      expect(result).toBeInstanceOf(TZDate);\n      assertType<assertType.Equal<TZDate, typeof result>>(true);\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\closestIndexTo\\closestIndexTo_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { toDate } from \"../toDate/index.js\";\nimport type { DateArg } from \"../types.js\";\n\n/**\n * @name closestIndexTo\n * @category Common Helpers\n * @summary Return an index of the closest date from the array comparing to the given date.\n *\n * @description\n * Return an index of the closest date from the array comparing to the given date.\n *\n * @param dateToCompare - The date to compare with\n * @param dates - The array to search\n *\n * @returns An index of the date closest to the given date or undefined if no valid value is given\n *\n * @example\n * // Which date is closer to 6 September 2015?\n * const dateToCompare = new Date(2015, 8, 6)\n * const datesArray = [\n *   new Date(2015, 0, 1),\n *   new Date(2016, 0, 1),\n *   new Date(2017, 0, 1)\n * ]\n * const result = closestIndexTo(dateToCompare, datesArray)\n * //=> 1\n */\nexport function closestIndexTo(\n  dateToCompare: DateArg<Date> & {},\n  dates: Array<DateArg<Date> & {}>,\n): number | undefined {\n  // [TODO] It would be better to return -1 here rather than undefined, as this\n  // is how JS behaves, but it would be a breaking change, so we need\n  // to consider it for v4.\n  const timeToCompare = +toDate(dateToCompare);\n\n  if (isNaN(timeToCompare)) return NaN;\n\n  let result: number | undefined;\n  let minDistance: number;\n  dates.forEach((date, index) => {\n    const date_ = toDate(date);\n\n    if (isNaN(+date_)) {\n      result = NaN;\n      minDistance = NaN;\n      return;\n    }\n\n    const distance = Math.abs(timeToCompare - +date_);\n    if (result == null || distance < minDistance) {\n      result = index;\n      minDistance = distance;\n    }\n  });\n\n  return result;\n}\n\n### Source File Dependency Files Content\n### Dependency File: src_types.ts\nimport { type constructFromSymbol } from \"./constants/index.js\";\nimport type { Locale } from \"./locale/types.js\";\n\nexport type * from \"./fp/types.js\";\nexport type * from \"./locale/types.js\";\n\n/**\n * The argument type.\n */\nexport type DateArg<DateType extends Date> = DateType | number | string;\n\n/**\n * Date extension interface that allows to transfer extra properties from\n * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n */\nexport interface ConstructableDate extends Date {\n  [constructFromSymbol]: <DateType extends Date = Date>(\n    value: DateArg<Date> & {},\n  ) => DateType;\n}\n\n/**\n * The generic date constructor. Replicates the Date constructor. Used to build\n * generic functions.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n */\nexport interface GenericDateConstructor<DateType extends Date = Date> {\n  /**\n   * The date constructor. Creates date with the current date and time.\n   *\n   * @returns The date instance\n   */\n  new (): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date, number of\n   * milliseconds or string to parse.\n   *\n   * @param value - The date, number of milliseconds or string to parse\n   *\n   * @returns The date instance\n   */\n  new (value: DateArg<Date> & {}): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date values (year,\n   * month, etc.) Note that the month is 0-indexed.\n   *\n   * @param year - The year\n   * @param month - The month. Note that the month is 0-indexed.\n   * @param date - The day of the month\n   * @param hours - The hours\n   * @param minutes - The minutes\n   * @param seconds - The seconds\n   * @param ms - The milliseconds\n   *\n   * @returns The date instance\n   */\n  new (\n    year: number,\n    month: number,\n    date?: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): DateType;\n}\n\n/**\n * The duration object. Contains the duration in the units specified by the\n * object.\n */\nexport interface Duration {\n  /** The number of years in the duration */\n  years?: number;\n  /** The number of months in the duration */\n  months?: number;\n  /** The number of weeks in the duration */\n  weeks?: number;\n  /** The number of days in the duration */\n  days?: number;\n  /** The number of hours in the duration */\n  hours?: number;\n  /** The number of minutes in the duration */\n  minutes?: number;\n  /** The number of seconds in the duration */\n  seconds?: number;\n}\n\n/**\n * The duration unit type alias.\n */\nexport type DurationUnit = keyof Duration;\n\n/**\n * An object that combines two dates to represent the time interval.\n *\n * @typeParam StartDate - The start `Date` type.\n * @typeParam EndDate - The end `Date` type.\n */\nexport interface Interval<\n  StartType extends DateArg<Date> = DateArg<Date>,\n  EndType extends DateArg<Date> = DateArg<Date>,\n> {\n  /** The start of the interval. */\n  start: StartType;\n  /** The end of the interval. */\n  end: EndType;\n}\n\n/**\n * A version of {@link Interval} that has both start and end resolved to Date.\n */\nexport type NormalizedInterval<DateType extends Date = Date> = Interval<\n  DateType,\n  DateType\n>;\n\n/**\n * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n */\nexport type Era = 0 | 1;\n\n/**\n * The year quarter. Goes from 1 to 4.\n */\nexport type Quarter = 1 | 2 | 3 | 4;\n\n/**\n * The day of the week type alias. Unlike the date (the number of days since\n * the beginning of the month), which begins with 1 and is dynamic (can go up to\n * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at\n * it as an index in an array where Sunday is the first element and Saturday\n * is the last.\n */\nexport type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * The month type alias. Goes from 0 to 11, where 0 is January and 11 is\n * December.\n */\nexport type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n\n/**\n * FirstWeekContainsDate is used to determine which week is the first week of\n * the year, based on what day the January, 1 is in that week.\n *\n * The day in that week can only be 1 (Monday) or 4 (Thursday).\n *\n * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.\n */\nexport type FirstWeekContainsDate = 1 | 4;\n\n/**\n * The date values, used to set or get date object values.\n */\nexport interface DateValues {\n  /** The year */\n  year?: number;\n  /** The month */\n  month?: number;\n  /** The day of the month */\n  date?: number;\n  /** The hours */\n  hours?: number;\n  /** The minutes */\n  minutes?: number;\n  /** The seconds */\n  seconds?: number;\n  /** The milliseconds */\n  milliseconds?: number;\n}\n\n/**\n * The number rounding method.\n */\nexport type RoundingMethod = \"ceil\" | \"floor\" | \"round\" | \"trunc\";\n\n/**\n * The ISO string format.\n *\n * - basic: Minimal number of separators\n * - extended: With separators added to enhance human readability\n */\nexport type ISOStringFormat = \"extended\" | \"basic\";\n\n/**\n * The ISO date representation. Represents which component the string includes,\n * date, time or both.\n */\nexport type ISOStringRepresentation = \"complete\" | \"date\" | \"time\";\n\n/// Function options types\n\n/**\n * The step function options. Used to build function options.\n */\nexport interface StepOptions {\n  /** The step to use when iterating */\n  step?: number;\n}\n\n/**\n * The week function options. Used to build function options.\n */\nexport interface WeekOptions {\n  /** Which day the week starts on. */\n  weekStartsOn?: Day;\n}\n\n/**\n * The first week contains date options. Used to build function options.\n */\nexport interface FirstWeekContainsDateOptions {\n  /** See {@link FirstWeekContainsDate} for more details. */\n  firstWeekContainsDate?: FirstWeekContainsDate;\n}\n\n/**\n * The localized function options. Used to build function options.\n *\n * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.\n */\nexport interface LocalizedOptions<LocaleFields extends keyof Locale> {\n  /** The locale to use in the function. */\n  locale?: Pick<Locale, LocaleFields>;\n}\n\n/**\n * The ISO format function options. Used to build function options.\n */\nexport interface ISOFormatOptions {\n  /** The format to use: basic with minimal number of separators or extended\n   * with separators added to enhance human readability */\n  format?: ISOStringFormat;\n  /** The date representation - what component to format: date, time\\\n   * or both (complete) */\n  representation?: ISOStringRepresentation;\n}\n\n/**\n * The rounding options. Used to build function options.\n */\nexport interface RoundingOptions {\n  /** The rounding method to use */\n  roundingMethod?: RoundingMethod;\n}\n\n/**\n * Additional tokens options. Used to build function options.\n */\nexport interface AdditionalTokensOptions {\n  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalWeekYearTokens?: boolean;\n  /** If true, allows usage of the day of year tokens `D` and `DD`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalDayOfYearTokens?: boolean;\n}\n\n/**\n * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30\n * is nearest half an hour.\n */\nexport type NearestMinutes =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28\n  | 29\n  | 30;\n\n/**\n * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12\n * is nearest half a day.\n */\nexport type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\n/**\n * The nearest minutes function options. Used to build function options.\n *\n * @deprecated Use {@link NearestToUnitOptions} instead.\n */\nexport type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;\n\n/**\n * The nearest unit function options. Used to build function options.\n */\nexport interface NearestToUnitOptions<Unit extends number> {\n  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter\n   * hours. */\n  nearestTo?: Unit;\n}\n\n/**\n * The context options. Used to build function options.\n */\nexport interface ContextOptions<DateType extends Date> {\n  /**\n   * The context to use in the function. It allows to normalize the arguments\n   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\n  in?: ContextFn<DateType> | undefined;\n}\n\n/**\n  /**\n   * The context function type. It's used to normalize the input arguments to\n   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\nexport type ContextFn<DateType extends Date> = (\n  value: DateArg<Date> & {},\n) => DateType;\n\n/**\n * Resolves passed type or array of types.\n */\nexport type MaybeArray<Type> = Type | Type[];\n\n\n### Dependency File: toDate_index.ts\nimport { constructFrom } from \"../constructFrom/index.js\";\nimport type { ConstructableDate, ContextFn, DateArg } from \"../types.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate<\n  DateType extends Date | ConstructableDate,\n  ResultDate extends Date = DateType,\n>(\n  argument: DateArg<DateType>,\n  context?: ContextFn<ResultDate> | undefined,\n): ResultDate {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it } from \"vitest\";\nimport { closestIndexTo } from \"./index.js\";\n\ndescribe(\"closestIndexTo\", () => {\n  it(\"returns the date index from the given array closest to the given date\", () => {\n    const date = new Date(2014, 6 /* Jul */, 2);\n    const result = closestIndexTo(date, [\n      new Date(2015, 7 /* Aug */, 31),\n      new Date(2012, 6 /* Jul */, 2),\n    ]);\n    expect(result).toBe(0);\n  });\n\n  it(\"works if the closest date from the given array is before the given date\", () => {\n    const date = new Date(2014, 6 /* Jul */, 2, 6, 30, 4, 500);\n    const result = closestIndexTo(date, [\n      new Date(2014, 6 /* Jul */, 2, 6, 30, 5, 900),\n      new Date(2014, 6 /* Jul */, 2, 6, 30, 3, 900),\n      new Date(2014, 6 /* Jul */, 2, 6, 30, 10),\n    ]);\n    expect(result).toBe(1);\n  });\n\n  it(\"accepts timestamps\", () => {\n    const date = new Date(2014, 6 /* Jul */, 2).getTime();\n    const result = closestIndexTo(date, [\n      new Date(2015, 7 /* Aug */, 31).getTime(),\n      new Date(2012, 6 /* Jul */, 2).getTime(),\n    ]);\n    expect(result).toBe(0);\n  });\n\n  it(\"returns undefined if the given array is empty\", () => {\n    const date = new Date(2014, 6 /* Jul */, 2).getTime();\n    const result = closestIndexTo(date, []);\n    expect(result).toBe(undefined);\n  });\n\n  it(\"returns NaN if the given date is `Invalid Date`\", () => {\n    const date = new Date(NaN);\n    const result = closestIndexTo(date, [\n      new Date(2015, 7 /* Aug */, 31),\n      new Date(2012, 6 /* Jul */, 2),\n    ]);\n    expect(result != null && isNaN(result)).toBe(true);\n  });\n\n  it(\"returns NaN if any date in the given array is `Invalid Date`\", () => {\n    const date = new Date(2014, 6 /* Jul */, 2);\n    const result = closestIndexTo(date, [\n      new Date(2015, 7 /* Aug */, 31),\n      new Date(NaN),\n      new Date(2012, 6 /* Jul */, 2),\n    ]);\n    expect(result != null && isNaN(result)).toBe(true);\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\compareAsc\\compareAsc_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { toDate } from \"../toDate/index.js\";\nimport type { DateArg } from \"../types.js\";\n\n/**\n * @name compareAsc\n * @category Common Helpers\n * @summary Compare the two dates and return -1, 0 or 1.\n *\n * @description\n * Compare the two dates and return 1 if the first date is after the second,\n * -1 if the first date is before the second or 0 if dates are equal.\n *\n * @param dateLeft - The first date to compare\n * @param dateRight - The second date to compare\n *\n * @returns The result of the comparison\n *\n * @example\n * // Compare 11 February 1987 and 10 July 1989:\n * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))\n * //=> -1\n *\n * @example\n * // Sort the array of dates:\n * const result = [\n *   new Date(1995, 6, 2),\n *   new Date(1987, 1, 11),\n *   new Date(1989, 6, 10)\n * ].sort(compareAsc)\n * //=> [\n * //   Wed Feb 11 1987 00:00:00,\n * //   Mon Jul 10 1989 00:00:00,\n * //   Sun Jul 02 1995 00:00:00\n * // ]\n */\nexport function compareAsc(\n  dateLeft: DateArg<Date> & {},\n  dateRight: DateArg<Date> & {},\n): number {\n  const diff = +toDate(dateLeft) - +toDate(dateRight);\n\n  if (diff < 0) return -1;\n  else if (diff > 0) return 1;\n\n  // Return 0 if diff is 0; return NaN if diff is NaN\n  return diff;\n}\n\n### Source File Dependency Files Content\n### Dependency File: src_types.ts\nimport { type constructFromSymbol } from \"./constants/index.js\";\nimport type { Locale } from \"./locale/types.js\";\n\nexport type * from \"./fp/types.js\";\nexport type * from \"./locale/types.js\";\n\n/**\n * The argument type.\n */\nexport type DateArg<DateType extends Date> = DateType | number | string;\n\n/**\n * Date extension interface that allows to transfer extra properties from\n * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n */\nexport interface ConstructableDate extends Date {\n  [constructFromSymbol]: <DateType extends Date = Date>(\n    value: DateArg<Date> & {},\n  ) => DateType;\n}\n\n/**\n * The generic date constructor. Replicates the Date constructor. Used to build\n * generic functions.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n */\nexport interface GenericDateConstructor<DateType extends Date = Date> {\n  /**\n   * The date constructor. Creates date with the current date and time.\n   *\n   * @returns The date instance\n   */\n  new (): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date, number of\n   * milliseconds or string to parse.\n   *\n   * @param value - The date, number of milliseconds or string to parse\n   *\n   * @returns The date instance\n   */\n  new (value: DateArg<Date> & {}): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date values (year,\n   * month, etc.) Note that the month is 0-indexed.\n   *\n   * @param year - The year\n   * @param month - The month. Note that the month is 0-indexed.\n   * @param date - The day of the month\n   * @param hours - The hours\n   * @param minutes - The minutes\n   * @param seconds - The seconds\n   * @param ms - The milliseconds\n   *\n   * @returns The date instance\n   */\n  new (\n    year: number,\n    month: number,\n    date?: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): DateType;\n}\n\n/**\n * The duration object. Contains the duration in the units specified by the\n * object.\n */\nexport interface Duration {\n  /** The number of years in the duration */\n  years?: number;\n  /** The number of months in the duration */\n  months?: number;\n  /** The number of weeks in the duration */\n  weeks?: number;\n  /** The number of days in the duration */\n  days?: number;\n  /** The number of hours in the duration */\n  hours?: number;\n  /** The number of minutes in the duration */\n  minutes?: number;\n  /** The number of seconds in the duration */\n  seconds?: number;\n}\n\n/**\n * The duration unit type alias.\n */\nexport type DurationUnit = keyof Duration;\n\n/**\n * An object that combines two dates to represent the time interval.\n *\n * @typeParam StartDate - The start `Date` type.\n * @typeParam EndDate - The end `Date` type.\n */\nexport interface Interval<\n  StartType extends DateArg<Date> = DateArg<Date>,\n  EndType extends DateArg<Date> = DateArg<Date>,\n> {\n  /** The start of the interval. */\n  start: StartType;\n  /** The end of the interval. */\n  end: EndType;\n}\n\n/**\n * A version of {@link Interval} that has both start and end resolved to Date.\n */\nexport type NormalizedInterval<DateType extends Date = Date> = Interval<\n  DateType,\n  DateType\n>;\n\n/**\n * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n */\nexport type Era = 0 | 1;\n\n/**\n * The year quarter. Goes from 1 to 4.\n */\nexport type Quarter = 1 | 2 | 3 | 4;\n\n/**\n * The day of the week type alias. Unlike the date (the number of days since\n * the beginning of the month), which begins with 1 and is dynamic (can go up to\n * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at\n * it as an index in an array where Sunday is the first element and Saturday\n * is the last.\n */\nexport type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * The month type alias. Goes from 0 to 11, where 0 is January and 11 is\n * December.\n */\nexport type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n\n/**\n * FirstWeekContainsDate is used to determine which week is the first week of\n * the year, based on what day the January, 1 is in that week.\n *\n * The day in that week can only be 1 (Monday) or 4 (Thursday).\n *\n * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.\n */\nexport type FirstWeekContainsDate = 1 | 4;\n\n/**\n * The date values, used to set or get date object values.\n */\nexport interface DateValues {\n  /** The year */\n  year?: number;\n  /** The month */\n  month?: number;\n  /** The day of the month */\n  date?: number;\n  /** The hours */\n  hours?: number;\n  /** The minutes */\n  minutes?: number;\n  /** The seconds */\n  seconds?: number;\n  /** The milliseconds */\n  milliseconds?: number;\n}\n\n/**\n * The number rounding method.\n */\nexport type RoundingMethod = \"ceil\" | \"floor\" | \"round\" | \"trunc\";\n\n/**\n * The ISO string format.\n *\n * - basic: Minimal number of separators\n * - extended: With separators added to enhance human readability\n */\nexport type ISOStringFormat = \"extended\" | \"basic\";\n\n/**\n * The ISO date representation. Represents which component the string includes,\n * date, time or both.\n */\nexport type ISOStringRepresentation = \"complete\" | \"date\" | \"time\";\n\n/// Function options types\n\n/**\n * The step function options. Used to build function options.\n */\nexport interface StepOptions {\n  /** The step to use when iterating */\n  step?: number;\n}\n\n/**\n * The week function options. Used to build function options.\n */\nexport interface WeekOptions {\n  /** Which day the week starts on. */\n  weekStartsOn?: Day;\n}\n\n/**\n * The first week contains date options. Used to build function options.\n */\nexport interface FirstWeekContainsDateOptions {\n  /** See {@link FirstWeekContainsDate} for more details. */\n  firstWeekContainsDate?: FirstWeekContainsDate;\n}\n\n/**\n * The localized function options. Used to build function options.\n *\n * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.\n */\nexport interface LocalizedOptions<LocaleFields extends keyof Locale> {\n  /** The locale to use in the function. */\n  locale?: Pick<Locale, LocaleFields>;\n}\n\n/**\n * The ISO format function options. Used to build function options.\n */\nexport interface ISOFormatOptions {\n  /** The format to use: basic with minimal number of separators or extended\n   * with separators added to enhance human readability */\n  format?: ISOStringFormat;\n  /** The date representation - what component to format: date, time\\\n   * or both (complete) */\n  representation?: ISOStringRepresentation;\n}\n\n/**\n * The rounding options. Used to build function options.\n */\nexport interface RoundingOptions {\n  /** The rounding method to use */\n  roundingMethod?: RoundingMethod;\n}\n\n/**\n * Additional tokens options. Used to build function options.\n */\nexport interface AdditionalTokensOptions {\n  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalWeekYearTokens?: boolean;\n  /** If true, allows usage of the day of year tokens `D` and `DD`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalDayOfYearTokens?: boolean;\n}\n\n/**\n * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30\n * is nearest half an hour.\n */\nexport type NearestMinutes =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28\n  | 29\n  | 30;\n\n/**\n * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12\n * is nearest half a day.\n */\nexport type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\n/**\n * The nearest minutes function options. Used to build function options.\n *\n * @deprecated Use {@link NearestToUnitOptions} instead.\n */\nexport type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;\n\n/**\n * The nearest unit function options. Used to build function options.\n */\nexport interface NearestToUnitOptions<Unit extends number> {\n  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter\n   * hours. */\n  nearestTo?: Unit;\n}\n\n/**\n * The context options. Used to build function options.\n */\nexport interface ContextOptions<DateType extends Date> {\n  /**\n   * The context to use in the function. It allows to normalize the arguments\n   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\n  in?: ContextFn<DateType> | undefined;\n}\n\n/**\n  /**\n   * The context function type. It's used to normalize the input arguments to\n   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\nexport type ContextFn<DateType extends Date> = (\n  value: DateArg<Date> & {},\n) => DateType;\n\n/**\n * Resolves passed type or array of types.\n */\nexport type MaybeArray<Type> = Type | Type[];\n\n\n### Dependency File: toDate_index.ts\nimport { constructFrom } from \"../constructFrom/index.js\";\nimport type { ConstructableDate, ContextFn, DateArg } from \"../types.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate<\n  DateType extends Date | ConstructableDate,\n  ResultDate extends Date = DateType,\n>(\n  argument: DateArg<DateType>,\n  context?: ContextFn<ResultDate> | undefined,\n): ResultDate {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it } from \"vitest\";\nimport { compareAsc } from \"./index.js\";\n\ndescribe(\"compareAsc\", () => {\n  it(\"returns 0 if the given dates are equal\", () => {\n    const result = compareAsc(\n      new Date(1989, 6 /* Jul */, 10),\n      new Date(1989, 6 /* Jul */, 10),\n    );\n    expect(result).toBe(0);\n  });\n\n  it(\"returns -1 if the first date is before the second one\", () => {\n    const result = compareAsc(\n      new Date(1987, 1 /* Feb */, 11),\n      new Date(1989, 6 /* Jul */, 10),\n    );\n    expect(result).toBe(-1);\n  });\n\n  it(\"returns 1 if the first date is after the second one\", () => {\n    const result = compareAsc(\n      new Date(1989, 6 /* Jul */, 10),\n      new Date(1987, 1 /* Feb */, 11),\n    );\n    expect(result).toBe(1);\n  });\n\n  it(\"sorts the dates array in the chronological order when function is passed as the argument to Array.prototype.sort()\", () => {\n    const unsortedArray = [\n      new Date(1995, 6 /* Jul */, 2),\n      new Date(1987, 1 /* Feb */, 11),\n      new Date(1989, 6 /* Jul */, 10),\n    ];\n\n    const sortedArray = [\n      new Date(1987, 1 /* Feb */, 11),\n      new Date(1989, 6 /* Jul */, 10),\n      new Date(1995, 6 /* Jul */, 2),\n    ];\n\n    unsortedArray.sort(compareAsc);\n    const result = unsortedArray;\n\n    expect(result).toEqual(sortedArray);\n  });\n\n  it(\"accepts timestamps\", () => {\n    const result = compareAsc(\n      new Date(1987, 1 /* Feb */, 11).getTime(),\n      new Date(1989, 6 /* Jul */, 10).getTime(),\n    );\n    expect(result).toBe(-1);\n  });\n\n  it(\"returns NaN if the first date is `Invalid Date`\", () => {\n    const result = compareAsc(new Date(NaN), new Date(1989, 6 /* Jul */, 10));\n    expect(isNaN(result)).toBe(true);\n  });\n\n  it(\"returns NaN if the second date is `Invalid Date`\", () => {\n    const result = compareAsc(new Date(1989, 6 /* Jul */, 10), new Date(NaN));\n    expect(isNaN(result)).toBe(true);\n  });\n\n  it(\"returns NaN if the both dates are `Invalid Date`\", () => {\n    const result = compareAsc(new Date(NaN), new Date(NaN));\n    expect(isNaN(result)).toBe(true);\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\daysToWeeks\\daysToWeeks_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { daysInWeek } from \"../constants/index.js\";\n\n/**\n * @name daysToWeeks\n * @category Conversion Helpers\n * @summary Convert days to weeks.\n *\n * @description\n * Convert a number of days to a full number of weeks.\n *\n * @param days - The number of days to be converted\n *\n * @returns The number of days converted in weeks\n *\n * @example\n * // Convert 14 days to weeks:\n * const result = daysToWeeks(14)\n * //=> 2\n *\n * @example\n * // It uses trunc rounding:\n * const result = daysToWeeks(13)\n * //=> 1\n */\nexport function daysToWeeks(days: number): number {\n  const result = Math.trunc(days / daysInWeek);\n  // Prevent negative zero\n  return result === 0 ? 0 : result;\n}\n\n### Source File Dependency Files Content\n### Dependency File: constants_index.ts\n/**\n * @module constants\n * @summary Useful constants\n * @description\n * Collection of useful date constants.\n *\n * The constants could be imported from `date-fns/constants`:\n *\n * ```ts\n * import { maxTime, minTime } from \"date-fns/constants\";\n *\n * function isAllowedTime(time) {\n *   return time <= maxTime && time >= minTime;\n * }\n * ```\n */\n\n/**\n * @constant\n * @name daysInWeek\n * @summary Days in 1 week.\n */\nexport const daysInWeek = 7;\n\n/**\n * @constant\n * @name daysInYear\n * @summary Days in 1 year.\n *\n * @description\n * How many days in a year.\n *\n * One years equals 365.2425 days according to the formula:\n *\n * > Leap year occurs every 4 years, except for years that are divisible by 100 and not divisible by 400.\n * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days\n */\nexport const daysInYear = 365.2425;\n\n/**\n * @constant\n * @name maxTime\n * @summary Maximum allowed time.\n *\n * @example\n * import { maxTime } from \"date-fns/constants\";\n *\n * const isValid = 8640000000000001 <= maxTime;\n * //=> false\n *\n * new Date(8640000000000001);\n * //=> Invalid Date\n */\nexport const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n\n/**\n * @constant\n * @name minTime\n * @summary Minimum allowed time.\n *\n * @example\n * import { minTime } from \"date-fns/constants\";\n *\n * const isValid = -8640000000000001 >= minTime;\n * //=> false\n *\n * new Date(-8640000000000001)\n * //=> Invalid Date\n */\nexport const minTime = -maxTime;\n\n/**\n * @constant\n * @name millisecondsInWeek\n * @summary Milliseconds in 1 week.\n */\nexport const millisecondsInWeek = 604800000;\n\n/**\n * @constant\n * @name millisecondsInDay\n * @summary Milliseconds in 1 day.\n */\nexport const millisecondsInDay = 86400000;\n\n/**\n * @constant\n * @name millisecondsInMinute\n * @summary Milliseconds in 1 minute\n */\nexport const millisecondsInMinute = 60000;\n\n/**\n * @constant\n * @name millisecondsInHour\n * @summary Milliseconds in 1 hour\n */\nexport const millisecondsInHour = 3600000;\n\n/**\n * @constant\n * @name millisecondsInSecond\n * @summary Milliseconds in 1 second\n */\nexport const millisecondsInSecond = 1000;\n\n/**\n * @constant\n * @name minutesInYear\n * @summary Minutes in 1 year.\n */\nexport const minutesInYear = 525600;\n\n/**\n * @constant\n * @name minutesInMonth\n * @summary Minutes in 1 month.\n */\nexport const minutesInMonth = 43200;\n\n/**\n * @constant\n * @name minutesInDay\n * @summary Minutes in 1 day.\n */\nexport const minutesInDay = 1440;\n\n/**\n * @constant\n * @name minutesInHour\n * @summary Minutes in 1 hour.\n */\nexport const minutesInHour = 60;\n\n/**\n * @constant\n * @name monthsInQuarter\n * @summary Months in 1 quarter.\n */\nexport const monthsInQuarter = 3;\n\n/**\n * @constant\n * @name monthsInYear\n * @summary Months in 1 year.\n */\nexport const monthsInYear = 12;\n\n/**\n * @constant\n * @name quartersInYear\n * @summary Quarters in 1 year\n */\nexport const quartersInYear = 4;\n\n/**\n * @constant\n * @name secondsInHour\n * @summary Seconds in 1 hour.\n */\nexport const secondsInHour = 3600;\n\n/**\n * @constant\n * @name secondsInMinute\n * @summary Seconds in 1 minute.\n */\nexport const secondsInMinute = 60;\n\n/**\n * @constant\n * @name secondsInDay\n * @summary Seconds in 1 day.\n */\nexport const secondsInDay = secondsInHour * 24;\n\n/**\n * @constant\n * @name secondsInWeek\n * @summary Seconds in 1 week.\n */\nexport const secondsInWeek = secondsInDay * 7;\n\n/**\n * @constant\n * @name secondsInYear\n * @summary Seconds in 1 year.\n */\nexport const secondsInYear = secondsInDay * daysInYear;\n\n/**\n * @constant\n * @name secondsInMonth\n * @summary Seconds in 1 month\n */\nexport const secondsInMonth = secondsInYear / 12;\n\n/**\n * @constant\n * @name secondsInQuarter\n * @summary Seconds in 1 quarter.\n */\nexport const secondsInQuarter = secondsInMonth * 3;\n\n/**\n * @constant\n * @name constructFromSymbol\n * @summary Symbol enabling Date extensions to inherit properties from the reference date.\n *\n * The symbol is used to enable the `constructFrom` function to construct a date\n * using a reference date and a value. It allows to transfer extra properties\n * from the reference date to the new date. It's useful for extensions like\n * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as\n * a constructor argument.\n */\nexport const constructFromSymbol = Symbol.for(\"constructDateFrom\");\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it } from \"vitest\";\nimport { daysToWeeks } from \"./index.js\";\n\ndescribe(\"daysToWeeks\", () => {\n  it(\"converts days to weeks\", () => {\n    expect(daysToWeeks(7)).toBe(1);\n    expect(daysToWeeks(14)).toBe(2);\n  });\n\n  it(\"uses trunc rounding\", () => {\n    expect(daysToWeeks(8)).toBe(1);\n    expect(daysToWeeks(6)).toBe(0);\n  });\n\n  it(\"handles border values\", () => {\n    expect(daysToWeeks(7.5)).toBe(1);\n    expect(daysToWeeks(0)).toBe(0);\n  });\n\n  it(\"properly works with negative numbers\", () => {\n    expect(daysToWeeks(7)).toBe(1);\n    expect(daysToWeeks(-7)).toBe(-1);\n\n    expect(daysToWeeks(14)).toBe(2);\n    expect(daysToWeeks(-14)).toBe(-2);\n\n    expect(daysToWeeks(8)).toBe(1);\n    expect(daysToWeeks(-8)).toBe(-1);\n\n    expect(daysToWeeks(6)).toBe(0);\n    expect(daysToWeeks(-6)).toBe(0);\n\n    expect(daysToWeeks(7.5)).toBe(1);\n    expect(daysToWeeks(-7.5)).toBe(-1);\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\endOfHour\\endOfHour_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { toDate } from \"../toDate/index.js\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\n\n/**\n * The {@link endOfHour} function options.\n */\nexport interface EndOfHourOptions<DateType extends Date = Date>\n  extends ContextOptions<DateType> {}\n\n/**\n * @name endOfHour\n * @category Hour Helpers\n * @summary Return the end of an hour for the given date.\n *\n * @description\n * Return the end of an hour for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The original date\n * @param options - An object with options\n *\n * @returns The end of an hour\n *\n * @example\n * // The end of an hour for 2 September 2014 11:55:00:\n * const result = endOfHour(new Date(2014, 8, 2, 11, 55))\n * //=> Tue Sep 02 2014 11:59:59.999\n */\nexport function endOfHour<\n  DateType extends Date,\n  ResultDate extends Date = DateType,\n>(\n  date: DateArg<DateType>,\n  options?: EndOfHourOptions<ResultDate> | undefined,\n): ResultDate {\n  const _date = toDate(date, options?.in);\n  _date.setMinutes(59, 59, 999);\n  return _date;\n}\n\n### Source File Dependency Files Content\n### Dependency File: src_types.ts\nimport { type constructFromSymbol } from \"./constants/index.js\";\nimport type { Locale } from \"./locale/types.js\";\n\nexport type * from \"./fp/types.js\";\nexport type * from \"./locale/types.js\";\n\n/**\n * The argument type.\n */\nexport type DateArg<DateType extends Date> = DateType | number | string;\n\n/**\n * Date extension interface that allows to transfer extra properties from\n * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n */\nexport interface ConstructableDate extends Date {\n  [constructFromSymbol]: <DateType extends Date = Date>(\n    value: DateArg<Date> & {},\n  ) => DateType;\n}\n\n/**\n * The generic date constructor. Replicates the Date constructor. Used to build\n * generic functions.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n */\nexport interface GenericDateConstructor<DateType extends Date = Date> {\n  /**\n   * The date constructor. Creates date with the current date and time.\n   *\n   * @returns The date instance\n   */\n  new (): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date, number of\n   * milliseconds or string to parse.\n   *\n   * @param value - The date, number of milliseconds or string to parse\n   *\n   * @returns The date instance\n   */\n  new (value: DateArg<Date> & {}): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date values (year,\n   * month, etc.) Note that the month is 0-indexed.\n   *\n   * @param year - The year\n   * @param month - The month. Note that the month is 0-indexed.\n   * @param date - The day of the month\n   * @param hours - The hours\n   * @param minutes - The minutes\n   * @param seconds - The seconds\n   * @param ms - The milliseconds\n   *\n   * @returns The date instance\n   */\n  new (\n    year: number,\n    month: number,\n    date?: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): DateType;\n}\n\n/**\n * The duration object. Contains the duration in the units specified by the\n * object.\n */\nexport interface Duration {\n  /** The number of years in the duration */\n  years?: number;\n  /** The number of months in the duration */\n  months?: number;\n  /** The number of weeks in the duration */\n  weeks?: number;\n  /** The number of days in the duration */\n  days?: number;\n  /** The number of hours in the duration */\n  hours?: number;\n  /** The number of minutes in the duration */\n  minutes?: number;\n  /** The number of seconds in the duration */\n  seconds?: number;\n}\n\n/**\n * The duration unit type alias.\n */\nexport type DurationUnit = keyof Duration;\n\n/**\n * An object that combines two dates to represent the time interval.\n *\n * @typeParam StartDate - The start `Date` type.\n * @typeParam EndDate - The end `Date` type.\n */\nexport interface Interval<\n  StartType extends DateArg<Date> = DateArg<Date>,\n  EndType extends DateArg<Date> = DateArg<Date>,\n> {\n  /** The start of the interval. */\n  start: StartType;\n  /** The end of the interval. */\n  end: EndType;\n}\n\n/**\n * A version of {@link Interval} that has both start and end resolved to Date.\n */\nexport type NormalizedInterval<DateType extends Date = Date> = Interval<\n  DateType,\n  DateType\n>;\n\n/**\n * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n */\nexport type Era = 0 | 1;\n\n/**\n * The year quarter. Goes from 1 to 4.\n */\nexport type Quarter = 1 | 2 | 3 | 4;\n\n/**\n * The day of the week type alias. Unlike the date (the number of days since\n * the beginning of the month), which begins with 1 and is dynamic (can go up to\n * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at\n * it as an index in an array where Sunday is the first element and Saturday\n * is the last.\n */\nexport type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * The month type alias. Goes from 0 to 11, where 0 is January and 11 is\n * December.\n */\nexport type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n\n/**\n * FirstWeekContainsDate is used to determine which week is the first week of\n * the year, based on what day the January, 1 is in that week.\n *\n * The day in that week can only be 1 (Monday) or 4 (Thursday).\n *\n * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.\n */\nexport type FirstWeekContainsDate = 1 | 4;\n\n/**\n * The date values, used to set or get date object values.\n */\nexport interface DateValues {\n  /** The year */\n  year?: number;\n  /** The month */\n  month?: number;\n  /** The day of the month */\n  date?: number;\n  /** The hours */\n  hours?: number;\n  /** The minutes */\n  minutes?: number;\n  /** The seconds */\n  seconds?: number;\n  /** The milliseconds */\n  milliseconds?: number;\n}\n\n/**\n * The number rounding method.\n */\nexport type RoundingMethod = \"ceil\" | \"floor\" | \"round\" | \"trunc\";\n\n/**\n * The ISO string format.\n *\n * - basic: Minimal number of separators\n * - extended: With separators added to enhance human readability\n */\nexport type ISOStringFormat = \"extended\" | \"basic\";\n\n/**\n * The ISO date representation. Represents which component the string includes,\n * date, time or both.\n */\nexport type ISOStringRepresentation = \"complete\" | \"date\" | \"time\";\n\n/// Function options types\n\n/**\n * The step function options. Used to build function options.\n */\nexport interface StepOptions {\n  /** The step to use when iterating */\n  step?: number;\n}\n\n/**\n * The week function options. Used to build function options.\n */\nexport interface WeekOptions {\n  /** Which day the week starts on. */\n  weekStartsOn?: Day;\n}\n\n/**\n * The first week contains date options. Used to build function options.\n */\nexport interface FirstWeekContainsDateOptions {\n  /** See {@link FirstWeekContainsDate} for more details. */\n  firstWeekContainsDate?: FirstWeekContainsDate;\n}\n\n/**\n * The localized function options. Used to build function options.\n *\n * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.\n */\nexport interface LocalizedOptions<LocaleFields extends keyof Locale> {\n  /** The locale to use in the function. */\n  locale?: Pick<Locale, LocaleFields>;\n}\n\n/**\n * The ISO format function options. Used to build function options.\n */\nexport interface ISOFormatOptions {\n  /** The format to use: basic with minimal number of separators or extended\n   * with separators added to enhance human readability */\n  format?: ISOStringFormat;\n  /** The date representation - what component to format: date, time\\\n   * or both (complete) */\n  representation?: ISOStringRepresentation;\n}\n\n/**\n * The rounding options. Used to build function options.\n */\nexport interface RoundingOptions {\n  /** The rounding method to use */\n  roundingMethod?: RoundingMethod;\n}\n\n/**\n * Additional tokens options. Used to build function options.\n */\nexport interface AdditionalTokensOptions {\n  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalWeekYearTokens?: boolean;\n  /** If true, allows usage of the day of year tokens `D` and `DD`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalDayOfYearTokens?: boolean;\n}\n\n/**\n * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30\n * is nearest half an hour.\n */\nexport type NearestMinutes =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28\n  | 29\n  | 30;\n\n/**\n * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12\n * is nearest half a day.\n */\nexport type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\n/**\n * The nearest minutes function options. Used to build function options.\n *\n * @deprecated Use {@link NearestToUnitOptions} instead.\n */\nexport type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;\n\n/**\n * The nearest unit function options. Used to build function options.\n */\nexport interface NearestToUnitOptions<Unit extends number> {\n  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter\n   * hours. */\n  nearestTo?: Unit;\n}\n\n/**\n * The context options. Used to build function options.\n */\nexport interface ContextOptions<DateType extends Date> {\n  /**\n   * The context to use in the function. It allows to normalize the arguments\n   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\n  in?: ContextFn<DateType> | undefined;\n}\n\n/**\n  /**\n   * The context function type. It's used to normalize the input arguments to\n   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\nexport type ContextFn<DateType extends Date> = (\n  value: DateArg<Date> & {},\n) => DateType;\n\n/**\n * Resolves passed type or array of types.\n */\nexport type MaybeArray<Type> = Type | Type[];\n\n\n### Dependency File: toDate_index.ts\nimport { constructFrom } from \"../constructFrom/index.js\";\nimport type { ConstructableDate, ContextFn, DateArg } from \"../types.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate<\n  DateType extends Date | ConstructableDate,\n  ResultDate extends Date = DateType,\n>(\n  argument: DateArg<DateType>,\n  context?: ContextFn<ResultDate> | undefined,\n): ResultDate {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { TZDate, tz } from \"@date-fns/tz\";\nimport { UTCDate } from \"@date-fns/utc\";\nimport { describe, expect, it } from \"vitest\";\nimport { assertType } from \"../_lib/test/index.js\";\nimport { endOfHour } from \"./index.js\";\n\ndescribe(\"endOfHour\", () => {\n  it(\"returns the date with the time set to the last millisecond before an hour ends\", () => {\n    const date = new Date(2014, 11, 1, 22, 15);\n    const result = endOfHour(date);\n    expect(result).toEqual(new Date(2014, 11, 1, 22, 59, 59, 999));\n  });\n\n  it(\"accepts a timestamp\", () => {\n    const result = endOfHour(new Date(2014, 11, 1, 22, 15).getTime());\n    expect(result).toEqual(new Date(2014, 11, 1, 22, 59, 59, 999));\n  });\n\n  it(\"does not mutate the original date\", () => {\n    const date = new Date(2014, 11, 1, 22, 15);\n    endOfHour(date);\n    expect(date).toEqual(new Date(2014, 11, 1, 22, 15));\n  });\n\n  it(\"returns `Invalid Date` if the given date is invalid\", () => {\n    const result = endOfHour(new Date(NaN));\n    expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n  });\n\n  it(\"resolves the date type by default\", () => {\n    const result = endOfHour(Date.now());\n    expect(result).toBeInstanceOf(Date);\n    assertType<assertType.Equal<Date, typeof result>>(true);\n  });\n\n  it(\"resolves the argument type if a date extension is passed\", () => {\n    const result = endOfHour(new UTCDate());\n    expect(result).toBeInstanceOf(UTCDate);\n    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n  });\n\n  describe(\"context\", () => {\n    it(\"allows to specify the context\", () => {\n      expect(\n        endOfHour(\"2024-04-10T07:00:00Z\", {\n          in: tz(\"Asia/Singapore\"),\n        }).toISOString(),\n      ).toBe(\"2024-04-10T15:59:59.999+08:00\");\n      expect(\n        endOfHour(\"2024-04-10T07:00:00Z\", {\n          in: tz(\"America/Los_Angeles\"),\n        }).toISOString(),\n      ).toBe(\"2024-04-10T00:59:59.999-07:00\");\n    });\n\n    it(\"resolves the context date type\", () => {\n      const date = new Date(\"2024-04-10T07:00:00Z\");\n      const result = endOfHour(date, {\n        in: tz(\"Asia/Tokyo\"),\n      });\n      expect(result).toBeInstanceOf(TZDate);\n      assertType<assertType.Equal<TZDate, typeof result>>(true);\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\endOfMonth\\endOfMonth_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { toDate } from \"../toDate/index.js\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\n\n/**\n * The {@link endOfMonth} function options.\n */\nexport interface EndOfMonthOptions<DateType extends Date = Date>\n  extends ContextOptions<DateType> {}\n\n/**\n * @name endOfMonth\n * @category Month Helpers\n * @summary Return the end of a month for the given date.\n *\n * @description\n * Return the end of a month for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The original date\n * @param options - An object with options\n *\n * @returns The end of a month\n *\n * @example\n * // The end of a month for 2 September 2014 11:55:00:\n * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 30 2014 23:59:59.999\n */\nexport function endOfMonth<\n  DateType extends Date,\n  ResultDate extends Date = DateType,\n>(\n  date: DateArg<DateType>,\n  options?: EndOfMonthOptions<ResultDate> | undefined,\n): ResultDate {\n  const _date = toDate(date, options?.in);\n  const month = _date.getMonth();\n  _date.setFullYear(_date.getFullYear(), month + 1, 0);\n  _date.setHours(23, 59, 59, 999);\n  return _date;\n}\n\n### Source File Dependency Files Content\n### Dependency File: src_types.ts\nimport { type constructFromSymbol } from \"./constants/index.js\";\nimport type { Locale } from \"./locale/types.js\";\n\nexport type * from \"./fp/types.js\";\nexport type * from \"./locale/types.js\";\n\n/**\n * The argument type.\n */\nexport type DateArg<DateType extends Date> = DateType | number | string;\n\n/**\n * Date extension interface that allows to transfer extra properties from\n * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n */\nexport interface ConstructableDate extends Date {\n  [constructFromSymbol]: <DateType extends Date = Date>(\n    value: DateArg<Date> & {},\n  ) => DateType;\n}\n\n/**\n * The generic date constructor. Replicates the Date constructor. Used to build\n * generic functions.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n */\nexport interface GenericDateConstructor<DateType extends Date = Date> {\n  /**\n   * The date constructor. Creates date with the current date and time.\n   *\n   * @returns The date instance\n   */\n  new (): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date, number of\n   * milliseconds or string to parse.\n   *\n   * @param value - The date, number of milliseconds or string to parse\n   *\n   * @returns The date instance\n   */\n  new (value: DateArg<Date> & {}): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date values (year,\n   * month, etc.) Note that the month is 0-indexed.\n   *\n   * @param year - The year\n   * @param month - The month. Note that the month is 0-indexed.\n   * @param date - The day of the month\n   * @param hours - The hours\n   * @param minutes - The minutes\n   * @param seconds - The seconds\n   * @param ms - The milliseconds\n   *\n   * @returns The date instance\n   */\n  new (\n    year: number,\n    month: number,\n    date?: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): DateType;\n}\n\n/**\n * The duration object. Contains the duration in the units specified by the\n * object.\n */\nexport interface Duration {\n  /** The number of years in the duration */\n  years?: number;\n  /** The number of months in the duration */\n  months?: number;\n  /** The number of weeks in the duration */\n  weeks?: number;\n  /** The number of days in the duration */\n  days?: number;\n  /** The number of hours in the duration */\n  hours?: number;\n  /** The number of minutes in the duration */\n  minutes?: number;\n  /** The number of seconds in the duration */\n  seconds?: number;\n}\n\n/**\n * The duration unit type alias.\n */\nexport type DurationUnit = keyof Duration;\n\n/**\n * An object that combines two dates to represent the time interval.\n *\n * @typeParam StartDate - The start `Date` type.\n * @typeParam EndDate - The end `Date` type.\n */\nexport interface Interval<\n  StartType extends DateArg<Date> = DateArg<Date>,\n  EndType extends DateArg<Date> = DateArg<Date>,\n> {\n  /** The start of the interval. */\n  start: StartType;\n  /** The end of the interval. */\n  end: EndType;\n}\n\n/**\n * A version of {@link Interval} that has both start and end resolved to Date.\n */\nexport type NormalizedInterval<DateType extends Date = Date> = Interval<\n  DateType,\n  DateType\n>;\n\n/**\n * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n */\nexport type Era = 0 | 1;\n\n/**\n * The year quarter. Goes from 1 to 4.\n */\nexport type Quarter = 1 | 2 | 3 | 4;\n\n/**\n * The day of the week type alias. Unlike the date (the number of days since\n * the beginning of the month), which begins with 1 and is dynamic (can go up to\n * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at\n * it as an index in an array where Sunday is the first element and Saturday\n * is the last.\n */\nexport type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * The month type alias. Goes from 0 to 11, where 0 is January and 11 is\n * December.\n */\nexport type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n\n/**\n * FirstWeekContainsDate is used to determine which week is the first week of\n * the year, based on what day the January, 1 is in that week.\n *\n * The day in that week can only be 1 (Monday) or 4 (Thursday).\n *\n * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.\n */\nexport type FirstWeekContainsDate = 1 | 4;\n\n/**\n * The date values, used to set or get date object values.\n */\nexport interface DateValues {\n  /** The year */\n  year?: number;\n  /** The month */\n  month?: number;\n  /** The day of the month */\n  date?: number;\n  /** The hours */\n  hours?: number;\n  /** The minutes */\n  minutes?: number;\n  /** The seconds */\n  seconds?: number;\n  /** The milliseconds */\n  milliseconds?: number;\n}\n\n/**\n * The number rounding method.\n */\nexport type RoundingMethod = \"ceil\" | \"floor\" | \"round\" | \"trunc\";\n\n/**\n * The ISO string format.\n *\n * - basic: Minimal number of separators\n * - extended: With separators added to enhance human readability\n */\nexport type ISOStringFormat = \"extended\" | \"basic\";\n\n/**\n * The ISO date representation. Represents which component the string includes,\n * date, time or both.\n */\nexport type ISOStringRepresentation = \"complete\" | \"date\" | \"time\";\n\n/// Function options types\n\n/**\n * The step function options. Used to build function options.\n */\nexport interface StepOptions {\n  /** The step to use when iterating */\n  step?: number;\n}\n\n/**\n * The week function options. Used to build function options.\n */\nexport interface WeekOptions {\n  /** Which day the week starts on. */\n  weekStartsOn?: Day;\n}\n\n/**\n * The first week contains date options. Used to build function options.\n */\nexport interface FirstWeekContainsDateOptions {\n  /** See {@link FirstWeekContainsDate} for more details. */\n  firstWeekContainsDate?: FirstWeekContainsDate;\n}\n\n/**\n * The localized function options. Used to build function options.\n *\n * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.\n */\nexport interface LocalizedOptions<LocaleFields extends keyof Locale> {\n  /** The locale to use in the function. */\n  locale?: Pick<Locale, LocaleFields>;\n}\n\n/**\n * The ISO format function options. Used to build function options.\n */\nexport interface ISOFormatOptions {\n  /** The format to use: basic with minimal number of separators or extended\n   * with separators added to enhance human readability */\n  format?: ISOStringFormat;\n  /** The date representation - what component to format: date, time\\\n   * or both (complete) */\n  representation?: ISOStringRepresentation;\n}\n\n/**\n * The rounding options. Used to build function options.\n */\nexport interface RoundingOptions {\n  /** The rounding method to use */\n  roundingMethod?: RoundingMethod;\n}\n\n/**\n * Additional tokens options. Used to build function options.\n */\nexport interface AdditionalTokensOptions {\n  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalWeekYearTokens?: boolean;\n  /** If true, allows usage of the day of year tokens `D` and `DD`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalDayOfYearTokens?: boolean;\n}\n\n/**\n * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30\n * is nearest half an hour.\n */\nexport type NearestMinutes =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28\n  | 29\n  | 30;\n\n/**\n * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12\n * is nearest half a day.\n */\nexport type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\n/**\n * The nearest minutes function options. Used to build function options.\n *\n * @deprecated Use {@link NearestToUnitOptions} instead.\n */\nexport type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;\n\n/**\n * The nearest unit function options. Used to build function options.\n */\nexport interface NearestToUnitOptions<Unit extends number> {\n  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter\n   * hours. */\n  nearestTo?: Unit;\n}\n\n/**\n * The context options. Used to build function options.\n */\nexport interface ContextOptions<DateType extends Date> {\n  /**\n   * The context to use in the function. It allows to normalize the arguments\n   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\n  in?: ContextFn<DateType> | undefined;\n}\n\n/**\n  /**\n   * The context function type. It's used to normalize the input arguments to\n   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\nexport type ContextFn<DateType extends Date> = (\n  value: DateArg<Date> & {},\n) => DateType;\n\n/**\n * Resolves passed type or array of types.\n */\nexport type MaybeArray<Type> = Type | Type[];\n\n\n### Dependency File: toDate_index.ts\nimport { constructFrom } from \"../constructFrom/index.js\";\nimport type { ConstructableDate, ContextFn, DateArg } from \"../types.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate<\n  DateType extends Date | ConstructableDate,\n  ResultDate extends Date = DateType,\n>(\n  argument: DateArg<DateType>,\n  context?: ContextFn<ResultDate> | undefined,\n): ResultDate {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { TZDate, tz } from \"@date-fns/tz\";\nimport { UTCDate } from \"@date-fns/utc\";\nimport { describe, expect, it } from \"vitest\";\nimport { assertType } from \"../_lib/test/index.js\";\nimport { endOfMonth } from \"./index.js\";\n\ndescribe(\"endOfMonth\", () => {\n  it(\"returns the date with the time set to 23:59:59.999 and the date set to the last day of a month\", () => {\n    const date = new Date(2014, 8 /* Sep */, 2, 11, 55, 0);\n    const result = endOfMonth(date);\n    expect(result).toEqual(new Date(2014, 8 /* Sep */, 30, 23, 59, 59, 999));\n  });\n\n  it(\"accepts a timestamp\", () => {\n    const date = new Date(2014, 8 /* Sep */, 2, 11, 55, 0).getTime();\n    const result = endOfMonth(date);\n    expect(result).toEqual(new Date(2014, 8 /* Sep */, 30, 23, 59, 59, 999));\n  });\n\n  it(\"does not mutate the original date\", () => {\n    const date = new Date(2014, 8 /* Sep */, 2, 11, 55, 0);\n    endOfMonth(date);\n    expect(date).toEqual(new Date(2014, 8 /* Sep */, 2, 11, 55, 0));\n  });\n\n  describe(\"edge cases\", () => {\n    it(\"works for last month in year\", () => {\n      const date = new Date(2014, 11 /* Dec */, 1, 0, 0, 0);\n      const result = endOfMonth(date);\n      expect(result).toEqual(new Date(2014, 11 /* Dec */, 31, 23, 59, 59, 999));\n    });\n\n    it(\"works for last day of month\", () => {\n      const date = new Date(2014, 9 /* Oct */, 31);\n      const result = endOfMonth(date);\n      expect(result).toEqual(new Date(2014, 9 /* Oct */, 31, 23, 59, 59, 999));\n    });\n  });\n\n  it(\"returns `Invalid Date` if the given date is invalid\", () => {\n    const result = endOfMonth(new Date(NaN));\n    expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n  });\n\n  it(\"resolves the date type by default\", () => {\n    const result = endOfMonth(Date.now());\n    expect(result).toBeInstanceOf(Date);\n    assertType<assertType.Equal<Date, typeof result>>(true);\n  });\n\n  it(\"resolves the argument type if a date extension is passed\", () => {\n    const result = endOfMonth(new UTCDate());\n    expect(result).toBeInstanceOf(UTCDate);\n    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n  });\n\n  describe(\"context\", () => {\n    it(\"allows to specify the context\", () => {\n      expect(\n        endOfMonth(\"2024-04-10T07:00:00Z\", {\n          in: tz(\"Asia/Singapore\"),\n        }).toISOString(),\n      ).toBe(\"2024-04-30T23:59:59.999+08:00\");\n      expect(\n        endOfMonth(\"2024-04-10T07:00:00Z\", {\n          in: tz(\"America/Los_Angeles\"),\n        }).toISOString(),\n      ).toBe(\"2024-04-30T23:59:59.999-07:00\");\n    });\n\n    it(\"resolves the context date type\", () => {\n      const date = new Date(\"2014-09-01T00:00:00Z\");\n      const result = endOfMonth(date, {\n        in: tz(\"Asia/Tokyo\"),\n      });\n      expect(result).toBeInstanceOf(TZDate);\n      assertType<assertType.Equal<TZDate, typeof result>>(true);\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\getQuarter\\getQuarter_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { toDate } from \"../toDate/index.js\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\n\n/**\n * The {@link getQuarter} function options.\n */\nexport interface GetQuarterOptions extends ContextOptions<Date> {}\n\n/**\n * @name getQuarter\n * @category Quarter Helpers\n * @summary Get the year quarter of the given date.\n *\n * @description\n * Get the year quarter of the given date.\n *\n * @param date - The given date\n * @param options - An object with options\n *\n * @returns The quarter\n *\n * @example\n * // Which quarter is 2 July 2014?\n * const result = getQuarter(new Date(2014, 6, 2));\n * //=> 3\n */\nexport function getQuarter(\n  date: DateArg<Date> & {},\n  options?: GetQuarterOptions | undefined,\n): number {\n  const _date = toDate(date, options?.in);\n  const quarter = Math.trunc(_date.getMonth() / 3) + 1;\n  return quarter;\n}\n\n### Source File Dependency Files Content\n### Dependency File: src_types.ts\nimport { type constructFromSymbol } from \"./constants/index.js\";\nimport type { Locale } from \"./locale/types.js\";\n\nexport type * from \"./fp/types.js\";\nexport type * from \"./locale/types.js\";\n\n/**\n * The argument type.\n */\nexport type DateArg<DateType extends Date> = DateType | number | string;\n\n/**\n * Date extension interface that allows to transfer extra properties from\n * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n */\nexport interface ConstructableDate extends Date {\n  [constructFromSymbol]: <DateType extends Date = Date>(\n    value: DateArg<Date> & {},\n  ) => DateType;\n}\n\n/**\n * The generic date constructor. Replicates the Date constructor. Used to build\n * generic functions.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n */\nexport interface GenericDateConstructor<DateType extends Date = Date> {\n  /**\n   * The date constructor. Creates date with the current date and time.\n   *\n   * @returns The date instance\n   */\n  new (): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date, number of\n   * milliseconds or string to parse.\n   *\n   * @param value - The date, number of milliseconds or string to parse\n   *\n   * @returns The date instance\n   */\n  new (value: DateArg<Date> & {}): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date values (year,\n   * month, etc.) Note that the month is 0-indexed.\n   *\n   * @param year - The year\n   * @param month - The month. Note that the month is 0-indexed.\n   * @param date - The day of the month\n   * @param hours - The hours\n   * @param minutes - The minutes\n   * @param seconds - The seconds\n   * @param ms - The milliseconds\n   *\n   * @returns The date instance\n   */\n  new (\n    year: number,\n    month: number,\n    date?: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): DateType;\n}\n\n/**\n * The duration object. Contains the duration in the units specified by the\n * object.\n */\nexport interface Duration {\n  /** The number of years in the duration */\n  years?: number;\n  /** The number of months in the duration */\n  months?: number;\n  /** The number of weeks in the duration */\n  weeks?: number;\n  /** The number of days in the duration */\n  days?: number;\n  /** The number of hours in the duration */\n  hours?: number;\n  /** The number of minutes in the duration */\n  minutes?: number;\n  /** The number of seconds in the duration */\n  seconds?: number;\n}\n\n/**\n * The duration unit type alias.\n */\nexport type DurationUnit = keyof Duration;\n\n/**\n * An object that combines two dates to represent the time interval.\n *\n * @typeParam StartDate - The start `Date` type.\n * @typeParam EndDate - The end `Date` type.\n */\nexport interface Interval<\n  StartType extends DateArg<Date> = DateArg<Date>,\n  EndType extends DateArg<Date> = DateArg<Date>,\n> {\n  /** The start of the interval. */\n  start: StartType;\n  /** The end of the interval. */\n  end: EndType;\n}\n\n/**\n * A version of {@link Interval} that has both start and end resolved to Date.\n */\nexport type NormalizedInterval<DateType extends Date = Date> = Interval<\n  DateType,\n  DateType\n>;\n\n/**\n * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n */\nexport type Era = 0 | 1;\n\n/**\n * The year quarter. Goes from 1 to 4.\n */\nexport type Quarter = 1 | 2 | 3 | 4;\n\n/**\n * The day of the week type alias. Unlike the date (the number of days since\n * the beginning of the month), which begins with 1 and is dynamic (can go up to\n * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at\n * it as an index in an array where Sunday is the first element and Saturday\n * is the last.\n */\nexport type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * The month type alias. Goes from 0 to 11, where 0 is January and 11 is\n * December.\n */\nexport type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n\n/**\n * FirstWeekContainsDate is used to determine which week is the first week of\n * the year, based on what day the January, 1 is in that week.\n *\n * The day in that week can only be 1 (Monday) or 4 (Thursday).\n *\n * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.\n */\nexport type FirstWeekContainsDate = 1 | 4;\n\n/**\n * The date values, used to set or get date object values.\n */\nexport interface DateValues {\n  /** The year */\n  year?: number;\n  /** The month */\n  month?: number;\n  /** The day of the month */\n  date?: number;\n  /** The hours */\n  hours?: number;\n  /** The minutes */\n  minutes?: number;\n  /** The seconds */\n  seconds?: number;\n  /** The milliseconds */\n  milliseconds?: number;\n}\n\n/**\n * The number rounding method.\n */\nexport type RoundingMethod = \"ceil\" | \"floor\" | \"round\" | \"trunc\";\n\n/**\n * The ISO string format.\n *\n * - basic: Minimal number of separators\n * - extended: With separators added to enhance human readability\n */\nexport type ISOStringFormat = \"extended\" | \"basic\";\n\n/**\n * The ISO date representation. Represents which component the string includes,\n * date, time or both.\n */\nexport type ISOStringRepresentation = \"complete\" | \"date\" | \"time\";\n\n/// Function options types\n\n/**\n * The step function options. Used to build function options.\n */\nexport interface StepOptions {\n  /** The step to use when iterating */\n  step?: number;\n}\n\n/**\n * The week function options. Used to build function options.\n */\nexport interface WeekOptions {\n  /** Which day the week starts on. */\n  weekStartsOn?: Day;\n}\n\n/**\n * The first week contains date options. Used to build function options.\n */\nexport interface FirstWeekContainsDateOptions {\n  /** See {@link FirstWeekContainsDate} for more details. */\n  firstWeekContainsDate?: FirstWeekContainsDate;\n}\n\n/**\n * The localized function options. Used to build function options.\n *\n * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.\n */\nexport interface LocalizedOptions<LocaleFields extends keyof Locale> {\n  /** The locale to use in the function. */\n  locale?: Pick<Locale, LocaleFields>;\n}\n\n/**\n * The ISO format function options. Used to build function options.\n */\nexport interface ISOFormatOptions {\n  /** The format to use: basic with minimal number of separators or extended\n   * with separators added to enhance human readability */\n  format?: ISOStringFormat;\n  /** The date representation - what component to format: date, time\\\n   * or both (complete) */\n  representation?: ISOStringRepresentation;\n}\n\n/**\n * The rounding options. Used to build function options.\n */\nexport interface RoundingOptions {\n  /** The rounding method to use */\n  roundingMethod?: RoundingMethod;\n}\n\n/**\n * Additional tokens options. Used to build function options.\n */\nexport interface AdditionalTokensOptions {\n  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalWeekYearTokens?: boolean;\n  /** If true, allows usage of the day of year tokens `D` and `DD`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalDayOfYearTokens?: boolean;\n}\n\n/**\n * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30\n * is nearest half an hour.\n */\nexport type NearestMinutes =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28\n  | 29\n  | 30;\n\n/**\n * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12\n * is nearest half a day.\n */\nexport type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\n/**\n * The nearest minutes function options. Used to build function options.\n *\n * @deprecated Use {@link NearestToUnitOptions} instead.\n */\nexport type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;\n\n/**\n * The nearest unit function options. Used to build function options.\n */\nexport interface NearestToUnitOptions<Unit extends number> {\n  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter\n   * hours. */\n  nearestTo?: Unit;\n}\n\n/**\n * The context options. Used to build function options.\n */\nexport interface ContextOptions<DateType extends Date> {\n  /**\n   * The context to use in the function. It allows to normalize the arguments\n   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\n  in?: ContextFn<DateType> | undefined;\n}\n\n/**\n  /**\n   * The context function type. It's used to normalize the input arguments to\n   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\nexport type ContextFn<DateType extends Date> = (\n  value: DateArg<Date> & {},\n) => DateType;\n\n/**\n * Resolves passed type or array of types.\n */\nexport type MaybeArray<Type> = Type | Type[];\n\n\n### Dependency File: toDate_index.ts\nimport { constructFrom } from \"../constructFrom/index.js\";\nimport type { ConstructableDate, ContextFn, DateArg } from \"../types.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate<\n  DateType extends Date | ConstructableDate,\n  ResultDate extends Date = DateType,\n>(\n  argument: DateArg<DateType>,\n  context?: ContextFn<ResultDate> | undefined,\n): ResultDate {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { tz } from \"@date-fns/tz\";\nimport { describe, expect, it } from \"vitest\";\nimport type { ContextOptions, DateArg } from \"../types.js\";\nimport { getQuarter } from \"./index.js\";\n\ndescribe(\"getQuarter\", () => {\n  it(\"returns the quarter of the given date\", () => {\n    const result = getQuarter(new Date(2014, 6 /* Jul */, 2));\n    expect(result).toBe(3);\n  });\n\n  it(\"accepts a timestamp\", () => {\n    const result = getQuarter(new Date(2014, 3 /* Apr */, 2).getTime());\n    expect(result).toBe(2);\n  });\n\n  it(\"returns NaN if the given date is invalid\", () => {\n    const result = getQuarter(new Date(NaN));\n    expect(isNaN(result)).toBe(true);\n  });\n\n  describe(\"context\", () => {\n    it(\"allows to specify the context\", () => {\n      expect(\n        getQuarter(\"2024-03-31T16:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n      ).toBe(2);\n      expect(\n        getQuarter(\"2024-03-31T15:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n      ).toBe(1);\n      expect(\n        getQuarter(\"2024-04-01T04:00:00Z\", { in: tz(\"America/New_York\") }),\n      ).toBe(2);\n      expect(\n        getQuarter(\"2024-04-01T03:00:00Z\", { in: tz(\"America/New_York\") }),\n      ).toBe(1);\n    });\n\n    it(\"doesn't enforce argument and context to be of the same type\", () => {\n      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n        arg: DateArg<DateType>,\n        options?: ContextOptions<ResultDate>,\n      ) {\n        getQuarter(arg, { in: options?.in });\n      }\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: date-fns\nTest File Path: date-fns\\isPast\\isPast_test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport { toDate } from \"../toDate/index.js\";\nimport type { DateArg } from \"../types.js\";\n\n/**\n * @name isPast\n * @category Common Helpers\n * @summary Is the given date in the past?\n * @pure false\n *\n * @description\n * Is the given date in the past?\n *\n * @param date - The date to check\n *\n * @returns The date is in the past\n *\n * @example\n * // If today is 6 October 2014, is 2 July 2014 in the past?\n * const result = isPast(new Date(2014, 6, 2))\n * //=> true\n */\nexport function isPast(date: DateArg<Date> & {}): boolean {\n  return +toDate(date) < Date.now();\n}\n\n### Source File Dependency Files Content\n### Dependency File: src_types.ts\nimport { type constructFromSymbol } from \"./constants/index.js\";\nimport type { Locale } from \"./locale/types.js\";\n\nexport type * from \"./fp/types.js\";\nexport type * from \"./locale/types.js\";\n\n/**\n * The argument type.\n */\nexport type DateArg<DateType extends Date> = DateType | number | string;\n\n/**\n * Date extension interface that allows to transfer extra properties from\n * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n */\nexport interface ConstructableDate extends Date {\n  [constructFromSymbol]: <DateType extends Date = Date>(\n    value: DateArg<Date> & {},\n  ) => DateType;\n}\n\n/**\n * The generic date constructor. Replicates the Date constructor. Used to build\n * generic functions.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n */\nexport interface GenericDateConstructor<DateType extends Date = Date> {\n  /**\n   * The date constructor. Creates date with the current date and time.\n   *\n   * @returns The date instance\n   */\n  new (): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date, number of\n   * milliseconds or string to parse.\n   *\n   * @param value - The date, number of milliseconds or string to parse\n   *\n   * @returns The date instance\n   */\n  new (value: DateArg<Date> & {}): DateType;\n\n  /**\n   * The date constructor. Creates date with the passed date values (year,\n   * month, etc.) Note that the month is 0-indexed.\n   *\n   * @param year - The year\n   * @param month - The month. Note that the month is 0-indexed.\n   * @param date - The day of the month\n   * @param hours - The hours\n   * @param minutes - The minutes\n   * @param seconds - The seconds\n   * @param ms - The milliseconds\n   *\n   * @returns The date instance\n   */\n  new (\n    year: number,\n    month: number,\n    date?: number,\n    hours?: number,\n    minutes?: number,\n    seconds?: number,\n    ms?: number,\n  ): DateType;\n}\n\n/**\n * The duration object. Contains the duration in the units specified by the\n * object.\n */\nexport interface Duration {\n  /** The number of years in the duration */\n  years?: number;\n  /** The number of months in the duration */\n  months?: number;\n  /** The number of weeks in the duration */\n  weeks?: number;\n  /** The number of days in the duration */\n  days?: number;\n  /** The number of hours in the duration */\n  hours?: number;\n  /** The number of minutes in the duration */\n  minutes?: number;\n  /** The number of seconds in the duration */\n  seconds?: number;\n}\n\n/**\n * The duration unit type alias.\n */\nexport type DurationUnit = keyof Duration;\n\n/**\n * An object that combines two dates to represent the time interval.\n *\n * @typeParam StartDate - The start `Date` type.\n * @typeParam EndDate - The end `Date` type.\n */\nexport interface Interval<\n  StartType extends DateArg<Date> = DateArg<Date>,\n  EndType extends DateArg<Date> = DateArg<Date>,\n> {\n  /** The start of the interval. */\n  start: StartType;\n  /** The end of the interval. */\n  end: EndType;\n}\n\n/**\n * A version of {@link Interval} that has both start and end resolved to Date.\n */\nexport type NormalizedInterval<DateType extends Date = Date> = Interval<\n  DateType,\n  DateType\n>;\n\n/**\n * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n */\nexport type Era = 0 | 1;\n\n/**\n * The year quarter. Goes from 1 to 4.\n */\nexport type Quarter = 1 | 2 | 3 | 4;\n\n/**\n * The day of the week type alias. Unlike the date (the number of days since\n * the beginning of the month), which begins with 1 and is dynamic (can go up to\n * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at\n * it as an index in an array where Sunday is the first element and Saturday\n * is the last.\n */\nexport type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * The month type alias. Goes from 0 to 11, where 0 is January and 11 is\n * December.\n */\nexport type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n\n/**\n * FirstWeekContainsDate is used to determine which week is the first week of\n * the year, based on what day the January, 1 is in that week.\n *\n * The day in that week can only be 1 (Monday) or 4 (Thursday).\n *\n * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.\n */\nexport type FirstWeekContainsDate = 1 | 4;\n\n/**\n * The date values, used to set or get date object values.\n */\nexport interface DateValues {\n  /** The year */\n  year?: number;\n  /** The month */\n  month?: number;\n  /** The day of the month */\n  date?: number;\n  /** The hours */\n  hours?: number;\n  /** The minutes */\n  minutes?: number;\n  /** The seconds */\n  seconds?: number;\n  /** The milliseconds */\n  milliseconds?: number;\n}\n\n/**\n * The number rounding method.\n */\nexport type RoundingMethod = \"ceil\" | \"floor\" | \"round\" | \"trunc\";\n\n/**\n * The ISO string format.\n *\n * - basic: Minimal number of separators\n * - extended: With separators added to enhance human readability\n */\nexport type ISOStringFormat = \"extended\" | \"basic\";\n\n/**\n * The ISO date representation. Represents which component the string includes,\n * date, time or both.\n */\nexport type ISOStringRepresentation = \"complete\" | \"date\" | \"time\";\n\n/// Function options types\n\n/**\n * The step function options. Used to build function options.\n */\nexport interface StepOptions {\n  /** The step to use when iterating */\n  step?: number;\n}\n\n/**\n * The week function options. Used to build function options.\n */\nexport interface WeekOptions {\n  /** Which day the week starts on. */\n  weekStartsOn?: Day;\n}\n\n/**\n * The first week contains date options. Used to build function options.\n */\nexport interface FirstWeekContainsDateOptions {\n  /** See {@link FirstWeekContainsDate} for more details. */\n  firstWeekContainsDate?: FirstWeekContainsDate;\n}\n\n/**\n * The localized function options. Used to build function options.\n *\n * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.\n */\nexport interface LocalizedOptions<LocaleFields extends keyof Locale> {\n  /** The locale to use in the function. */\n  locale?: Pick<Locale, LocaleFields>;\n}\n\n/**\n * The ISO format function options. Used to build function options.\n */\nexport interface ISOFormatOptions {\n  /** The format to use: basic with minimal number of separators or extended\n   * with separators added to enhance human readability */\n  format?: ISOStringFormat;\n  /** The date representation - what component to format: date, time\\\n   * or both (complete) */\n  representation?: ISOStringRepresentation;\n}\n\n/**\n * The rounding options. Used to build function options.\n */\nexport interface RoundingOptions {\n  /** The rounding method to use */\n  roundingMethod?: RoundingMethod;\n}\n\n/**\n * Additional tokens options. Used to build function options.\n */\nexport interface AdditionalTokensOptions {\n  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalWeekYearTokens?: boolean;\n  /** If true, allows usage of the day of year tokens `D` and `DD`.\n   * See: https://date-fns.org/docs/Unicode-Tokens */\n  useAdditionalDayOfYearTokens?: boolean;\n}\n\n/**\n * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30\n * is nearest half an hour.\n */\nexport type NearestMinutes =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28\n  | 29\n  | 30;\n\n/**\n * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12\n * is nearest half a day.\n */\nexport type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\n/**\n * The nearest minutes function options. Used to build function options.\n *\n * @deprecated Use {@link NearestToUnitOptions} instead.\n */\nexport type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;\n\n/**\n * The nearest unit function options. Used to build function options.\n */\nexport interface NearestToUnitOptions<Unit extends number> {\n  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter\n   * hours. */\n  nearestTo?: Unit;\n}\n\n/**\n * The context options. Used to build function options.\n */\nexport interface ContextOptions<DateType extends Date> {\n  /**\n   * The context to use in the function. It allows to normalize the arguments\n   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\n  in?: ContextFn<DateType> | undefined;\n}\n\n/**\n  /**\n   * The context function type. It's used to normalize the input arguments to\n   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n   */\nexport type ContextFn<DateType extends Date> = (\n  value: DateArg<Date> & {},\n) => DateType;\n\n/**\n * Resolves passed type or array of types.\n */\nexport type MaybeArray<Type> = Type | Type[];\n\n\n### Dependency File: toDate_index.ts\nimport { constructFrom } from \"../constructFrom/index.js\";\nimport type { ConstructableDate, ContextFn, DateArg } from \"../types.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate<\n  DateType extends Date | ConstructableDate,\n  ResultDate extends Date = DateType,\n>(\n  argument: DateArg<DateType>,\n  context?: ContextFn<ResultDate> | undefined,\n): ResultDate {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:00:27"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it } from \"vitest\";\nimport { fakeDate } from \"../_lib/test/index.js\";\nimport { isPast } from \"./index.js\";\n\ndescribe(\"isPast\", () => {\n  fakeDate(new Date(2014, 8 /* Sep */, 25));\n\n  it(\"returns true if the given date is in the past\", () => {\n    const result = isPast(new Date(2014, 6 /* Jul */, 2));\n    expect(result).toBe(true);\n  });\n\n  it(\"returns false if the given date is in the future\", () => {\n    const result = isPast(new Date(2014, 11 /* Dec */, 31));\n    expect(result).toBe(false);\n  });\n\n  it(\"returns false if the given date is now\", () => {\n    const result = isPast(new Date(2014, 8 /* Sep */, 25));\n    expect(result).toBe(false);\n  });\n\n  it(\"accepts a timestamp\", () => {\n    const result = isPast(new Date(2014, 6 /* Jul */, 2).getTime());\n    expect(result).toBe(true);\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\Codec.ts\\Codec.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.3\n */\nimport { identity, Refinement } from 'fp-ts/lib/function'\nimport { Invariant3 } from 'fp-ts/lib/Invariant'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as D from './Decoder'\nimport * as E from './Encoder'\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * Laws:\n *\n * 1. `pipe(codec.decode(u), E.fold(() => u, codec.encode)) = u` for all `u` in `unknown`\n * 2. `codec.decode(codec.encode(a)) = E.right(a)` for all `a` in `A`\n *\n * @category model\n * @since 2.2.3\n */\nexport interface Codec<I, O, A> extends D.Decoder<I, A>, E.Encoder<O, A> {}\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.3\n */\nexport function make<I, O, A>(decoder: D.Decoder<I, A>, encoder: E.Encoder<O, A>): Codec<I, O, A> {\n  return {\n    decode: decoder.decode,\n    encode: encoder.encode\n  }\n}\n\n/**\n * @category constructors\n * @since 2.2.3\n */\nexport function fromDecoder<I, A>(decoder: D.Decoder<I, A>): Codec<I, A, A> {\n  return {\n    decode: decoder.decode,\n    encode: identity\n  }\n}\n\n/**\n * @category constructors\n * @since 2.2.3\n */\nexport function literal<A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n): Codec<unknown, A[number], A[number]> {\n  return fromDecoder(D.literal(...values))\n}\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\n/**\n * @category primitives\n * @since 2.2.3\n */\nexport const string: Codec<unknown, string, string> =\n  /*#__PURE__*/\n  fromDecoder(D.string)\n\n/**\n * @category primitives\n * @since 2.2.3\n */\nexport const number: Codec<unknown, number, number> =\n  /*#__PURE__*/\n  fromDecoder(D.number)\n\n/**\n * @category primitives\n * @since 2.2.3\n */\nexport const boolean: Codec<unknown, boolean, boolean> =\n  /*#__PURE__*/\n  fromDecoder(D.boolean)\n\n/**\n * @category primitives\n * @since 2.2.3\n */\nexport const UnknownArray: Codec<unknown, Array<unknown>, Array<unknown>> =\n  /*#__PURE__*/\n  fromDecoder(D.UnknownArray)\n\n/**\n * @category primitives\n * @since 2.2.3\n */\nexport const UnknownRecord: Codec<unknown, Record<string, unknown>, Record<string, unknown>> =\n  /*#__PURE__*/\n  fromDecoder(D.UnknownRecord)\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport const mapLeftWithInput =\n  <I>(f: (i: I, e: D.DecodeError) => D.DecodeError) =>\n  <O, A>(codec: Codec<I, O, A>): Codec<I, O, A> =>\n    make(pipe(codec, D.mapLeftWithInput(f)), codec)\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport const refine = <A, B extends A>(\n  refinement: Refinement<A, B>,\n  id: string\n): (<I, O>(from: Codec<I, O, A>) => Codec<I, O, B>) => {\n  const refine = D.refine(refinement, id)\n  return (from) => make(refine(from), from)\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function nullable<I, O, A>(or: Codec<I, O, A>): Codec<null | I, null | O, null | A> {\n  return make(D.nullable(or), E.nullable(or))\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function fromStruct<P extends Record<string, Codec<any, any, any>>>(\n  properties: P\n): Codec<{ [K in keyof P]: InputOf<P[K]> }, { [K in keyof P]: OutputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> {\n  return make(D.fromStruct(properties) as any, E.struct(properties))\n}\n\n/**\n * Use `fromStruct` instead.\n *\n * @category combinators\n * @since 2.2.8\n * @deprecated\n */\nexport const fromType = fromStruct\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function struct<P extends Record<string, Codec<unknown, any, any>>>(\n  properties: P\n): Codec<unknown, { [K in keyof P]: OutputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> {\n  return pipe(UnknownRecord, compose(fromStruct(properties as any))) as any\n}\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.3\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport function fromPartial<P extends Record<string, Codec<any, any, any>>>(\n  properties: P\n): Codec<\n  Partial<{ [K in keyof P]: InputOf<P[K]> }>,\n  Partial<{ [K in keyof P]: OutputOf<P[K]> }>,\n  Partial<{ [K in keyof P]: TypeOf<P[K]> }>\n> {\n  return make(D.fromPartial(properties), E.partial(properties))\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function partial<P extends Record<string, Codec<unknown, any, any>>>(\n  properties: P\n): Codec<unknown, Partial<{ [K in keyof P]: OutputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> {\n  return pipe(UnknownRecord, compose(fromPartial(properties as any))) as any\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function fromArray<I, O, A>(item: Codec<I, O, A>): Codec<Array<I>, Array<O>, Array<A>> {\n  return make(D.fromArray(item), E.array(item))\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function array<O, A>(item: Codec<unknown, O, A>): Codec<unknown, Array<O>, Array<A>> {\n  return pipe(UnknownArray, compose(fromArray(item))) as any\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function fromRecord<I, O, A>(\n  codomain: Codec<I, O, A>\n): Codec<Record<string, I>, Record<string, O>, Record<string, A>> {\n  return make(D.fromRecord(codomain), E.record(codomain))\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function record<O, A>(codomain: Codec<unknown, O, A>): Codec<unknown, Record<string, O>, Record<string, A>> {\n  return pipe(UnknownRecord, compose(fromRecord(codomain))) as any\n}\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromTuple = <C extends ReadonlyArray<Codec<any, any, any>>>(\n  ...components: C\n): Codec<{ [K in keyof C]: InputOf<C[K]> }, { [K in keyof C]: OutputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> =>\n  make(D.fromTuple(...components) as any, E.tuple(...components)) as any\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function tuple<C extends ReadonlyArray<Codec<unknown, any, any>>>(\n  ...components: C\n): Codec<unknown, { [K in keyof C]: OutputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> {\n  return pipe(UnknownArray as any, compose(fromTuple(...components) as any)) as any\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport const intersect = <IB, OB, B>(\n  right: Codec<IB, OB, B>\n): (<IA, OA, A>(left: Codec<IA, OA, A>) => Codec<IA & IB, OA & OB, A & B>) => {\n  const intersectD = D.intersect(right)\n  const intersectE = E.intersect(right)\n  return (left) => make(intersectD(left), intersectE(left))\n}\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromSum = <T extends string>(\n  tag: T\n): (<MS extends Record<string, Codec<any, any, any>>>(\n  members: MS\n) => Codec<InputOf<MS[keyof MS]>, OutputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>>) => {\n  const decoder = D.fromSum(tag)\n  const encoder = E.sum(tag)\n  return (members) => make(decoder(members) as any, encoder(members))\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function sum<T extends string>(\n  tag: T\n): <M extends Record<string, Codec<unknown, any, any>>>(\n  members: M\n) => Codec<unknown, OutputOf<M[keyof M]>, TypeOf<M[keyof M]>> {\n  const sum = fromSum(tag)\n  return (members) => pipe(UnknownRecord, compose(sum(members) as any)) as any\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function lazy<I, O, A>(id: string, f: () => Codec<I, O, A>): Codec<I, O, A> {\n  return make(D.lazy(id, f), E.lazy(f))\n}\n\n/**\n * @category combinators\n * @since 2.2.16\n */\nexport const readonly: <I, O, A>(codec: Codec<I, O, A>) => Codec<I, O, Readonly<A>> = identity\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const compose =\n  <L, A extends L, P extends A, B>(to: Codec<L, P, B>) =>\n  <I, O>(from: Codec<I, O, A>): Codec<I, O, B> =>\n    make(D.compose(to)(from), E.compose(from)(to))\n\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n\nconst imap_: Invariant3<URI>['imap'] = (fa, f, g) => make(D.Functor.map(fa, f), E.Contravariant.contramap(fa, g))\n\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n\n/**\n * @category Invariant\n * @since 2.2.3\n */\nexport const imap: <I, O, A, B>(f: (a: A) => B, g: (b: B) => A) => (fa: Codec<I, O, A>) => Codec<I, O, B> =\n  (f, g) => (fa) =>\n    imap_(fa, f, g)\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.3\n */\nexport const URI = 'io-ts/Codec'\n\n/**\n * @category instances\n * @since 2.2.3\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind3<R, E, A> {\n    readonly [URI]: Codec<R, E, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Invariant: Invariant3<URI> = {\n  URI,\n  imap: imap_\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.8\n */\nexport type InputOf<C> = D.InputOf<C>\n\n/**\n * @since 2.2.3\n */\nexport type OutputOf<C> = E.OutputOf<C>\n\n/**\n * @since 2.2.3\n */\nexport type TypeOf<C> = E.TypeOf<C>\n\n### Source File Dependency Files Content\n### Dependency File: Decoder.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Alt2, Alt2C } from 'fp-ts/lib/Alt'\nimport { Bifunctor2 } from 'fp-ts/lib/Bifunctor'\nimport { Category2 } from 'fp-ts/lib/Category'\nimport * as E from 'fp-ts/lib/Either'\nimport { identity, Refinement } from 'fp-ts/lib/function'\nimport { Functor2 } from 'fp-ts/lib/Functor'\nimport { MonadThrow2C } from 'fp-ts/lib/MonadThrow'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as DE from './DecodeError'\nimport * as FS from './FreeSemigroup'\nimport * as G from './Guard'\nimport * as K from './Kleisli'\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// Kleisli config\n// -------------------------------------------------------------------------------------\n\n/**\n * @internal\n */\nexport const SE =\n  /*#__PURE__*/\n  DE.getSemigroup<string>()\n\n/**\n * @internal\n */\nexport const ap = <A, B>(\n  fab: E.Either<DecodeError, (a: A) => B>,\n  fa: E.Either<DecodeError, A>\n): E.Either<DecodeError, B> =>\n  E.isLeft(fab)\n    ? E.isLeft(fa)\n      ? E.left(SE.concat(fab.left, fa.left))\n      : fab\n    : E.isLeft(fa)\n    ? fa\n    : E.right(fab.right(fa.right))\n\nconst M: MonadThrow2C<E.URI, DecodeError> & Bifunctor2<E.URI> & Alt2C<E.URI, DecodeError> = {\n  URI: E.URI,\n  _E: undefined as any,\n  map: (fa, f) => pipe(fa, E.map(f)),\n  ap,\n  of: E.right,\n  chain: (ma, f) => pipe(ma, E.chain(f)),\n  throwError: E.left,\n  bimap: (fa, f, g) => pipe(fa, E.bimap(f, g)),\n  mapLeft: (fa, f) => pipe(fa, E.mapLeft(f)),\n  alt: (me, that) => {\n    if (E.isRight(me)) {\n      return me\n    }\n    const ea = that()\n    return E.isLeft(ea) ? E.left(SE.concat(me.left, ea.left)) : ea\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.8\n */\nexport interface Decoder<I, A> extends K.Kleisli<E.URI, I, DecodeError, A> {}\n\n// -------------------------------------------------------------------------------------\n// DecodeError\n// -------------------------------------------------------------------------------------\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport type DecodeError = FS.FreeSemigroup<DE.DecodeError<string>>\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const error = (actual: unknown, message: string): DecodeError => FS.of(DE.leaf(actual, message))\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const success: <A>(a: A) => E.Either<DecodeError, A> = E.right\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const failure = <A = never>(actual: unknown, message: string): E.Either<DecodeError, A> =>\n  E.left(error(actual, message))\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.8\n */\nexport const fromRefinement = <I, A extends I>(refinement: Refinement<I, A>, expected: string): Decoder<I, A> =>\n  K.fromRefinement(M)(refinement, (u) => error(u, expected))\n\n/**\n * @category constructors\n * @since 2.2.8\n */\nexport const fromGuard = <I, A extends I>(guard: G.Guard<I, A>, expected: string): Decoder<I, A> =>\n  fromRefinement(guard.is, expected)\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n) => Decoder<unknown, A[number]> =\n  /*#__PURE__*/\n  K.literal(M)((u, values) => error(u, values.map((value) => JSON.stringify(value)).join(' | ')))\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const string: Decoder<unknown, string> =\n  /*#__PURE__*/\n  fromGuard(G.string, 'string')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const number: Decoder<unknown, number> =\n  /*#__PURE__*/\n  fromGuard(G.number, 'number')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const boolean: Decoder<unknown, boolean> =\n  /*#__PURE__*/\n  fromGuard(G.boolean, 'boolean')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const UnknownArray: Decoder<unknown, Array<unknown>> =\n  /*#__PURE__*/\n  fromGuard(G.UnknownArray, 'Array<unknown>')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const UnknownRecord: Decoder<unknown, Record<string, unknown>> =\n  /*#__PURE__*/\n  fromGuard(G.UnknownRecord, 'Record<string, unknown>')\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const mapLeftWithInput: <I>(\n  f: (input: I, e: DecodeError) => DecodeError\n) => <A>(decoder: Decoder<I, A>) => Decoder<I, A> =\n  /*#__PURE__*/\n  K.mapLeftWithInput(M)\n\n/**\n * @category combinators\n * @since 2.2.9\n */\nexport const withMessage = <I>(\n  message: (input: I, e: DecodeError) => string\n): (<A>(decoder: Decoder<I, A>) => Decoder<I, A>) =>\n  mapLeftWithInput((input, e) => FS.of(DE.wrap(message(input, e), e)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const refine = <A, B extends A>(\n  refinement: Refinement<A, B>,\n  id: string\n): (<I>(from: Decoder<I, A>) => Decoder<I, B>) => K.refine(M)(refinement, (a) => error(a, id))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const parse: <A, B>(parser: (a: A) => E.Either<DecodeError, B>) => <I>(from: Decoder<I, A>) => Decoder<I, B> =\n  /*#__PURE__*/\n  K.parse(M)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const nullable: <I, A>(or: Decoder<I, A>) => Decoder<null | I, null | A> =\n  /*#__PURE__*/\n  K.nullable(M)((u, e) => FS.concat(FS.of(DE.member(0, error(u, 'null'))), FS.of(DE.member(1, e))))\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const fromStruct = <P extends Record<string, Decoder<any, any>>>(\n  properties: P\n): Decoder<{ [K in keyof P]: InputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> =>\n  K.fromStruct(M)((k, e) => FS.of(DE.key(k, DE.required, e)))(properties)\n\n/**\n * Use `fromStruct` instead.\n *\n * @category combinators\n * @since 2.2.8\n * @deprecated\n */\nexport const fromType = fromStruct\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const struct = <A>(properties: { [K in keyof A]: Decoder<unknown, A[K]> }): Decoder<\n  unknown,\n  { [K in keyof A]: A[K] }\n> => pipe(UnknownRecord as any, compose(fromStruct(properties)))\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.7\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromPartial = <P extends Record<string, Decoder<any, any>>>(\n  properties: P\n): Decoder<Partial<{ [K in keyof P]: InputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> =>\n  K.fromPartial(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(properties)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const partial = <A>(properties: { [K in keyof A]: Decoder<unknown, A[K]> }): Decoder<\n  unknown,\n  Partial<{ [K in keyof A]: A[K] }>\n> => pipe(UnknownRecord as any, compose(fromPartial(properties)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromArray = <I, A>(item: Decoder<I, A>): Decoder<Array<I>, Array<A>> =>\n  K.fromArray(M)((i, e) => FS.of(DE.index(i, DE.optional, e)))(item)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const array = <A>(item: Decoder<unknown, A>): Decoder<unknown, Array<A>> =>\n  pipe(UnknownArray, compose(fromArray(item)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromRecord = <I, A>(codomain: Decoder<I, A>): Decoder<Record<string, I>, Record<string, A>> =>\n  K.fromRecord(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(codomain)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const record = <A>(codomain: Decoder<unknown, A>): Decoder<unknown, Record<string, A>> =>\n  pipe(UnknownRecord, compose(fromRecord(codomain)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromTuple = <C extends ReadonlyArray<Decoder<any, any>>>(\n  ...components: C\n): Decoder<{ [K in keyof C]: InputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> =>\n  K.fromTuple(M)((i, e) => FS.of(DE.index(i, DE.required, e)))(...components) as any\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Decoder<unknown, A[K]> }\n): Decoder<unknown, A> => pipe(UnknownArray as any, compose(fromTuple(...components))) as any\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const union: <MS extends readonly [Decoder<any, any>, ...Array<Decoder<any, any>>]>(\n  ...members: MS\n) => Decoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =\n  /*#__PURE__*/\n  K.union(M)((i, e) => FS.of(DE.member(i, e)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const intersect: <IB, B>(right: Decoder<IB, B>) => <IA, A>(left: Decoder<IA, A>) => Decoder<IA & IB, A & B> =\n  /*#__PURE__*/\n  K.intersect(M)\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromSum =\n  <T extends string>(tag: T) =>\n  <MS extends Record<string, Decoder<any, any>>>(members: MS): Decoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =>\n    K.fromSum(M)((tag, value, keys) =>\n      FS.of(\n        DE.key(\n          tag,\n          DE.required,\n          error(value, keys.length === 0 ? 'never' : keys.map((k) => JSON.stringify(k)).join(' | '))\n        )\n      )\n    )(tag)(members)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const sum =\n  <T extends string>(tag: T) =>\n  <A>(members: { [K in keyof A]: Decoder<unknown, A[K] & Record<T, K>> }): Decoder<unknown, A[keyof A]> =>\n    pipe(UnknownRecord as any, compose(fromSum(tag)(members)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const lazy: <I, A>(id: string, f: () => Decoder<I, A>) => Decoder<I, A> =\n  /*#__PURE__*/\n  K.lazy(M)((id, e) => FS.of(DE.lazy(id, e)))\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const readonly: <I, A>(decoder: Decoder<I, A>) => Decoder<I, Readonly<A>> = identity\n\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n\nconst map_: Functor2<URI>['map'] = (fa, f) => pipe(fa, map(f))\n\nconst alt_: Alt2<URI>['alt'] = (me, that) => pipe(me, alt(that))\n\nconst compose_: Category2<URI>['compose'] = (ab, la) => pipe(la, compose(ab))\n\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n\n/**\n * @category Functor\n * @since 2.2.7\n */\nexport const map: <A, B>(f: (a: A) => B) => <I>(fa: Decoder<I, A>) => Decoder<I, B> =\n  /*#__PURE__*/\n  K.map(M)\n\n/**\n * @category Alt\n * @since 2.2.7\n */\nexport const alt: <I, A>(that: () => Decoder<I, A>) => (me: Decoder<I, A>) => Decoder<I, A> =\n  /*#__PURE__*/\n  K.alt(M)\n\n/**\n * @category Semigroupoid\n * @since 2.2.8\n */\nexport const compose: <A, B>(to: Decoder<A, B>) => <I>(from: Decoder<I, A>) => Decoder<I, B> =\n  /*#__PURE__*/\n  K.compose(M)\n\n/**\n * @category Category\n * @since 2.2.8\n */\nexport const id: <A>() => Decoder<A, A> =\n  /*#__PURE__*/\n  K.id(M)\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport const URI = 'io-ts/Decoder'\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind2<E, A> {\n    readonly [URI]: Decoder<E, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Functor: Functor2<URI> = {\n  URI,\n  map: map_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Alt: Alt2<URI> = {\n  URI,\n  map: map_,\n  alt: alt_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Category: Category2<URI> = {\n  URI,\n  compose: compose_,\n  id\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Schemable: S.Schemable2C<URI, unknown> = {\n  URI,\n  literal,\n  string,\n  number,\n  boolean,\n  nullable,\n  type,\n  struct,\n  partial,\n  record,\n  array,\n  tuple: tuple as S.Schemable2C<URI, unknown>['tuple'],\n  intersect,\n  sum,\n  lazy,\n  readonly\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnknownContainers: S.WithUnknownContainers2C<URI, unknown> = {\n  UnknownArray,\n  UnknownRecord\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnion: S.WithUnion2C<URI, unknown> = {\n  union: union as S.WithUnion2C<URI, unknown>['union']\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithRefine: S.WithRefine2C<URI, unknown> = {\n  refine: refine as S.WithRefine2C<URI, unknown>['refine']\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.8\n */\nexport type InputOf<D> = K.InputOf<E.URI, D>\n\n/**\n * @since 2.2.7\n */\nexport type TypeOf<D> = K.TypeOf<E.URI, D>\n\ninterface Tree<A> {\n  readonly value: A\n  readonly forest: ReadonlyArray<Tree<A>>\n}\n\nconst empty: Array<never> = []\n\nconst make = <A>(value: A, forest: ReadonlyArray<Tree<A>> = empty): Tree<A> => ({\n  value,\n  forest\n})\n\nconst drawTree = (tree: Tree<string>): string => tree.value + drawForest('\\n', tree.forest)\n\nconst drawForest = (indentation: string, forest: ReadonlyArray<Tree<string>>): string => {\n  let r = ''\n  const len = forest.length\n  let tree: Tree<string>\n  for (let i = 0; i < len; i++) {\n    tree = forest[i]\n    const isLast = i === len - 1\n    r += indentation + (isLast ? '\u2514' : '\u251c') + '\u2500 ' + tree.value\n    r += drawForest(indentation + (len > 1 && !isLast ? '\u2502  ' : '   '), tree.forest)\n  }\n  return r\n}\n\nconst toTree: (e: DE.DecodeError<string>) => Tree<string> = DE.fold({\n  Leaf: (input, error) => make(`cannot decode ${JSON.stringify(input)}, should be ${error}`),\n  Key: (key, kind, errors) => make(`${kind} property ${JSON.stringify(key)}`, toForest(errors)),\n  Index: (index, kind, errors) => make(`${kind} index ${index}`, toForest(errors)),\n  Member: (index, errors) => make(`member ${index}`, toForest(errors)),\n  Lazy: (id, errors) => make(`lazy type ${id}`, toForest(errors)),\n  Wrap: (error, errors) => make(error, toForest(errors))\n})\n\nconst toForest = (e: DecodeError): ReadonlyArray<Tree<string>> => {\n  const stack = []\n  let focus = e\n  const res = []\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    switch (focus._tag) {\n      case 'Of':\n        {\n          res.push(toTree(focus.value))\n          const tmp = stack.pop()\n          if (tmp === undefined) {\n            return res\n          } else {\n            focus = tmp\n          }\n        }\n        break\n      case 'Concat':\n        stack.push(focus.right)\n        focus = focus.left\n        break\n    }\n  }\n}\n\n/**\n * @since 2.2.7\n */\nexport const draw = (e: DecodeError): string => toForest(e).map(drawTree).join('\\n')\n\n/**\n * @internal\n */\nexport const stringify: <A>(e: E.Either<DecodeError, A>) => string =\n  /*#__PURE__*/\n  E.fold(draw, (a) => JSON.stringify(a, null, 2))\n\n\n### Dependency File: Encoder.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.3\n */\nimport { Category2 } from 'fp-ts/lib/Category'\nimport { Contravariant2 } from 'fp-ts/lib/Contravariant'\nimport { identity } from 'fp-ts/lib/function'\n\nimport { intersect_, memoize } from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.3\n */\nexport interface Encoder<O, A> {\n  readonly encode: (a: A) => O\n}\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function nullable<O, A>(or: Encoder<O, A>): Encoder<null | O, null | A> {\n  return {\n    encode: (a) => (a === null ? null : or.encode(a))\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function struct<P extends Record<string, Encoder<any, any>>>(\n  properties: P\n): Encoder<{ [K in keyof P]: OutputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> {\n  return {\n    encode: (a) => {\n      const o: Record<keyof P, any> = {} as any\n      for (const k in properties) {\n        o[k] = properties[k].encode(a[k])\n      }\n      return o\n    }\n  }\n}\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.3\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function partial<P extends Record<string, Encoder<any, any>>>(\n  properties: P\n): Encoder<Partial<{ [K in keyof P]: OutputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> {\n  return {\n    encode: (a) => {\n      const o: Record<keyof P, any> = {} as any\n      for (const k in properties) {\n        const v = a[k]\n        // don't add missing properties\n        if (k in a) {\n          // don't strip undefined properties\n          o[k] = v === undefined ? undefined : properties[k].encode(v)\n        }\n      }\n      return o\n    }\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function record<O, A>(codomain: Encoder<O, A>): Encoder<Record<string, O>, Record<string, A>> {\n  return {\n    encode: (r) => {\n      const o: Record<string, O> = {}\n      for (const k in r) {\n        o[k] = codomain.encode(r[k])\n      }\n      return o\n    }\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function array<O, A>(item: Encoder<O, A>): Encoder<Array<O>, Array<A>> {\n  return {\n    encode: (as) => as.map(item.encode)\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function tuple<C extends ReadonlyArray<Encoder<any, any>>>(\n  ...components: C\n): Encoder<{ [K in keyof C]: OutputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> {\n  return {\n    encode: (as) => components.map((c, i) => c.encode(as[i])) as any\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport const intersect =\n  <P, B>(right: Encoder<P, B>) =>\n  <O, A>(left: Encoder<O, A>): Encoder<O & P, A & B> => ({\n    encode: (ab) => intersect_(left.encode(ab), right.encode(ab))\n  })\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function sum<T extends string>(\n  tag: T\n): <MS extends Record<string, Encoder<any, any>>>(\n  members: MS\n) => Encoder<OutputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> {\n  return (members) => {\n    return {\n      encode: (a) => members[a[tag]].encode(a)\n    }\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function lazy<O, A>(f: () => Encoder<O, A>): Encoder<O, A> {\n  const get = memoize<void, Encoder<O, A>>(f)\n  return {\n    encode: (a) => get().encode(a)\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.16\n */\nexport const readonly: <O, A>(decoder: Encoder<O, A>) => Encoder<O, Readonly<A>> = identity\n\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n\nconst contramap_: <E, A, B>(ea: Encoder<E, A>, f: (b: B) => A) => Encoder<E, B> = (ea, f) => ({\n  encode: (b) => ea.encode(f(b))\n})\n\nconst compose_: <E, A, B>(ab: Encoder<A, B>, ea: Encoder<E, A>) => Encoder<E, B> = (ab, ea) => contramap_(ea, ab.encode)\n\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n\n/**\n * @category Contravariant\n * @since 2.2.3\n */\nexport const contramap: <A, B>(f: (b: B) => A) => <E>(fa: Encoder<E, A>) => Encoder<E, B> = (f) => (fa) =>\n  contramap_(fa, f)\n\n/**\n * @category Semigroupoid\n * @since 2.2.3\n */\nexport const compose: <E, A>(ea: Encoder<E, A>) => <B>(ab: Encoder<A, B>) => Encoder<E, B> = (ea) => (ab) =>\n  compose_(ab, ea)\n\n/**\n * @category Category\n * @since 2.2.3\n */\nexport function id<A>(): Encoder<A, A> {\n  return {\n    encode: identity\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.3\n */\nexport const URI = 'io-ts/Encoder'\n\n/**\n * @category instances\n * @since 2.2.3\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind2<E, A> {\n    readonly [URI]: Encoder<E, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Contravariant: Contravariant2<URI> = {\n  URI,\n  contramap: contramap_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Category: Category2<URI> = {\n  URI,\n  compose: compose_,\n  id\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport type TypeOf<E> = E extends Encoder<any, infer A> ? A : never\n\n/**\n * @since 2.2.3\n */\nexport type OutputOf<E> = E extends Encoder<infer O, any> ? O : never\n\n\n### Dependency File: Schemable.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { Refinement } from 'fp-ts/lib/function'\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\n/**\n * @since 2.2.0\n */\nexport type Literal = string | number | boolean | null\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable<S> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => HKT<S, A[number]>\n  readonly string: HKT<S, string>\n  readonly number: HKT<S, number>\n  readonly boolean: HKT<S, boolean>\n  readonly nullable: <A>(or: HKT<S, A>) => HKT<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: HKT<S, A>) => HKT<S, Record<string, A>>\n  readonly array: <A>(item: HKT<S, A>) => HKT<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, A>\n  readonly intersect: <B>(right: HKT<S, B>) => <A>(left: HKT<S, A>) => HKT<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: HKT<S, A[K] & Record<T, K>> }) => HKT<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => HKT<S, A>) => HKT<S, A>\n  readonly readonly: <A>(sa: HKT<S, A>) => HKT<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable1<S extends URIS> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind<S, A[number]>\n  readonly string: Kind<S, string>\n  readonly number: Kind<S, number>\n  readonly boolean: Kind<S, boolean>\n  readonly nullable: <A>(or: Kind<S, A>) => Kind<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: Kind<S, A>) => Kind<S, Record<string, A>>\n  readonly array: <A>(item: Kind<S, A>) => Kind<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, A>\n  readonly intersect: <B>(right: Kind<S, B>) => <A>(left: Kind<S, A>) => Kind<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind<S, A[K] & Record<T, K>> }) => Kind<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind<S, A>) => Kind<S, A>\n  readonly readonly: <A>(sa: Kind<S, A>) => Kind<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface Schemable2C<S extends URIS2, E> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind2<S, E, A[number]>\n  readonly string: Kind2<S, E, string>\n  readonly number: Kind2<S, E, number>\n  readonly boolean: Kind2<S, E, boolean>\n  readonly nullable: <A>(or: Kind2<S, E, A>) => Kind2<S, E, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<\n    S,\n    E,\n    Partial<{ [K in keyof A]: A[K] }>\n  >\n  readonly record: <A>(codomain: Kind2<S, E, A>) => Kind2<S, E, Record<string, A>>\n  readonly array: <A>(item: Kind2<S, E, A>) => Kind2<S, E, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(\n    ...components: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A>\n  readonly intersect: <B>(right: Kind2<S, E, B>) => <A>(left: Kind2<S, E, A>) => Kind2<S, E, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind2<S, E, A[K] & Record<T, K>> }) => Kind2<S, E, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind2<S, E, A>) => Kind2<S, E, A>\n  readonly readonly: <A>(sa: Kind2<S, E, A>) => Kind2<S, E, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers<S> {\n  readonly UnknownArray: HKT<S, Array<unknown>>\n  readonly UnknownRecord: HKT<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers1<S extends URIS> {\n  readonly UnknownArray: Kind<S, Array<unknown>>\n  readonly UnknownRecord: Kind<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnknownContainers2C<S extends URIS2, E> {\n  readonly UnknownArray: Kind2<S, E, Array<unknown>>\n  readonly UnknownRecord: Kind2<S, E, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion<S> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: HKT<S, A[K]> }\n  ) => HKT<S, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion1<S extends URIS> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind<S, A[K]> }\n  ) => Kind<S, A[number]>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnion2C<S extends URIS2, E> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine<S> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: HKT<S, A>) => HKT<S, B>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine1<S extends URIS> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Kind<S, A>) => Kind<S, B>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithRefine2C<S extends URIS2, E> {\n  readonly refine: <A, B extends A>(\n    refinement: Refinement<A, B>,\n    id: string\n  ) => (from: Kind2<S, E, A>) => Kind2<S, E, B>\n}\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst typeOf = (x: unknown): string => (x === null ? 'null' : typeof x)\n\n/**\n * @internal\n */\nexport const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport * as assert from 'assert'\nimport * as E from 'fp-ts/lib/Either'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as _ from '../src/Codec'\nimport * as DE from '../src/DecodeError'\nimport * as D from '../src/Decoder'\nimport * as FS from '../src/FreeSemigroup'\nimport * as H from './helpers'\n\nconst codecNumberFromString: _.Codec<string, string, number> = _.make(\n  H.decoderNumberFromString,\n  H.encoderNumberToString\n)\n\nconst codecNumber: _.Codec<unknown, string, number> = pipe(_.string, _.compose(codecNumberFromString))\n\nconst codecPositive: _.Codec<unknown, number, H.Positive> = _.fromDecoder(H.decoderPositive)\n\nconst codecInt: _.Codec<unknown, number, H.Int> = _.fromDecoder(H.decoderInt)\n\nconst codecUndefined: _.Codec<unknown, undefined, undefined> = _.fromDecoder(H.decoderUndefined)\n\nexport type Json = boolean | number | string | null | JsonArray | JsonRecord\n\nexport interface JsonRecord {\n  readonly [key: string]: Json\n}\n\nexport interface JsonArray extends ReadonlyArray<Json> {}\n\nexport function parseJSON<E>(s: string, onError: (reason: unknown) => E): E.Either<E, Json> {\n  return E.tryCatch(() => JSON.parse(s), onError)\n}\n\ndescribe.concurrent('Codec', () => {\n  describe.concurrent('Invariant', () => {\n    it('imap', () => {\n      const codec = _.Invariant.imap(\n        _.string,\n        (s) => ({ value: s }),\n        ({ value }) => value\n      )\n      assert.deepStrictEqual(codec.decode('a'), D.success({ value: 'a' }))\n      assert.deepStrictEqual(codec.encode({ value: 'a' }), 'a')\n    })\n  })\n\n  it('imap', () => {\n    const codec = pipe(\n      _.string,\n      _.imap(\n        (s) => ({ value: s }),\n        ({ value }) => value\n      )\n    )\n    assert.deepStrictEqual(codec.decode('a'), D.success({ value: 'a' }))\n    assert.deepStrictEqual(codec.encode({ value: 'a' }), 'a')\n  })\n\n  describe.concurrent('mapLeftWithInput', () => {\n    describe.concurrent('decode', () => {\n      it('should, return the provided expected', () => {\n        const decoder = pipe(\n          _.number,\n          _.mapLeftWithInput((u) => FS.of(DE.leaf(u, 'not a number')))\n        )\n        assert.deepStrictEqual(decoder.decode('a'), D.failure('a', 'not a number'))\n      })\n    })\n  })\n\n  describe.concurrent('string', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = _.string\n        assert.deepStrictEqual(codec.decode('a'), D.success('a'))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = _.string\n        assert.deepStrictEqual(codec.decode(null), D.failure(null, 'string'))\n      })\n    })\n  })\n\n  describe.concurrent('number', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = _.number\n        assert.deepStrictEqual(codec.decode(1), D.success(1))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = _.number\n        assert.deepStrictEqual(codec.decode(null), D.failure(null, 'number'))\n      })\n    })\n  })\n\n  describe.concurrent('boolean', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = _.boolean\n        assert.deepStrictEqual(codec.decode(true), D.success(true))\n        assert.deepStrictEqual(codec.decode(false), D.success(false))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = _.boolean\n        assert.deepStrictEqual(codec.decode(null), D.failure(null, 'boolean'))\n      })\n    })\n  })\n\n  describe.concurrent('literal', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = _.literal('a', null, 'b', 1, true)\n        assert.deepStrictEqual(codec.decode('a'), D.success('a'))\n        assert.deepStrictEqual(codec.decode(null), D.success(null))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = _.literal('a', null)\n        assert.deepStrictEqual(codec.decode('b'), D.failure('b', '\"a\" | null'))\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const codec = _.literal('a')\n        assert.deepStrictEqual(codec.encode('a'), 'a')\n      })\n    })\n  })\n\n  describe.concurrent('refine', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = pipe(\n          _.string,\n          _.refine((s): s is string => s.length > 0, 'NonEmptyString')\n        )\n        assert.deepStrictEqual(codec.decode('a'), D.success('a'))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = pipe(\n          _.string,\n          _.refine((s): s is string => s.length > 0, 'NonEmptyString')\n        )\n        assert.deepStrictEqual(codec.decode(undefined), D.failure(undefined, 'string'))\n        assert.deepStrictEqual(codec.decode(''), D.failure('', 'NonEmptyString'))\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const codec = pipe(\n          _.string,\n          _.refine((s): s is string => s.length > 0, 'NonEmptyString')\n        )\n        assert.strictEqual(codec.encode('a'), 'a')\n      })\n    })\n  })\n\n  describe.concurrent('nullable', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = _.nullable(codecNumber)\n        assert.deepStrictEqual(codec.decode(null), D.success(null))\n        assert.deepStrictEqual(codec.decode('1'), D.success(1))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = _.nullable(codecNumber)\n        assert.deepStrictEqual(\n          codec.decode(undefined),\n          E.left(\n            FS.concat(\n              FS.of(DE.member(0, FS.of(DE.leaf(undefined, 'null')))),\n              FS.of(DE.member(1, FS.of(DE.leaf(undefined, 'string'))))\n            )\n          )\n        )\n        assert.deepStrictEqual(\n          codec.decode('a'),\n          E.left(\n            FS.concat(\n              FS.of(DE.member(0, FS.of(DE.leaf('a', 'null')))),\n              FS.of(DE.member(1, FS.of(DE.leaf('a', 'parsable to a number'))))\n            )\n          )\n        )\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const codec = _.nullable(codecNumber)\n        assert.strictEqual(codec.encode(null), null)\n        assert.strictEqual(codec.encode(1), '1')\n      })\n    })\n  })\n\n  describe.concurrent('struct', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = _.struct({\n          a: _.string\n        })\n        assert.deepStrictEqual(codec.decode({ a: 'a' }), D.success({ a: 'a' }))\n      })\n\n      it('should strip additional fields', () => {\n        const codec = _.struct({\n          a: _.string\n        })\n        assert.deepStrictEqual(codec.decode({ a: 'a', b: 1 }), D.success({ a: 'a' }))\n      })\n\n      it('should not strip fields corresponding to undefined values', () => {\n        const codec = _.struct({\n          a: codecUndefined\n        })\n        assert.deepStrictEqual(codec.decode({}), D.success({ a: undefined }))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = _.struct({\n          a: _.string\n        })\n        assert.deepStrictEqual(codec.decode(undefined), D.failure(undefined, 'Record<string, unknown>'))\n        assert.deepStrictEqual(\n          codec.decode({ a: 1 }),\n          E.left(FS.of(DE.key('a', DE.required, FS.of(DE.leaf(1, 'string')))))\n        )\n      })\n\n      it('should collect all errors', () => {\n        const codec = _.struct({\n          a: _.string,\n          b: _.number\n        })\n        assert.deepStrictEqual(\n          codec.decode({}),\n          E.left(\n            FS.concat(\n              FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string')))),\n              FS.of(DE.key('b', DE.required, FS.of(DE.leaf(undefined, 'number'))))\n            )\n          )\n        )\n      })\n\n      it('should support getters', () => {\n        class A {\n          get a() {\n            return 'a'\n          }\n          get b() {\n            return 'b'\n          }\n        }\n        const codec = _.struct({ a: _.string, b: _.string })\n        assert.deepStrictEqual(codec.decode(new A()), D.success({ a: 'a', b: 'b' }))\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const codec = _.struct({ a: codecNumber })\n        assert.deepStrictEqual(codec.encode({ a: 1 }), { a: '1' })\n      })\n\n      it('should strip additional fields', () => {\n        const codec = _.struct({ a: _.number })\n        const a = { a: 1, b: true }\n        assert.deepStrictEqual(codec.encode(a), { a: 1 })\n      })\n    })\n  })\n\n  describe.concurrent('partial', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = _.partial({ a: _.string })\n        assert.deepStrictEqual(codec.decode({ a: 'a' }), D.success({ a: 'a' }))\n        assert.deepStrictEqual(codec.decode({}), D.success({}))\n      })\n\n      it('should strip additional fields', () => {\n        const codec = _.partial({ a: _.string })\n        assert.deepStrictEqual(codec.decode({ a: 'a', b: 1 }), D.success({ a: 'a' }))\n      })\n\n      it('should not add missing fields', () => {\n        const codec = _.partial({ a: _.string })\n        assert.deepStrictEqual(codec.decode({}), D.success({}))\n      })\n\n      it('should not strip fields corresponding to undefined values', () => {\n        const codec = _.partial({ a: _.string })\n        assert.deepStrictEqual(codec.decode({ a: undefined }), D.success({ a: undefined }))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = _.partial({ a: _.string })\n        assert.deepStrictEqual(codec.decode(undefined), D.failure(undefined, 'Record<string, unknown>'))\n        assert.deepStrictEqual(\n          codec.decode({ a: 1 }),\n          E.left(FS.of(DE.key('a', DE.optional, FS.of(DE.leaf(1, 'string')))))\n        )\n      })\n\n      it('should collect all errors', () => {\n        const codec = _.partial({\n          a: _.string,\n          b: _.number\n        })\n        assert.deepStrictEqual(\n          codec.decode({ a: 1, b: 'b' }),\n          E.left(\n            FS.concat(\n              FS.of(DE.key('a', DE.optional, FS.of(DE.leaf(1, 'string')))),\n              FS.of(DE.key('b', DE.optional, FS.of(DE.leaf('b', 'number'))))\n            )\n          )\n        )\n      })\n\n      it('should support getters', () => {\n        class A {\n          get a() {\n            return 'a'\n          }\n          get b() {\n            return 'b'\n          }\n        }\n        const codec = _.partial({ a: _.string, b: _.string })\n        assert.deepStrictEqual(codec.decode(new A()), D.success({ a: 'a', b: 'b' }))\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const codec = _.partial({ a: codecNumber })\n        assert.deepStrictEqual(codec.encode({}), {})\n        assert.deepStrictEqual(codec.encode({ a: 1 }), { a: '1' })\n      })\n\n      it('should strip additional fields', () => {\n        const codec = _.partial({ a: _.string })\n        const a = { a: 'a', b: true }\n        assert.deepStrictEqual(codec.encode(a), { a: 'a' })\n      })\n\n      it('should not add missing fields', () => {\n        const codec = _.partial({ a: _.string })\n        assert.deepStrictEqual(codec.encode({}), {})\n      })\n\n      it('should not strip fields corresponding to undefined values', () => {\n        const codec = _.partial({ a: _.string })\n        assert.deepStrictEqual(codec.encode({ a: undefined }), { a: undefined })\n      })\n    })\n  })\n\n  describe.concurrent('record', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid value', () => {\n        const codec = _.record(_.number)\n        assert.deepStrictEqual(codec.decode({}), D.success({}))\n        assert.deepStrictEqual(codec.decode({ a: 1 }), D.success({ a: 1 }))\n      })\n\n      it('should reject an invalid value', () => {\n        const codec = _.record(_.number)\n        assert.deepStrictEqual(codec.decode(undefined), D.failure(undefined, 'Record<string, unknown>'))\n        assert.deepStrictEqual(\n          codec.decode({ a: 'a' }),\n          E.left(FS.of(DE.key('a', DE.optional, FS.of(DE.leaf('a', 'number')))))\n        )\n      })\n\n      it('should collect all errors', () => {\n        const codec = _.record(_.number)\n        assert.deepStrictEqual(\n          codec.decode({ a: 'a', b: 'b' }),\n          E.left(\n            FS.concat(\n              FS.of(DE.key('a', DE.optional, FS.of(DE.leaf('a', 'number')))),\n              FS.of(DE.key('b', DE.optional, FS.of(DE.leaf('b', 'number'))))\n            )\n          )\n        )\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const codec = _.record(codecNumber)\n        assert.deepStrictEqual(codec.encode({ a: 1, b: 2 }), { a: '1', b: '2' })\n      })\n    })\n  })\n\n  describe.concurrent('array', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = _.array(_.string)\n        assert.deepStrictEqual(codec.decode([]), D.success([]))\n        assert.deepStrictEqual(codec.decode(['a']), D.success(['a']))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = _.array(_.string)\n        assert.deepStrictEqual(codec.decode(undefined), D.failure(undefined, 'Array<unknown>'))\n        assert.deepStrictEqual(codec.decode([1]), E.left(FS.of(DE.index(0, DE.optional, FS.of(DE.leaf(1, 'string'))))))\n      })\n\n      it('should collect all errors', () => {\n        const codec = _.array(_.string)\n        assert.deepStrictEqual(\n          codec.decode([1, 2]),\n          E.left(\n            FS.concat(\n              FS.of(DE.index(0, DE.optional, FS.of(DE.leaf(1, 'string')))),\n              FS.of(DE.index(1, DE.optional, FS.of(DE.leaf(2, 'string'))))\n            )\n          )\n        )\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const codec = _.array(codecNumber)\n        assert.deepStrictEqual(codec.encode([1, 2]), ['1', '2'])\n      })\n    })\n  })\n\n  describe.concurrent('tuple', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = _.tuple(_.string, _.number)\n        assert.deepStrictEqual(codec.decode(['a', 1]), D.success(['a', 1]))\n      })\n\n      it('should handle zero components', () => {\n        assert.deepStrictEqual(_.tuple().decode([]), D.success([]))\n      })\n\n      it('should reject an invalid input', () => {\n        const codec = _.tuple(_.string, _.number)\n        assert.deepStrictEqual(codec.decode(undefined), D.failure(undefined, 'Array<unknown>'))\n        assert.deepStrictEqual(\n          codec.decode(['a']),\n          E.left(FS.of(DE.index(1, DE.required, FS.of(DE.leaf(undefined, 'number')))))\n        )\n        assert.deepStrictEqual(\n          codec.decode([1, 2]),\n          E.left(FS.of(DE.index(0, DE.required, FS.of(DE.leaf(1, 'string')))))\n        )\n      })\n\n      it('should collect all errors', () => {\n        const codec = _.tuple(_.string, _.number)\n        assert.deepStrictEqual(\n          codec.decode([1, 'a']),\n          E.left(\n            FS.concat(\n              FS.of(DE.index(0, DE.required, FS.of(DE.leaf(1, 'string')))),\n              FS.of(DE.index(1, DE.required, FS.of(DE.leaf('a', 'number'))))\n            )\n          )\n        )\n      })\n\n      it('should strip additional components', () => {\n        const codec = _.tuple(_.string, _.number)\n        assert.deepStrictEqual(codec.decode(['a', 1, true]), D.success(['a', 1]))\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const codec = _.tuple(codecNumber, _.string)\n        assert.deepStrictEqual(codec.encode([1, 'a']), ['1', 'a'])\n      })\n    })\n  })\n\n  describe.concurrent('intersect', () => {\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const codec = pipe(_.struct({ a: _.string }), _.intersect(_.struct({ b: _.number })))\n        assert.deepStrictEqual(codec.decode({ a: 'a', b: 1 }), D.success({ a: 'a', b: 1 }))\n      })\n\n      it('should handle primitives', () => {\n        const codec = pipe(codecInt, _.intersect(codecPositive))\n        assert.deepStrictEqual(codec.decode(1), D.success(1))\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const codec = pipe(_.struct({ a: _.string }), _.intersect(_.struct({ b: codecNumber })))\n        assert.deepStrictEqual(codec.encode({ a: 'a', b: 1 }), { a: 'a', b: '1' })\n      })\n\n      it('should handle primitives', () => {\n        const codec = pipe(codecInt, _.intersect(codecPositive))\n        assert.deepStrictEqual(codec.encode(1 as any), 1)\n      })\n    })\n  })\n\n  describe.concurrent('sum', () => {\n    const sum = _.sum('_tag')\n\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        const A = _.struct({ _tag: _.literal('A'), a: _.string })\n        const B = _.struct({ _tag: _.literal('B'), b: _.number })\n        const codec = sum({ A, B })\n        assert.deepStrictEqual(codec.decode({ _tag: 'A', a: 'a' }), D.success({ _tag: 'A', a: 'a' }))\n        assert.deepStrictEqual(codec.decode({ _tag: 'B', b: 1 }), D.success({ _tag: 'B', b: 1 }))\n      })\n\n      it('should reject an invalid input', () => {\n        const A = _.struct({ _tag: _.literal('A'), a: _.string })\n        const B = _.struct({ _tag: _.literal('B'), b: _.number })\n        const codec = sum({ A, B })\n        assert.deepStrictEqual(codec.decode(null), D.failure(null, 'Record<string, unknown>'))\n        assert.deepStrictEqual(\n          codec.decode({}),\n          E.left(FS.of(DE.key('_tag', DE.required, FS.of(DE.leaf(undefined, '\"A\" | \"B\"')))))\n        )\n        assert.deepStrictEqual(\n          codec.decode({ _tag: 'A', a: 1 }),\n          E.left(FS.of(DE.key('a', DE.required, FS.of(DE.leaf(1, 'string')))))\n        )\n      })\n\n      it('should support empty records', () => {\n        const decoder = sum({})\n        assert.deepStrictEqual(\n          decoder.decode({}),\n          E.left(FS.of(DE.key('_tag', DE.required, FS.of(DE.leaf(undefined, 'never')))))\n        )\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        const A = _.struct({ _tag: _.literal('A'), a: _.string })\n        const B = _.struct({ _tag: _.literal('B'), b: codecNumber })\n        const codec = sum({ A, B })\n        assert.deepStrictEqual(codec.encode({ _tag: 'A', a: 'a' }), { _tag: 'A', a: 'a' })\n        assert.deepStrictEqual(codec.encode({ _tag: 'B', b: 1 }), { _tag: 'B', b: '1' })\n      })\n    })\n  })\n\n  describe.concurrent('lazy', () => {\n    interface A {\n      a: number\n      b?: A\n    }\n    interface AOut {\n      a: string\n      b?: AOut\n    }\n\n    const lazyCodec: _.Codec<unknown, AOut, A> = _.lazy('A', () =>\n      pipe(_.struct({ a: codecNumber }), _.intersect(_.partial({ b: lazyCodec })))\n    )\n\n    describe.concurrent('decode', () => {\n      it('should decode a valid input', () => {\n        assert.deepStrictEqual(lazyCodec.decode({ a: '1' }), D.success({ a: 1 }))\n        assert.deepStrictEqual(lazyCodec.decode({ a: '1', b: { a: '2' } }), D.success({ a: 1, b: { a: 2 } }))\n      })\n\n      it('should reject an invalid input', () => {\n        assert.deepStrictEqual(\n          lazyCodec.decode({ a: 1 }),\n          E.left(FS.of(DE.lazy('A', FS.of(DE.key('a', DE.required, FS.of(DE.leaf(1, 'string')))))))\n        )\n        assert.deepStrictEqual(\n          lazyCodec.decode({ a: 'a' }),\n          E.left(FS.of(DE.lazy('A', FS.of(DE.key('a', DE.required, FS.of(DE.leaf('a', 'parsable to a number')))))))\n        )\n        assert.deepStrictEqual(\n          lazyCodec.decode({ a: '1', b: {} }),\n          E.left(\n            FS.of(\n              DE.lazy(\n                'A',\n                FS.of(\n                  DE.key(\n                    'b',\n                    DE.optional,\n                    FS.of(DE.lazy('A', FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string'))))))\n                  )\n                )\n              )\n            )\n          )\n        )\n      })\n    })\n\n    describe.concurrent('encode', () => {\n      it('should encode a value', () => {\n        assert.deepStrictEqual(lazyCodec.encode({ a: 1 }), { a: '1' })\n        assert.deepStrictEqual(lazyCodec.encode({ a: 1, b: { a: 2 } }), { a: '1', b: { a: '2' } })\n      })\n    })\n  })\n\n  it('#453', () => {\n    const Base64: _.Codec<string, string, string> = {\n      decode: (s) =>\n        E.tryCatch(\n          () => Buffer.from(s, 'base64').toString(),\n          () => D.error(s, 'Base64')\n        ),\n      encode: (s) => Buffer.from(s).toString('base64')\n    }\n\n    const Json: _.Codec<string, string, Json> = {\n      decode: (s) => parseJSON(s, () => D.error(s, 'Json')),\n      encode: (a) => JSON.stringify(a)\n    }\n\n    const DateFromString: _.Codec<string, string, Date> = _.make(\n      {\n        decode: (s) => {\n          const d = new Date(s)\n          return isNaN(d.getTime()) ? D.failure(s, 'DateFromISOString') : D.success(d)\n        }\n      },\n      { encode: String }\n    )\n\n    const User = _.struct({ a: _.string, b: pipe(_.string, _.compose(DateFromString)) })\n\n    const codec = pipe(_.string, _.compose(Base64), _.compose(Json), _.compose(User))\n\n    assert.deepStrictEqual(\n      codec.decode(codec.encode({ a: 'a', b: new Date('1980') })),\n      E.right({\n        a: 'a',\n        b: new Date('1980')\n      })\n    )\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\Decoder.ts\\Decoder.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Alt2, Alt2C } from 'fp-ts/lib/Alt'\nimport { Bifunctor2 } from 'fp-ts/lib/Bifunctor'\nimport { Category2 } from 'fp-ts/lib/Category'\nimport * as E from 'fp-ts/lib/Either'\nimport { identity, Refinement } from 'fp-ts/lib/function'\nimport { Functor2 } from 'fp-ts/lib/Functor'\nimport { MonadThrow2C } from 'fp-ts/lib/MonadThrow'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as DE from './DecodeError'\nimport * as FS from './FreeSemigroup'\nimport * as G from './Guard'\nimport * as K from './Kleisli'\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// Kleisli config\n// -------------------------------------------------------------------------------------\n\n/**\n * @internal\n */\nexport const SE =\n  /*#__PURE__*/\n  DE.getSemigroup<string>()\n\n/**\n * @internal\n */\nexport const ap = <A, B>(\n  fab: E.Either<DecodeError, (a: A) => B>,\n  fa: E.Either<DecodeError, A>\n): E.Either<DecodeError, B> =>\n  E.isLeft(fab)\n    ? E.isLeft(fa)\n      ? E.left(SE.concat(fab.left, fa.left))\n      : fab\n    : E.isLeft(fa)\n    ? fa\n    : E.right(fab.right(fa.right))\n\nconst M: MonadThrow2C<E.URI, DecodeError> & Bifunctor2<E.URI> & Alt2C<E.URI, DecodeError> = {\n  URI: E.URI,\n  _E: undefined as any,\n  map: (fa, f) => pipe(fa, E.map(f)),\n  ap,\n  of: E.right,\n  chain: (ma, f) => pipe(ma, E.chain(f)),\n  throwError: E.left,\n  bimap: (fa, f, g) => pipe(fa, E.bimap(f, g)),\n  mapLeft: (fa, f) => pipe(fa, E.mapLeft(f)),\n  alt: (me, that) => {\n    if (E.isRight(me)) {\n      return me\n    }\n    const ea = that()\n    return E.isLeft(ea) ? E.left(SE.concat(me.left, ea.left)) : ea\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.8\n */\nexport interface Decoder<I, A> extends K.Kleisli<E.URI, I, DecodeError, A> {}\n\n// -------------------------------------------------------------------------------------\n// DecodeError\n// -------------------------------------------------------------------------------------\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport type DecodeError = FS.FreeSemigroup<DE.DecodeError<string>>\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const error = (actual: unknown, message: string): DecodeError => FS.of(DE.leaf(actual, message))\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const success: <A>(a: A) => E.Either<DecodeError, A> = E.right\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const failure = <A = never>(actual: unknown, message: string): E.Either<DecodeError, A> =>\n  E.left(error(actual, message))\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.8\n */\nexport const fromRefinement = <I, A extends I>(refinement: Refinement<I, A>, expected: string): Decoder<I, A> =>\n  K.fromRefinement(M)(refinement, (u) => error(u, expected))\n\n/**\n * @category constructors\n * @since 2.2.8\n */\nexport const fromGuard = <I, A extends I>(guard: G.Guard<I, A>, expected: string): Decoder<I, A> =>\n  fromRefinement(guard.is, expected)\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n) => Decoder<unknown, A[number]> =\n  /*#__PURE__*/\n  K.literal(M)((u, values) => error(u, values.map((value) => JSON.stringify(value)).join(' | ')))\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const string: Decoder<unknown, string> =\n  /*#__PURE__*/\n  fromGuard(G.string, 'string')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const number: Decoder<unknown, number> =\n  /*#__PURE__*/\n  fromGuard(G.number, 'number')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const boolean: Decoder<unknown, boolean> =\n  /*#__PURE__*/\n  fromGuard(G.boolean, 'boolean')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const UnknownArray: Decoder<unknown, Array<unknown>> =\n  /*#__PURE__*/\n  fromGuard(G.UnknownArray, 'Array<unknown>')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const UnknownRecord: Decoder<unknown, Record<string, unknown>> =\n  /*#__PURE__*/\n  fromGuard(G.UnknownRecord, 'Record<string, unknown>')\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const mapLeftWithInput: <I>(\n  f: (input: I, e: DecodeError) => DecodeError\n) => <A>(decoder: Decoder<I, A>) => Decoder<I, A> =\n  /*#__PURE__*/\n  K.mapLeftWithInput(M)\n\n/**\n * @category combinators\n * @since 2.2.9\n */\nexport const withMessage = <I>(\n  message: (input: I, e: DecodeError) => string\n): (<A>(decoder: Decoder<I, A>) => Decoder<I, A>) =>\n  mapLeftWithInput((input, e) => FS.of(DE.wrap(message(input, e), e)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const refine = <A, B extends A>(\n  refinement: Refinement<A, B>,\n  id: string\n): (<I>(from: Decoder<I, A>) => Decoder<I, B>) => K.refine(M)(refinement, (a) => error(a, id))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const parse: <A, B>(parser: (a: A) => E.Either<DecodeError, B>) => <I>(from: Decoder<I, A>) => Decoder<I, B> =\n  /*#__PURE__*/\n  K.parse(M)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const nullable: <I, A>(or: Decoder<I, A>) => Decoder<null | I, null | A> =\n  /*#__PURE__*/\n  K.nullable(M)((u, e) => FS.concat(FS.of(DE.member(0, error(u, 'null'))), FS.of(DE.member(1, e))))\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const fromStruct = <P extends Record<string, Decoder<any, any>>>(\n  properties: P\n): Decoder<{ [K in keyof P]: InputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> =>\n  K.fromStruct(M)((k, e) => FS.of(DE.key(k, DE.required, e)))(properties)\n\n/**\n * Use `fromStruct` instead.\n *\n * @category combinators\n * @since 2.2.8\n * @deprecated\n */\nexport const fromType = fromStruct\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const struct = <A>(properties: { [K in keyof A]: Decoder<unknown, A[K]> }): Decoder<\n  unknown,\n  { [K in keyof A]: A[K] }\n> => pipe(UnknownRecord as any, compose(fromStruct(properties)))\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.7\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromPartial = <P extends Record<string, Decoder<any, any>>>(\n  properties: P\n): Decoder<Partial<{ [K in keyof P]: InputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> =>\n  K.fromPartial(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(properties)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const partial = <A>(properties: { [K in keyof A]: Decoder<unknown, A[K]> }): Decoder<\n  unknown,\n  Partial<{ [K in keyof A]: A[K] }>\n> => pipe(UnknownRecord as any, compose(fromPartial(properties)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromArray = <I, A>(item: Decoder<I, A>): Decoder<Array<I>, Array<A>> =>\n  K.fromArray(M)((i, e) => FS.of(DE.index(i, DE.optional, e)))(item)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const array = <A>(item: Decoder<unknown, A>): Decoder<unknown, Array<A>> =>\n  pipe(UnknownArray, compose(fromArray(item)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromRecord = <I, A>(codomain: Decoder<I, A>): Decoder<Record<string, I>, Record<string, A>> =>\n  K.fromRecord(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(codomain)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const record = <A>(codomain: Decoder<unknown, A>): Decoder<unknown, Record<string, A>> =>\n  pipe(UnknownRecord, compose(fromRecord(codomain)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromTuple = <C extends ReadonlyArray<Decoder<any, any>>>(\n  ...components: C\n): Decoder<{ [K in keyof C]: InputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> =>\n  K.fromTuple(M)((i, e) => FS.of(DE.index(i, DE.required, e)))(...components) as any\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Decoder<unknown, A[K]> }\n): Decoder<unknown, A> => pipe(UnknownArray as any, compose(fromTuple(...components))) as any\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const union: <MS extends readonly [Decoder<any, any>, ...Array<Decoder<any, any>>]>(\n  ...members: MS\n) => Decoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =\n  /*#__PURE__*/\n  K.union(M)((i, e) => FS.of(DE.member(i, e)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const intersect: <IB, B>(right: Decoder<IB, B>) => <IA, A>(left: Decoder<IA, A>) => Decoder<IA & IB, A & B> =\n  /*#__PURE__*/\n  K.intersect(M)\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromSum =\n  <T extends string>(tag: T) =>\n  <MS extends Record<string, Decoder<any, any>>>(members: MS): Decoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =>\n    K.fromSum(M)((tag, value, keys) =>\n      FS.of(\n        DE.key(\n          tag,\n          DE.required,\n          error(value, keys.length === 0 ? 'never' : keys.map((k) => JSON.stringify(k)).join(' | '))\n        )\n      )\n    )(tag)(members)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const sum =\n  <T extends string>(tag: T) =>\n  <A>(members: { [K in keyof A]: Decoder<unknown, A[K] & Record<T, K>> }): Decoder<unknown, A[keyof A]> =>\n    pipe(UnknownRecord as any, compose(fromSum(tag)(members)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const lazy: <I, A>(id: string, f: () => Decoder<I, A>) => Decoder<I, A> =\n  /*#__PURE__*/\n  K.lazy(M)((id, e) => FS.of(DE.lazy(id, e)))\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const readonly: <I, A>(decoder: Decoder<I, A>) => Decoder<I, Readonly<A>> = identity\n\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n\nconst map_: Functor2<URI>['map'] = (fa, f) => pipe(fa, map(f))\n\nconst alt_: Alt2<URI>['alt'] = (me, that) => pipe(me, alt(that))\n\nconst compose_: Category2<URI>['compose'] = (ab, la) => pipe(la, compose(ab))\n\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n\n/**\n * @category Functor\n * @since 2.2.7\n */\nexport const map: <A, B>(f: (a: A) => B) => <I>(fa: Decoder<I, A>) => Decoder<I, B> =\n  /*#__PURE__*/\n  K.map(M)\n\n/**\n * @category Alt\n * @since 2.2.7\n */\nexport const alt: <I, A>(that: () => Decoder<I, A>) => (me: Decoder<I, A>) => Decoder<I, A> =\n  /*#__PURE__*/\n  K.alt(M)\n\n/**\n * @category Semigroupoid\n * @since 2.2.8\n */\nexport const compose: <A, B>(to: Decoder<A, B>) => <I>(from: Decoder<I, A>) => Decoder<I, B> =\n  /*#__PURE__*/\n  K.compose(M)\n\n/**\n * @category Category\n * @since 2.2.8\n */\nexport const id: <A>() => Decoder<A, A> =\n  /*#__PURE__*/\n  K.id(M)\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport const URI = 'io-ts/Decoder'\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind2<E, A> {\n    readonly [URI]: Decoder<E, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Functor: Functor2<URI> = {\n  URI,\n  map: map_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Alt: Alt2<URI> = {\n  URI,\n  map: map_,\n  alt: alt_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Category: Category2<URI> = {\n  URI,\n  compose: compose_,\n  id\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Schemable: S.Schemable2C<URI, unknown> = {\n  URI,\n  literal,\n  string,\n  number,\n  boolean,\n  nullable,\n  type,\n  struct,\n  partial,\n  record,\n  array,\n  tuple: tuple as S.Schemable2C<URI, unknown>['tuple'],\n  intersect,\n  sum,\n  lazy,\n  readonly\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnknownContainers: S.WithUnknownContainers2C<URI, unknown> = {\n  UnknownArray,\n  UnknownRecord\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnion: S.WithUnion2C<URI, unknown> = {\n  union: union as S.WithUnion2C<URI, unknown>['union']\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithRefine: S.WithRefine2C<URI, unknown> = {\n  refine: refine as S.WithRefine2C<URI, unknown>['refine']\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.8\n */\nexport type InputOf<D> = K.InputOf<E.URI, D>\n\n/**\n * @since 2.2.7\n */\nexport type TypeOf<D> = K.TypeOf<E.URI, D>\n\ninterface Tree<A> {\n  readonly value: A\n  readonly forest: ReadonlyArray<Tree<A>>\n}\n\nconst empty: Array<never> = []\n\nconst make = <A>(value: A, forest: ReadonlyArray<Tree<A>> = empty): Tree<A> => ({\n  value,\n  forest\n})\n\nconst drawTree = (tree: Tree<string>): string => tree.value + drawForest('\\n', tree.forest)\n\nconst drawForest = (indentation: string, forest: ReadonlyArray<Tree<string>>): string => {\n  let r = ''\n  const len = forest.length\n  let tree: Tree<string>\n  for (let i = 0; i < len; i++) {\n    tree = forest[i]\n    const isLast = i === len - 1\n    r += indentation + (isLast ? '\u2514' : '\u251c') + '\u2500 ' + tree.value\n    r += drawForest(indentation + (len > 1 && !isLast ? '\u2502  ' : '   '), tree.forest)\n  }\n  return r\n}\n\nconst toTree: (e: DE.DecodeError<string>) => Tree<string> = DE.fold({\n  Leaf: (input, error) => make(`cannot decode ${JSON.stringify(input)}, should be ${error}`),\n  Key: (key, kind, errors) => make(`${kind} property ${JSON.stringify(key)}`, toForest(errors)),\n  Index: (index, kind, errors) => make(`${kind} index ${index}`, toForest(errors)),\n  Member: (index, errors) => make(`member ${index}`, toForest(errors)),\n  Lazy: (id, errors) => make(`lazy type ${id}`, toForest(errors)),\n  Wrap: (error, errors) => make(error, toForest(errors))\n})\n\nconst toForest = (e: DecodeError): ReadonlyArray<Tree<string>> => {\n  const stack = []\n  let focus = e\n  const res = []\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    switch (focus._tag) {\n      case 'Of':\n        {\n          res.push(toTree(focus.value))\n          const tmp = stack.pop()\n          if (tmp === undefined) {\n            return res\n          } else {\n            focus = tmp\n          }\n        }\n        break\n      case 'Concat':\n        stack.push(focus.right)\n        focus = focus.left\n        break\n    }\n  }\n}\n\n/**\n * @since 2.2.7\n */\nexport const draw = (e: DecodeError): string => toForest(e).map(drawTree).join('\\n')\n\n/**\n * @internal\n */\nexport const stringify: <A>(e: E.Either<DecodeError, A>) => string =\n  /*#__PURE__*/\n  E.fold(draw, (a) => JSON.stringify(a, null, 2))\n\n### Source File Dependency Files Content\n### Dependency File: DecodeError.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Semigroup } from 'fp-ts/lib/Semigroup'\n\nimport * as FS from './FreeSemigroup'\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Leaf<E> {\n  readonly _tag: 'Leaf'\n  readonly actual: unknown\n  readonly error: E\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\n// eslint-disable-next-line @typescript-eslint/prefer-as-const\nexport const required: 'required' = 'required'\n\n/**\n * @category model\n * @since 2.2.7\n */\n// eslint-disable-next-line @typescript-eslint/prefer-as-const\nexport const optional: 'optional' = 'optional'\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport type Kind = 'required' | 'optional'\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Key<E> {\n  readonly _tag: 'Key'\n  readonly key: string\n  readonly kind: Kind\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Index<E> {\n  readonly _tag: 'Index'\n  readonly index: number\n  readonly kind: Kind\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Member<E> {\n  readonly _tag: 'Member'\n  readonly index: number\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Lazy<E> {\n  readonly _tag: 'Lazy'\n  readonly id: string\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.9\n */\nexport interface Wrap<E> {\n  readonly _tag: 'Wrap'\n  readonly error: E\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport type DecodeError<E> = Leaf<E> | Key<E> | Index<E> | Member<E> | Lazy<E> | Wrap<E>\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const leaf = <E>(actual: unknown, error: E): DecodeError<E> => ({ _tag: 'Leaf', actual, error })\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const key = <E>(key: string, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Key',\n  key,\n  kind,\n  errors\n})\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const index = <E>(index: number, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Index',\n  index,\n  kind,\n  errors\n})\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const member = <E>(index: number, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Member',\n  index,\n  errors\n})\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const lazy = <E>(id: string, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Lazy',\n  id,\n  errors\n})\n\n/**\n * @category constructors\n * @since 2.2.9\n */\nexport const wrap = <E>(error: E, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Wrap',\n  error,\n  errors\n})\n\n/**\n * @category destructors\n * @since 2.2.7\n */\nexport const fold = <E, R>(patterns: {\n  Leaf: (input: unknown, error: E) => R\n  Key: (key: string, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Index: (index: number, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Member: (index: number, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Lazy: (id: string, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Wrap: (error: E, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n}): ((e: DecodeError<E>) => R) => {\n  const f = (e: DecodeError<E>): R => {\n    switch (e._tag) {\n      case 'Leaf':\n        return patterns.Leaf(e.actual, e.error)\n      case 'Key':\n        return patterns.Key(e.key, e.kind, e.errors)\n      case 'Index':\n        return patterns.Index(e.index, e.kind, e.errors)\n      case 'Member':\n        return patterns.Member(e.index, e.errors)\n      case 'Lazy':\n        return patterns.Lazy(e.id, e.errors)\n      case 'Wrap':\n        return patterns.Wrap(e.error, e.errors)\n    }\n  }\n  return f\n}\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport function getSemigroup<E = never>(): Semigroup<FS.FreeSemigroup<DecodeError<E>>> {\n  return FS.getSemigroup()\n}\n\n\n### Dependency File: FreeSemigroup.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Semigroup } from 'fp-ts/lib/Semigroup'\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Of<A> {\n  readonly _tag: 'Of'\n  readonly value: A\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Concat<A> {\n  readonly _tag: 'Concat'\n  readonly left: FreeSemigroup<A>\n  readonly right: FreeSemigroup<A>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport type FreeSemigroup<A> = Of<A> | Concat<A>\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const of = <A>(a: A): FreeSemigroup<A> => ({ _tag: 'Of', value: a })\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const concat = <A>(left: FreeSemigroup<A>, right: FreeSemigroup<A>): FreeSemigroup<A> => ({\n  _tag: 'Concat',\n  left,\n  right\n})\n\n/**\n * @category destructors\n * @since 2.2.7\n */\nexport const fold =\n  <A, R>(onOf: (value: A) => R, onConcat: (left: FreeSemigroup<A>, right: FreeSemigroup<A>) => R) =>\n  (f: FreeSemigroup<A>): R => {\n    switch (f._tag) {\n      case 'Of':\n        return onOf(f.value)\n      case 'Concat':\n        return onConcat(f.left, f.right)\n    }\n  }\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport function getSemigroup<A = never>(): Semigroup<FreeSemigroup<A>> {\n  return { concat }\n}\n\n\n### Dependency File: Guard.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { identity, Refinement } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.8\n */\nexport interface Guard<I, A extends I> {\n  is: (i: I) => i is A\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.2\n */\nexport type TypeOf<G> = G extends Guard<any, infer A> ? A : never\n\n/**\n * @since 2.2.8\n */\nexport type InputOf<G> = G extends Guard<infer I, any> ? I : never\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.0\n */\nexport const literal = <A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n): Guard<unknown, A[number]> => ({\n  is: (u: unknown): u is A[number] => values.findIndex((a) => a === u) !== -1\n})\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const string: Guard<unknown, string> = {\n  is: (u: unknown): u is string => typeof u === 'string'\n}\n\n/**\n * Note: `NaN` is excluded.\n *\n * @category primitives\n * @since 2.2.0\n */\nexport const number: Guard<unknown, number> = {\n  is: (u: unknown): u is number => typeof u === 'number' && !isNaN(u)\n}\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const boolean: Guard<unknown, boolean> = {\n  is: (u: unknown): u is boolean => typeof u === 'boolean'\n}\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const UnknownArray: Guard<unknown, Array<unknown>> = {\n  is: Array.isArray\n}\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const UnknownRecord: Guard<unknown, Record<string, unknown>> = {\n  is: (u: unknown): u is Record<string, unknown> => u !== null && typeof u === 'object' && !Array.isArray(u)\n}\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const refine =\n  <I, A extends I, B extends A>(refinement: Refinement<A, B>) =>\n  (from: Guard<I, A>): Guard<I, B> => ({\n    is: (i: I): i is B => from.is(i) && refinement(i)\n  })\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const nullable = <I, A extends I>(or: Guard<I, A>): Guard<null | I, null | A> => ({\n  is: (i): i is null | A => i === null || or.is(i)\n})\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const struct = <A>(properties: { [K in keyof A]: Guard<unknown, A[K]> }): Guard<\n  unknown,\n  { [K in keyof A]: A[K] }\n> =>\n  pipe(\n    UnknownRecord,\n    refine(\n      (\n        r\n      ): r is {\n        [K in keyof A]: A[K]\n      } => {\n        for (const k in properties) {\n          if (!(k in r) || !properties[k].is(r[k])) {\n            return false\n          }\n        }\n        return true\n      }\n    )\n  )\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.0\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const partial = <A>(properties: { [K in keyof A]: Guard<unknown, A[K]> }): Guard<\n  unknown,\n  Partial<{ [K in keyof A]: A[K] }>\n> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is Partial<A> => {\n      for (const k in properties) {\n        const v = r[k]\n        if (v !== undefined && !properties[k].is(v)) {\n          return false\n        }\n      }\n      return true\n    })\n  )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const array = <A>(item: Guard<unknown, A>): Guard<unknown, Array<A>> =>\n  pipe(\n    UnknownArray,\n    refine((us): us is Array<A> => us.every(item.is))\n  )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const record = <A>(codomain: Guard<unknown, A>): Guard<unknown, Record<string, A>> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is Record<string, A> => {\n      for (const k in r) {\n        if (!codomain.is(r[k])) {\n          return false\n        }\n      }\n      return true\n    })\n  )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, A> => ({\n  is: (u): u is A => Array.isArray(u) && u.length === components.length && components.every((c, i) => c.is(u[i]))\n})\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const intersect =\n  <B>(right: Guard<unknown, B>) =>\n  <A>(left: Guard<unknown, A>): Guard<unknown, A & B> => ({\n    is: (u: unknown): u is A & B => left.is(u) && right.is(u)\n  })\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const union = <A extends readonly [unknown, ...Array<unknown>]>(\n  ...members: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, A[number]> => ({\n  is: (u: unknown): u is A | A[number] => members.some((m) => m.is(u))\n})\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const sum =\n  <T extends string>(tag: T) =>\n  <A>(members: { [K in keyof A]: Guard<unknown, A[K] & Record<T, K>> }): Guard<unknown, A[keyof A]> =>\n    pipe(\n      UnknownRecord,\n      refine((r): r is any => {\n        const v = r[tag] as keyof A\n        if (v in members) {\n          return members[v].is(r)\n        }\n        return false\n      })\n    )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const lazy = <A>(f: () => Guard<unknown, A>): Guard<unknown, A> => {\n  const get = S.memoize<void, Guard<unknown, A>>(f)\n  return {\n    is: (u: unknown): u is A => get().is(u)\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const readonly: <I, A extends I>(guard: Guard<I, A>) => Guard<I, Readonly<A>> = identity\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const alt =\n  <I, A extends I>(that: () => Guard<I, A>) =>\n  (me: Guard<I, A>): Guard<I, A> => ({\n    is: (i): i is A => me.is(i) || that().is(i)\n  })\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const zero = <I, A extends I>(): Guard<I, A> => ({\n  is: (_): _ is A => false\n})\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const compose =\n  <I, A extends I, B extends A>(to: Guard<A, B>) =>\n  (from: Guard<I, A>): Guard<I, B> => ({\n    is: (i): i is B => from.is(i) && to.is(i)\n  })\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const id = <A>(): Guard<A, A> => ({\n  is: (_): _ is A => true\n})\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.0\n */\nexport const URI = 'io-ts/Guard'\n\n/**\n * @category instances\n * @since 2.2.0\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind<A> {\n    readonly [URI]: Guard<unknown, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Schemable: S.Schemable1<URI> = {\n  URI,\n  literal,\n  string,\n  number,\n  boolean,\n  nullable,\n  type,\n  struct,\n  partial,\n  record,\n  array,\n  tuple: tuple as S.Schemable1<URI>['tuple'],\n  intersect,\n  sum,\n  lazy: (_, f) => lazy(f),\n  readonly\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnknownContainers: S.WithUnknownContainers1<URI> = {\n  UnknownArray,\n  UnknownRecord\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnion: S.WithUnion1<URI> = {\n  union: union as S.WithUnion1<URI>['union']\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithRefine: S.WithRefine1<URI> = {\n  refine: refine as S.WithRefine1<URI>['refine']\n}\n\n\n### Dependency File: Kleisli.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Alt2C } from 'fp-ts/lib/Alt'\nimport { Applicative2C } from 'fp-ts/lib/Applicative'\nimport { Apply2C } from 'fp-ts/lib/Apply'\nimport { Bifunctor2 } from 'fp-ts/lib/Bifunctor'\nimport * as E from 'fp-ts/lib/Either'\nimport { Lazy, Refinement } from 'fp-ts/lib/function'\nimport { Functor2C } from 'fp-ts/lib/Functor'\nimport { Kind2, URIS2 } from 'fp-ts/lib/HKT'\nimport { Monad2C } from 'fp-ts/lib/Monad'\nimport { MonadThrow2C } from 'fp-ts/lib/MonadThrow'\n\nimport * as G from './Guard'\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Kleisli<M extends URIS2, I, E, A> {\n  readonly decode: (i: I) => Kind2<M, E, A>\n}\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport function fromRefinement<M extends URIS2, E>(\n  M: MonadThrow2C<M, E>\n): <I, A extends I>(refinement: Refinement<I, A>, onError: (i: I) => E) => Kleisli<M, I, E, A> {\n  return (refinement, onError) => ({\n    decode: (i) => (refinement(i) ? M.of(i) : M.throwError(onError(i)))\n  })\n}\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport function literal<M extends URIS2, E>(\n  M: MonadThrow2C<M, E>\n): <I>(\n  onError: (i: I, values: readonly [S.Literal, ...ReadonlyArray<S.Literal>]) => E\n) => <A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n) => Kleisli<M, I, E, A[number]> {\n  return (onError) =>\n    <A extends readonly [S.Literal, ...Array<S.Literal>]>(...values: A) => ({\n      decode: (i) => (G.literal(...values).is(i) ? M.of<A[number]>(i) : M.throwError(onError(i, values)))\n    })\n}\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function mapLeftWithInput<M extends URIS2>(\n  M: Bifunctor2<M>\n): <I, E>(f: (i: I, e: E) => E) => <A>(decoder: Kleisli<M, I, E, A>) => Kleisli<M, I, E, A> {\n  return (f) => (decoder) => ({\n    decode: (i) => M.mapLeft(decoder.decode(i), (e) => f(i, e))\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function refine<M extends URIS2, E>(\n  M: MonadThrow2C<M, E> & Bifunctor2<M>\n): <A, B extends A>(\n  refinement: (a: A) => a is B,\n  onError: (a: A) => E\n) => <I>(from: Kleisli<M, I, E, A>) => Kleisli<M, I, E, B> {\n  return (refinement, onError) => (from) => compose(M)(fromRefinement(M)(refinement, onError))(from)\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function parse<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(decode: (a: A) => Kind2<M, E, B>) => <I>(from: Kleisli<M, I, E, A>) => Kleisli<M, I, E, B> {\n  return (decode) => (from) => compose(M)({ decode })(from)\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function nullable<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): <I>(onError: (i: I, e: E) => E) => <A>(or: Kleisli<M, I, E, A>) => Kleisli<M, null | I, E, null | A> {\n  return <I>(onError: (i: I, e: E) => E) =>\n    <A>(or: Kleisli<M, I, E, A>): Kleisli<M, null | I, E, null | A> => ({\n      decode: (i) =>\n        i === null\n          ? M.of<null | A>(null)\n          : M.bimap(\n              or.decode(i),\n              (e) => onError(i, e),\n              (a): A | null => a\n            )\n    })\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function fromStruct<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onPropertyError: (key: string, e: E) => E\n) => <P extends Record<string, Kleisli<M, any, E, any>>>(\n  properties: P\n) => Kleisli<M, { [K in keyof P]: InputOf<M, P[K]> }, E, { [K in keyof P]: TypeOf<M, P[K]> }> {\n  const traverse = traverseRecordWithIndex(M)\n  return (onPropertyError) => (properties) => ({\n    decode: (i) =>\n      traverse(properties as Record<string, Kleisli<M, unknown, E, unknown>>, (key, decoder) =>\n        M.mapLeft(decoder.decode(i[key]), (e) => onPropertyError(key, e))\n      ) as any\n  })\n}\n\n/**\n * Use `fromStruct` instead.\n *\n * @category combinators\n * @since 2.2.7\n * @deprecated\n */\nexport const fromType = fromStruct\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromPartial<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onPropertyError: (key: string, e: E) => E\n) => <P extends Record<string, Kleisli<M, any, E, any>>>(\n  properties: P\n) => Kleisli<M, Partial<{ [K in keyof P]: InputOf<M, P[K]> }>, E, Partial<{ [K in keyof P]: TypeOf<M, P[K]> }>> {\n  const traverse = traverseRecordWithIndex(M)\n  const undefinedProperty = M.of<E.Either<void, unknown>>(E.right(undefined))\n  const skipProperty = M.of<E.Either<void, unknown>>(E.left(undefined))\n  return (onPropertyError) => (properties) => ({\n    decode: (i) =>\n      M.map(\n        traverse(properties as Record<string, Kleisli<M, unknown, E, unknown>>, (key, decoder) => {\n          const ikey = i[key]\n          if (ikey === undefined) {\n            return key in i\n              ? // don't strip undefined properties\n                undefinedProperty\n              : // don't add missing properties\n                skipProperty\n          }\n          return M.bimap(\n            decoder.decode(ikey),\n            (e) => onPropertyError(key, e),\n            (a) => E.right<void, unknown>(a)\n          )\n        }),\n        compactRecord\n      ) as any\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromArray<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (onItemError: (index: number, e: E) => E) => <I, A>(item: Kleisli<M, I, E, A>) => Kleisli<M, Array<I>, E, Array<A>> {\n  const traverse = traverseArrayWithIndex(M)\n  return (onItemError) => (item) => ({\n    decode: (is) => traverse(is, (index, i) => M.mapLeft(item.decode(i), (e) => onItemError(index, e)))\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromRecord<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onKeyError: (key: string, e: E) => E\n) => <I, A>(codomain: Kleisli<M, I, E, A>) => Kleisli<M, Record<string, I>, E, Record<string, A>> {\n  const traverse = traverseRecordWithIndex(M)\n  return (onKeyError) => (codomain) => ({\n    decode: (ir) => traverse(ir, (key, i) => M.mapLeft(codomain.decode(i), (e) => onKeyError(key, e)))\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromTuple<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onIndexError: (index: number, e: E) => E\n) => <C extends ReadonlyArray<Kleisli<M, any, E, any>>>(\n  ...components: C\n) => Kleisli<M, { [K in keyof C]: InputOf<M, C[K]> }, E, { [K in keyof C]: TypeOf<M, C[K]> }> {\n  const traverse = traverseArrayWithIndex(M)\n  return (onIndexError) =>\n    (...components) => ({\n      decode: (is) =>\n        traverse(components as unknown as Array<Kleisli<M, unknown, E, unknown>>, (index, decoder) =>\n          M.mapLeft(decoder.decode(is[index]), (e) => onIndexError(index, e))\n        ) as any\n    })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function union<M extends URIS2, E>(\n  M: Alt2C<M, E> & Bifunctor2<M>\n): (\n  onMemberError: (index: number, e: E) => E\n) => <MS extends readonly [Kleisli<M, any, E, any>, ...Array<Kleisli<M, any, E, any>>]>(\n  ...members: MS\n) => Kleisli<M, InputOf<M, MS[keyof MS]>, E, TypeOf<M, MS[keyof MS]>> {\n  return (onMemberError) =>\n    <MS extends readonly [Kleisli<M, any, E, any>, ...Array<Kleisli<M, any, E, any>>]>(...members: MS) => ({\n      decode: (i) => {\n        let out: Kind2<M, E, TypeOf<M, MS[keyof MS]>> = M.mapLeft(members[0].decode(i), (e) => onMemberError(0, e))\n        for (let index = 1; index < members.length; index++) {\n          out = M.alt(out, () => M.mapLeft(members[index].decode(i), (e) => onMemberError(index, e)))\n        }\n        return out\n      }\n    })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function intersect<M extends URIS2, E>(\n  M: Apply2C<M, E>\n): <IB, B>(right: Kleisli<M, IB, E, B>) => <IA, A>(left: Kleisli<M, IA, E, A>) => Kleisli<M, IA & IB, E, A & B> {\n  return <IB, B>(right: Kleisli<M, IB, E, B>) =>\n    <IA, A>(left: Kleisli<M, IA, E, A>): Kleisli<M, IA & IB, E, A & B> => ({\n      decode: (i) =>\n        M.ap(\n          M.map(left.decode(i), (a: A) => (b: B) => S.intersect_(a, b)),\n          right.decode(i)\n        )\n    })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromSum<M extends URIS2, E>(\n  M: MonadThrow2C<M, E>\n): (\n  onTagError: (tag: string, value: unknown, tags: ReadonlyArray<string>) => E\n) => <T extends string>(\n  tag: T\n) => <MS extends Record<string, Kleisli<M, any, E, any>>>(\n  members: MS\n) => Kleisli<M, InputOf<M, MS[keyof MS]>, E, TypeOf<M, MS[keyof MS]>> {\n  return (onTagError) =>\n    (tag) =>\n    <I extends Record<string, unknown>, A>(members: { [K in keyof A]: Kleisli<M, I, E, A[K]> }): Kleisli<\n      M,\n      I,\n      E,\n      A[keyof A]\n    > => {\n      const keys = Object.keys(members)\n      return {\n        decode: (ir) => {\n          const v: any = ir[tag]\n          if (Object.prototype.hasOwnProperty.call(members, v)) {\n            return (members as any)[v].decode(ir)\n          }\n          return M.throwError(onTagError(tag, v, keys))\n        }\n      }\n    }\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function lazy<M extends URIS2>(\n  M: Bifunctor2<M>\n): <E>(onError: (id: string, e: E) => E) => <I, A>(id: string, f: () => Kleisli<M, I, E, A>) => Kleisli<M, I, E, A> {\n  return <E>(onError: (id: string, e: E) => E) =>\n    <I, A>(id: string, f: () => Kleisli<M, I, E, A>): Kleisli<M, I, E, A> => {\n      const get = S.memoize<void, Kleisli<M, I, E, A>>(f)\n      return {\n        decode: (u) => M.mapLeft(get().decode(u), (e) => onError(id, e))\n      }\n    }\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function compose<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(ab: Kleisli<M, A, E, B>) => <I>(ia: Kleisli<M, I, E, A>) => Kleisli<M, I, E, B> {\n  return (ab) => (ia) => ({\n    decode: (i) => M.chain(ia.decode(i), ab.decode)\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport function id<M extends URIS2, E>(M: Applicative2C<M, E>): <A>() => Kleisli<M, A, E, A> {\n  return () => ({\n    decode: M.of\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function map<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <A, B>(f: (a: A) => B) => <I>(ia: Kleisli<F, I, E, A>) => Kleisli<F, I, E, B> {\n  return (f) => (ia) => ({\n    decode: (i) => F.map(ia.decode(i), f)\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function alt<F extends URIS2, E>(\n  A: Alt2C<F, E>\n): <I, A>(that: Lazy<Kleisli<F, I, E, A>>) => (me: Kleisli<F, I, E, A>) => Kleisli<F, I, E, A> {\n  return (that) => (me) => ({\n    decode: (i) => A.alt(me.decode(i), () => that().decode(i))\n  })\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst traverseArrayWithIndex =\n  <M extends URIS2, E>(M: Applicative2C<M, E>) =>\n  <A, B>(as: Array<A>, f: (i: number, a: A) => Kind2<M, E, B>): Kind2<M, E, Array<B>> => {\n    return as.reduce(\n      (mbs, a, i) =>\n        M.ap(\n          M.map(mbs, (bs) => (b: B) => {\n            bs.push(b)\n            return bs\n          }),\n          f(i, a)\n        ),\n      M.of<Array<B>>([])\n    )\n  }\n\nconst traverseRecordWithIndex =\n  <M extends URIS2, E>(M: Applicative2C<M, E>) =>\n  <A, B>(r: Record<string, A>, f: (k: string, a: A) => Kind2<M, E, B>): Kind2<M, E, Record<string, B>> => {\n    const ks = Object.keys(r)\n    if (ks.length === 0) {\n      return M.of({})\n    }\n    let fr: Kind2<M, E, Record<string, B>> = M.of({})\n    for (const key of ks) {\n      fr = M.ap(\n        M.map(fr, (r) => (b: B) => {\n          r[key] = b\n          return r\n        }),\n        f(key, r[key])\n      )\n    }\n    return fr\n  }\n\nconst compactRecord = <A>(r: Record<string, E.Either<void, A>>): Record<string, A> => {\n  const out: Record<string, A> = {}\n  for (const k in r) {\n    const rk = r[k]\n    if (E.isRight(rk)) {\n      out[k] = rk.right\n    }\n  }\n  return out\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.7\n */\nexport type TypeOf<M extends URIS2, KD> = KD extends Kleisli<M, any, any, infer A> ? A : never\n\n/**\n * @since 2.2.7\n */\nexport type InputOf<M extends URIS2, KD> = KD extends Kleisli<M, infer I, any, any> ? I : never\n\n\n### Dependency File: Schemable.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { Refinement } from 'fp-ts/lib/function'\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\n/**\n * @since 2.2.0\n */\nexport type Literal = string | number | boolean | null\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable<S> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => HKT<S, A[number]>\n  readonly string: HKT<S, string>\n  readonly number: HKT<S, number>\n  readonly boolean: HKT<S, boolean>\n  readonly nullable: <A>(or: HKT<S, A>) => HKT<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: HKT<S, A>) => HKT<S, Record<string, A>>\n  readonly array: <A>(item: HKT<S, A>) => HKT<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, A>\n  readonly intersect: <B>(right: HKT<S, B>) => <A>(left: HKT<S, A>) => HKT<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: HKT<S, A[K] & Record<T, K>> }) => HKT<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => HKT<S, A>) => HKT<S, A>\n  readonly readonly: <A>(sa: HKT<S, A>) => HKT<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable1<S extends URIS> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind<S, A[number]>\n  readonly string: Kind<S, string>\n  readonly number: Kind<S, number>\n  readonly boolean: Kind<S, boolean>\n  readonly nullable: <A>(or: Kind<S, A>) => Kind<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: Kind<S, A>) => Kind<S, Record<string, A>>\n  readonly array: <A>(item: Kind<S, A>) => Kind<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, A>\n  readonly intersect: <B>(right: Kind<S, B>) => <A>(left: Kind<S, A>) => Kind<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind<S, A[K] & Record<T, K>> }) => Kind<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind<S, A>) => Kind<S, A>\n  readonly readonly: <A>(sa: Kind<S, A>) => Kind<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface Schemable2C<S extends URIS2, E> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind2<S, E, A[number]>\n  readonly string: Kind2<S, E, string>\n  readonly number: Kind2<S, E, number>\n  readonly boolean: Kind2<S, E, boolean>\n  readonly nullable: <A>(or: Kind2<S, E, A>) => Kind2<S, E, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<\n    S,\n    E,\n    Partial<{ [K in keyof A]: A[K] }>\n  >\n  readonly record: <A>(codomain: Kind2<S, E, A>) => Kind2<S, E, Record<string, A>>\n  readonly array: <A>(item: Kind2<S, E, A>) => Kind2<S, E, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(\n    ...components: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A>\n  readonly intersect: <B>(right: Kind2<S, E, B>) => <A>(left: Kind2<S, E, A>) => Kind2<S, E, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind2<S, E, A[K] & Record<T, K>> }) => Kind2<S, E, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind2<S, E, A>) => Kind2<S, E, A>\n  readonly readonly: <A>(sa: Kind2<S, E, A>) => Kind2<S, E, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers<S> {\n  readonly UnknownArray: HKT<S, Array<unknown>>\n  readonly UnknownRecord: HKT<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers1<S extends URIS> {\n  readonly UnknownArray: Kind<S, Array<unknown>>\n  readonly UnknownRecord: Kind<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnknownContainers2C<S extends URIS2, E> {\n  readonly UnknownArray: Kind2<S, E, Array<unknown>>\n  readonly UnknownRecord: Kind2<S, E, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion<S> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: HKT<S, A[K]> }\n  ) => HKT<S, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion1<S extends URIS> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind<S, A[K]> }\n  ) => Kind<S, A[number]>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnion2C<S extends URIS2, E> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine<S> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: HKT<S, A>) => HKT<S, B>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine1<S extends URIS> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Kind<S, A>) => Kind<S, B>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithRefine2C<S extends URIS2, E> {\n  readonly refine: <A, B extends A>(\n    refinement: Refinement<A, B>,\n    id: string\n  ) => (from: Kind2<S, E, A>) => Kind2<S, E, B>\n}\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst typeOf = (x: unknown): string => (x === null ? 'null' : typeof x)\n\n/**\n * @internal\n */\nexport const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport * as assert from 'assert'\nimport * as E from 'fp-ts/lib/Either'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as DE from '../src/DecodeError'\nimport * as _ from '../src/Decoder'\nimport * as FS from '../src/FreeSemigroup'\nimport * as H from './helpers'\n\ndescribe.concurrent('Decoder', () => {\n  // -------------------------------------------------------------------------------------\n  // instances\n  // -------------------------------------------------------------------------------------\n\n  it('Functor', () => {\n    const decoder = _.Functor.map(_.string, (s) => s + '!')\n    assert.deepStrictEqual(decoder.decode('a'), _.success('a!'))\n  })\n\n  it('Alt', () => {\n    const decoder = _.Alt.alt<unknown, string | number>(_.string, () => _.number)\n    assert.deepStrictEqual(decoder.decode('a'), _.success('a'))\n    assert.deepStrictEqual(decoder.decode(1), _.success(1))\n  })\n\n  it('Category', () => {\n    const decoder = _.Category.compose(_.id<unknown>(), _.string)\n    assert.deepStrictEqual(decoder.decode('a'), _.success('a'))\n    assert.deepStrictEqual(decoder.decode(1), _.failure(1, 'string'))\n  })\n\n  // -------------------------------------------------------------------------------------\n  // primitives\n  // -------------------------------------------------------------------------------------\n\n  it('string', async () => {\n    assert.deepStrictEqual(_.string.decode('a'), _.success('a'))\n    assert.deepStrictEqual(_.string.decode(null), E.left(FS.of(DE.leaf(null, 'string'))))\n  })\n\n  describe.concurrent('number', () => {\n    it('number', async () => {\n      assert.deepStrictEqual(_.number.decode(1), _.success(1))\n      assert.deepStrictEqual(_.number.decode(null), E.left(FS.of(DE.leaf(null, 'number'))))\n    })\n\n    it('should exclude NaN', () => {\n      assert.deepStrictEqual(_.number.decode(NaN), E.left(FS.of(DE.leaf(NaN, 'number'))))\n    })\n  })\n\n  it('boolean', async () => {\n    assert.deepStrictEqual(_.boolean.decode(true), _.success(true))\n    assert.deepStrictEqual(_.boolean.decode(null), E.left(FS.of(DE.leaf(null, 'boolean'))))\n  })\n\n  it('UnknownArray', async () => {\n    assert.deepStrictEqual(_.UnknownArray.decode([1, 'a']), _.success([1, 'a']))\n    assert.deepStrictEqual(_.UnknownArray.decode(null), E.left(FS.of(DE.leaf(null, 'Array<unknown>'))))\n  })\n\n  it('UnknownRecord', async () => {\n    assert.deepStrictEqual(_.UnknownRecord.decode({ a: 1, b: 'b' }), _.success({ a: 1, b: 'b' }))\n    assert.deepStrictEqual(_.UnknownRecord.decode(null), E.left(FS.of(DE.leaf(null, 'Record<string, unknown>'))))\n  })\n\n  // -------------------------------------------------------------------------------------\n  // constructors\n  // -------------------------------------------------------------------------------------\n\n  describe.concurrent('literal', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.literal('a', null, 'b', 1, true)\n      assert.deepStrictEqual(decoder.decode('a'), _.success('a'))\n      assert.deepStrictEqual(decoder.decode(null), _.success(null))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.literal('a', null)\n      assert.deepStrictEqual(decoder.decode('b'), E.left(FS.of(DE.leaf('b', '\"a\" | null'))))\n    })\n  })\n\n  // -------------------------------------------------------------------------------------\n  // combinators\n  // -------------------------------------------------------------------------------------\n\n  it('mapLeftWithInput', () => {\n    const decoder = pipe(\n      _.number,\n      _.mapLeftWithInput((u) => FS.of(DE.leaf(u, 'not a number')))\n    )\n    assert.deepStrictEqual(decoder.decode('a'), E.left(FS.of(DE.leaf('a', 'not a number'))))\n  })\n\n  it('withMessage', () => {\n    const decoder = pipe(\n      _.struct({\n        name: _.string,\n        age: _.number\n      }),\n      _.withMessage(() => 'Person')\n    )\n    assert.deepStrictEqual(\n      pipe(decoder.decode({}), E.mapLeft(_.draw)),\n      E.left(`Person\n\u251c\u2500 required property \"name\"\n\u2502  \u2514\u2500 cannot decode undefined, should be string\n\u2514\u2500 required property \"age\"\n   \u2514\u2500 cannot decode undefined, should be number`)\n    )\n  })\n\n  it('compose', () => {\n    interface IntBrand {\n      readonly Int: unique symbol\n    }\n\n    type Int = number & IntBrand\n\n    const decoder = pipe(_.number, _.compose(_.fromRefinement((n): n is Int => Number.isInteger(n), 'IntFromNumber')))\n    assert.deepStrictEqual(decoder.decode(1), _.success(1))\n    assert.deepStrictEqual(decoder.decode('a'), _.failure('a', 'number'))\n    assert.deepStrictEqual(decoder.decode(1.2), _.failure(1.2, 'IntFromNumber'))\n  })\n\n  describe.concurrent('nullable', () => {\n    it('should decode a valid input', () => {\n      const decoder = _.nullable(H.decoderNumberFromUnknownString)\n      assert.deepStrictEqual(decoder.decode(null), _.success(null))\n      assert.deepStrictEqual(decoder.decode('1'), _.success(1))\n    })\n\n    it('should reject an invalid input', () => {\n      const decoder = _.nullable(H.decoderNumberFromUnknownString)\n      assert.deepStrictEqual(\n        decoder.decode(undefined),\n        E.left(\n          FS.concat(\n            FS.of(DE.member(0, FS.of(DE.leaf(undefined, 'null')))),\n            FS.of(DE.member(1, FS.of(DE.leaf(undefined, 'string'))))\n          )\n        )\n      )\n      assert.deepStrictEqual(\n        decoder.decode('a'),\n        E.left(\n          FS.concat(\n            FS.of(DE.member(0, FS.of(DE.leaf('a', 'null')))),\n            FS.of(DE.member(1, FS.of(DE.leaf('a', 'parsable to a number'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('struct', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.struct({\n        a: _.string\n      })\n      assert.deepStrictEqual(decoder.decode({ a: 'a' }), _.success({ a: 'a' }))\n    })\n\n    it('should strip additional fields', async () => {\n      const decoder = _.struct({\n        a: _.string\n      })\n      assert.deepStrictEqual(decoder.decode({ a: 'a', b: 1 }), _.success({ a: 'a' }))\n    })\n\n    it('should not strip fields corresponding to undefined values', async () => {\n      const decoder = _.struct({\n        a: H.decoderUndefined\n      })\n      assert.deepStrictEqual(decoder.decode({}), _.success({ a: undefined }))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.struct({\n        a: _.string\n      })\n      assert.deepStrictEqual(decoder.decode(undefined), E.left(FS.of(DE.leaf(undefined, 'Record<string, unknown>'))))\n      assert.deepStrictEqual(\n        decoder.decode({ a: 1 }),\n        E.left(FS.of(DE.key('a', DE.required, FS.of(DE.leaf(1, 'string')))))\n      )\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.struct({\n        a: _.string,\n        b: _.number\n      })\n      assert.deepStrictEqual(\n        decoder.decode({}),\n        E.left(\n          FS.concat(\n            FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string')))),\n            FS.of(DE.key('b', DE.required, FS.of(DE.leaf(undefined, 'number'))))\n          )\n        )\n      )\n    })\n\n    it('should support getters', async () => {\n      class A {\n        get a() {\n          return 'a'\n        }\n        get b() {\n          return 'b'\n        }\n      }\n      const decoder = _.struct({ a: _.string, b: _.string })\n      assert.deepStrictEqual(decoder.decode(new A()), _.success({ a: 'a', b: 'b' }))\n    })\n  })\n\n  describe.concurrent('partial', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(decoder.decode({ a: 'a' }), _.success({ a: 'a' }))\n      assert.deepStrictEqual(decoder.decode({}), _.success({}))\n    })\n\n    it('should strip additional fields', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(decoder.decode({ a: 'a', b: 1 }), _.success({ a: 'a' }))\n    })\n\n    it('should not add missing fields', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(decoder.decode({}), _.success({}))\n    })\n\n    it('should not strip fields corresponding to undefined values', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(decoder.decode({ a: undefined }), _.success({ a: undefined }))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(decoder.decode(undefined), E.left(FS.of(DE.leaf(undefined, 'Record<string, unknown>'))))\n      assert.deepStrictEqual(\n        decoder.decode({ a: 1 }),\n        E.left(FS.of(DE.key('a', DE.optional, FS.of(DE.leaf(1, 'string')))))\n      )\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.partial({\n        a: _.string,\n        b: _.number\n      })\n      assert.deepStrictEqual(\n        decoder.decode({ a: 1, b: 'b' }),\n        E.left(\n          FS.concat(\n            FS.of(DE.key('a', DE.optional, FS.of(DE.leaf(1, 'string')))),\n            FS.of(DE.key('b', DE.optional, FS.of(DE.leaf('b', 'number'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('array', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.array(_.string)\n      assert.deepStrictEqual(decoder.decode([]), _.success([]))\n      assert.deepStrictEqual(decoder.decode(['a']), _.success(['a']))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.array(_.string)\n      assert.deepStrictEqual(decoder.decode(undefined), E.left(FS.of(DE.leaf(undefined, 'Array<unknown>'))))\n      assert.deepStrictEqual(decoder.decode([1]), E.left(FS.of(DE.index(0, DE.optional, FS.of(DE.leaf(1, 'string'))))))\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.array(_.string)\n      assert.deepStrictEqual(\n        decoder.decode([1, 2]),\n        E.left(\n          FS.concat(\n            FS.of(DE.index(0, DE.optional, FS.of(DE.leaf(1, 'string')))),\n            FS.of(DE.index(1, DE.optional, FS.of(DE.leaf(2, 'string'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('record', () => {\n    it('should decode a valid value', async () => {\n      const decoder = _.record(_.number)\n      assert.deepStrictEqual(decoder.decode({}), _.success({}))\n      assert.deepStrictEqual(decoder.decode({ a: 1 }), _.success({ a: 1 }))\n    })\n\n    it('should reject an invalid value', async () => {\n      const decoder = _.record(_.number)\n      assert.deepStrictEqual(decoder.decode(undefined), E.left(FS.of(DE.leaf(undefined, 'Record<string, unknown>'))))\n      assert.deepStrictEqual(\n        decoder.decode({ a: 'a' }),\n        E.left(FS.of(DE.key('a', DE.optional, FS.of(DE.leaf('a', 'number')))))\n      )\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.record(_.number)\n      assert.deepStrictEqual(\n        decoder.decode({ a: 'a', b: 'b' }),\n        E.left(\n          FS.concat(\n            FS.of(DE.key('a', DE.optional, FS.of(DE.leaf('a', 'number')))),\n            FS.of(DE.key('b', DE.optional, FS.of(DE.leaf('b', 'number'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('tuple', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.tuple(_.string, _.number)\n      assert.deepStrictEqual(decoder.decode(['a', 1]), _.success(['a', 1]))\n    })\n\n    it('should handle zero components', async () => {\n      assert.deepStrictEqual(_.tuple().decode([]), _.success([]))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.tuple(_.string, _.number)\n      assert.deepStrictEqual(decoder.decode(undefined), E.left(FS.of(DE.leaf(undefined, 'Array<unknown>'))))\n      assert.deepStrictEqual(\n        decoder.decode(['a']),\n        E.left(FS.of(DE.index(1, DE.required, FS.of(DE.leaf(undefined, 'number')))))\n      )\n      assert.deepStrictEqual(\n        decoder.decode([1, 2]),\n        E.left(FS.of(DE.index(0, DE.required, FS.of(DE.leaf(1, 'string')))))\n      )\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.tuple(_.string, _.number)\n      assert.deepStrictEqual(\n        decoder.decode([1, 'a']),\n        E.left(\n          FS.concat(\n            FS.of(DE.index(0, DE.required, FS.of(DE.leaf(1, 'string')))),\n            FS.of(DE.index(1, DE.required, FS.of(DE.leaf('a', 'number'))))\n          )\n        )\n      )\n    })\n\n    it('should strip additional components', async () => {\n      const decoder = _.tuple(_.string, _.number)\n      assert.deepStrictEqual(decoder.decode(['a', 1, true]), _.success(['a', 1]))\n    })\n  })\n\n  describe.concurrent('union', () => {\n    it('should decode a valid input', () => {\n      assert.deepStrictEqual(_.union(_.string).decode('a'), _.success('a'))\n      const decoder = _.union(_.string, _.number)\n      assert.deepStrictEqual(decoder.decode('a'), _.success('a'))\n      assert.deepStrictEqual(decoder.decode(1), _.success(1))\n    })\n\n    it('should reject an invalid input', () => {\n      const decoder = _.union(_.string, _.number)\n      assert.deepStrictEqual(\n        decoder.decode(true),\n        E.left(\n          FS.concat(\n            FS.of(DE.member(0, FS.of(DE.leaf(true, 'string')))),\n            FS.of(DE.member(1, FS.of(DE.leaf(true, 'number'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('refine', () => {\n    it('should decode a valid input', () => {\n      const decoder = pipe(\n        _.string,\n        _.refine((s): s is string => s.length > 0, 'NonEmptyString')\n      )\n      assert.deepStrictEqual(decoder.decode('a'), _.success('a'))\n    })\n\n    it('should reject an invalid input', () => {\n      const decoder = pipe(\n        _.string,\n        _.refine((s): s is string => s.length > 0, 'NonEmptyString')\n      )\n      assert.deepStrictEqual(decoder.decode(undefined), E.left(FS.of(DE.leaf(undefined, 'string'))))\n      assert.deepStrictEqual(decoder.decode(''), E.left(FS.of(DE.leaf('', 'NonEmptyString'))))\n    })\n  })\n\n  describe.concurrent('intersect', () => {\n    it('should decode a valid input', () => {\n      const decoder = pipe(_.struct({ a: _.string }), _.intersect(_.struct({ b: _.number })))\n      assert.deepStrictEqual(decoder.decode({ a: 'a', b: 1 }), _.success({ a: 'a', b: 1 }))\n    })\n\n    it('should handle primitives', () => {\n      const decoder = pipe(H.decoderInt, _.intersect(H.decoderPositive))\n      assert.deepStrictEqual(decoder.decode(1), _.success(1))\n    })\n\n    it('should accumulate all errors', () => {\n      const decoder = pipe(_.struct({ a: _.string }), _.intersect(_.struct({ b: _.number })))\n      assert.deepStrictEqual(\n        decoder.decode({ a: 'a' }),\n        E.left(FS.of(DE.key('b', DE.required, FS.of(DE.leaf(undefined, 'number')))))\n      )\n      assert.deepStrictEqual(\n        decoder.decode({ b: 1 }),\n        E.left(FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string')))))\n      )\n      assert.deepStrictEqual(\n        decoder.decode({}),\n        E.left(\n          FS.concat(\n            FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string')))),\n            FS.of(DE.key('b', DE.required, FS.of(DE.leaf(undefined, 'number'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('sum', () => {\n    const sum = _.sum('_tag')\n\n    it('should decode a valid input', () => {\n      const A = _.struct({ _tag: _.literal('A'), a: _.string })\n      const B = _.struct({ _tag: _.literal('B'), b: _.number })\n      const decoder = sum({ A, B })\n      assert.deepStrictEqual(decoder.decode({ _tag: 'A', a: 'a' }), _.success({ _tag: 'A', a: 'a' }))\n      assert.deepStrictEqual(decoder.decode({ _tag: 'B', b: 1 }), _.success({ _tag: 'B', b: 1 }))\n    })\n\n    it('should reject an invalid input', () => {\n      const A = _.struct({ _tag: _.literal('A'), a: _.string })\n      const B = _.struct({ _tag: _.literal('B'), b: _.number })\n      const decoder = sum({ A, B })\n      assert.deepStrictEqual(decoder.decode(null), E.left(FS.of(DE.leaf(null, 'Record<string, unknown>'))))\n      assert.deepStrictEqual(\n        decoder.decode({}),\n        E.left(FS.of(DE.key('_tag', DE.required, FS.of(DE.leaf(undefined, '\"A\" | \"B\"')))))\n      )\n      assert.deepStrictEqual(\n        decoder.decode({ _tag: 'A', a: 1 }),\n        E.left(FS.of(DE.key('a', DE.required, FS.of(DE.leaf(1, 'string')))))\n      )\n      assert.deepStrictEqual(\n        decoder.decode({ _tag: 'toString', a: 1 }),\n        E.left(FS.of(DE.key('_tag', DE.required, FS.of(DE.leaf('toString', '\"A\" | \"B\"')))))\n      )\n    })\n\n    it('should support empty records', () => {\n      const decoder = sum({})\n      assert.deepStrictEqual(\n        decoder.decode({}),\n        E.left(FS.of(DE.key('_tag', DE.required, FS.of(DE.leaf(undefined, 'never')))))\n      )\n    })\n\n    it('should support non-`string` tag values', () => {\n      const decoder = _.sum('_tag')({\n        [1]: _.struct({ _tag: _.literal(1), a: _.string }),\n        [2]: _.struct({ _tag: _.literal(2), b: _.number })\n      })\n      assert.deepStrictEqual(decoder.decode({ _tag: 1, a: 'a' }), E.right({ _tag: 1, a: 'a' }))\n      assert.deepStrictEqual(decoder.decode({ _tag: 2, b: 1 }), E.right({ _tag: 2, b: 1 }))\n      assert.deepStrictEqual(\n        decoder.decode({ _tag: 2, b: 'a' }),\n        E.left(FS.of(DE.key('b', DE.required, FS.of(DE.leaf('a', 'number')))))\n      )\n    })\n  })\n\n  interface A {\n    a: number\n    b?: A\n  }\n\n  const lazyDecoder: _.Decoder<unknown, A> = _.lazy('A', () =>\n    pipe(_.struct({ a: H.decoderNumberFromUnknownString }), _.intersect(_.partial({ b: lazyDecoder })))\n  )\n\n  describe.concurrent('lazy', () => {\n    it('should decode a valid input', () => {\n      assert.deepStrictEqual(lazyDecoder.decode({ a: '1' }), _.success({ a: 1 }))\n      assert.deepStrictEqual(lazyDecoder.decode({ a: '1', b: { a: '2' } }), _.success({ a: 1, b: { a: 2 } }))\n    })\n\n    it('should reject an invalid input', () => {\n      assert.deepStrictEqual(\n        lazyDecoder.decode({ a: 1 }),\n        E.left(FS.of(DE.lazy('A', FS.of(DE.key('a', DE.required, FS.of(DE.leaf(1, 'string')))))))\n      )\n      assert.deepStrictEqual(\n        lazyDecoder.decode({ a: 'a' }),\n        E.left(FS.of(DE.lazy('A', FS.of(DE.key('a', DE.required, FS.of(DE.leaf('a', 'parsable to a number')))))))\n      )\n      assert.deepStrictEqual(\n        lazyDecoder.decode({ a: '1', b: {} }),\n        E.left(\n          FS.of(\n            DE.lazy(\n              'A',\n              FS.of(\n                DE.key(\n                  'b',\n                  DE.optional,\n                  FS.of(DE.lazy('A', FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string'))))))\n                )\n              )\n            )\n          )\n        )\n      )\n    })\n  })\n\n  // -------------------------------------------------------------------------------------\n  // utils\n  // -------------------------------------------------------------------------------------\n\n  describe.concurrent('draw', () => {\n    it('is stack safe', () => {\n      expect(() => {\n        E.mapLeft(_.draw)(\n          _.record(_.struct({ done: _.boolean })).decode(\n            new Array(10000)\n              .fill({})\n              .map((v, k) => [k, v])\n              .reduce((acc, [k, v]) => {\n                acc[k] = v\n                return acc\n              }, {} as Record<string, unknown>)\n          )\n        )\n      }).not.toThrow()\n    })\n\n    it('draw', () => {\n      const decoder = _.struct({\n        a: _.string,\n        b: _.number,\n        c: _.array(_.boolean),\n        d: _.nullable(_.string)\n      })\n      assert.deepStrictEqual(\n        pipe(decoder.decode({ c: [1] }), E.mapLeft(_.draw)),\n        E.left(`required property \"a\"\n\u2514\u2500 cannot decode undefined, should be string\nrequired property \"b\"\n\u2514\u2500 cannot decode undefined, should be number\nrequired property \"c\"\n\u2514\u2500 optional index 0\n   \u2514\u2500 cannot decode 1, should be boolean\nrequired property \"d\"\n\u251c\u2500 member 0\n\u2502  \u2514\u2500 cannot decode undefined, should be null\n\u2514\u2500 member 1\n   \u2514\u2500 cannot decode undefined, should be string`)\n      )\n    })\n\n    it('should support lazy combinators', () => {\n      assert.deepStrictEqual(\n        pipe(lazyDecoder.decode({ a: '1', b: {} }), E.mapLeft(_.draw)),\n        E.left(`lazy type A\n\u2514\u2500 optional property \"b\"\n   \u2514\u2500 lazy type A\n      \u2514\u2500 required property \"a\"\n         \u2514\u2500 cannot decode undefined, should be string`)\n      )\n    })\n  })\n\n  it('stringify', () => {\n    assert.deepStrictEqual(_.stringify(_.string.decode('a')), '\"a\"')\n    assert.deepStrictEqual(_.stringify(_.string.decode(null)), 'cannot decode null, should be string')\n  })\n\n  it('fromRefinement', () => {\n    const IntFromNumber = _.fromRefinement((n: number): n is H.Int => Number.isInteger(n), 'IntFromNumber')\n    assert.deepStrictEqual(IntFromNumber.decode(1), _.success(1))\n    assert.deepStrictEqual(IntFromNumber.decode(1.2), _.failure(1.2, 'IntFromNumber'))\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\Encoder.ts\\Encoder.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.3\n */\nimport { Category2 } from 'fp-ts/lib/Category'\nimport { Contravariant2 } from 'fp-ts/lib/Contravariant'\nimport { identity } from 'fp-ts/lib/function'\n\nimport { intersect_, memoize } from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.3\n */\nexport interface Encoder<O, A> {\n  readonly encode: (a: A) => O\n}\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function nullable<O, A>(or: Encoder<O, A>): Encoder<null | O, null | A> {\n  return {\n    encode: (a) => (a === null ? null : or.encode(a))\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function struct<P extends Record<string, Encoder<any, any>>>(\n  properties: P\n): Encoder<{ [K in keyof P]: OutputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> {\n  return {\n    encode: (a) => {\n      const o: Record<keyof P, any> = {} as any\n      for (const k in properties) {\n        o[k] = properties[k].encode(a[k])\n      }\n      return o\n    }\n  }\n}\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.3\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function partial<P extends Record<string, Encoder<any, any>>>(\n  properties: P\n): Encoder<Partial<{ [K in keyof P]: OutputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> {\n  return {\n    encode: (a) => {\n      const o: Record<keyof P, any> = {} as any\n      for (const k in properties) {\n        const v = a[k]\n        // don't add missing properties\n        if (k in a) {\n          // don't strip undefined properties\n          o[k] = v === undefined ? undefined : properties[k].encode(v)\n        }\n      }\n      return o\n    }\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function record<O, A>(codomain: Encoder<O, A>): Encoder<Record<string, O>, Record<string, A>> {\n  return {\n    encode: (r) => {\n      const o: Record<string, O> = {}\n      for (const k in r) {\n        o[k] = codomain.encode(r[k])\n      }\n      return o\n    }\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function array<O, A>(item: Encoder<O, A>): Encoder<Array<O>, Array<A>> {\n  return {\n    encode: (as) => as.map(item.encode)\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function tuple<C extends ReadonlyArray<Encoder<any, any>>>(\n  ...components: C\n): Encoder<{ [K in keyof C]: OutputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> {\n  return {\n    encode: (as) => components.map((c, i) => c.encode(as[i])) as any\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport const intersect =\n  <P, B>(right: Encoder<P, B>) =>\n  <O, A>(left: Encoder<O, A>): Encoder<O & P, A & B> => ({\n    encode: (ab) => intersect_(left.encode(ab), right.encode(ab))\n  })\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function sum<T extends string>(\n  tag: T\n): <MS extends Record<string, Encoder<any, any>>>(\n  members: MS\n) => Encoder<OutputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> {\n  return (members) => {\n    return {\n      encode: (a) => members[a[tag]].encode(a)\n    }\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function lazy<O, A>(f: () => Encoder<O, A>): Encoder<O, A> {\n  const get = memoize<void, Encoder<O, A>>(f)\n  return {\n    encode: (a) => get().encode(a)\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.16\n */\nexport const readonly: <O, A>(decoder: Encoder<O, A>) => Encoder<O, Readonly<A>> = identity\n\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n\nconst contramap_: <E, A, B>(ea: Encoder<E, A>, f: (b: B) => A) => Encoder<E, B> = (ea, f) => ({\n  encode: (b) => ea.encode(f(b))\n})\n\nconst compose_: <E, A, B>(ab: Encoder<A, B>, ea: Encoder<E, A>) => Encoder<E, B> = (ab, ea) => contramap_(ea, ab.encode)\n\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n\n/**\n * @category Contravariant\n * @since 2.2.3\n */\nexport const contramap: <A, B>(f: (b: B) => A) => <E>(fa: Encoder<E, A>) => Encoder<E, B> = (f) => (fa) =>\n  contramap_(fa, f)\n\n/**\n * @category Semigroupoid\n * @since 2.2.3\n */\nexport const compose: <E, A>(ea: Encoder<E, A>) => <B>(ab: Encoder<A, B>) => Encoder<E, B> = (ea) => (ab) =>\n  compose_(ab, ea)\n\n/**\n * @category Category\n * @since 2.2.3\n */\nexport function id<A>(): Encoder<A, A> {\n  return {\n    encode: identity\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.3\n */\nexport const URI = 'io-ts/Encoder'\n\n/**\n * @category instances\n * @since 2.2.3\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind2<E, A> {\n    readonly [URI]: Encoder<E, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Contravariant: Contravariant2<URI> = {\n  URI,\n  contramap: contramap_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Category: Category2<URI> = {\n  URI,\n  compose: compose_,\n  id\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport type TypeOf<E> = E extends Encoder<any, infer A> ? A : never\n\n/**\n * @since 2.2.3\n */\nexport type OutputOf<E> = E extends Encoder<infer O, any> ? O : never\n\n### Source File Dependency Files Content\n### Dependency File: Schemable.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { Refinement } from 'fp-ts/lib/function'\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\n/**\n * @since 2.2.0\n */\nexport type Literal = string | number | boolean | null\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable<S> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => HKT<S, A[number]>\n  readonly string: HKT<S, string>\n  readonly number: HKT<S, number>\n  readonly boolean: HKT<S, boolean>\n  readonly nullable: <A>(or: HKT<S, A>) => HKT<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: HKT<S, A>) => HKT<S, Record<string, A>>\n  readonly array: <A>(item: HKT<S, A>) => HKT<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, A>\n  readonly intersect: <B>(right: HKT<S, B>) => <A>(left: HKT<S, A>) => HKT<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: HKT<S, A[K] & Record<T, K>> }) => HKT<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => HKT<S, A>) => HKT<S, A>\n  readonly readonly: <A>(sa: HKT<S, A>) => HKT<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable1<S extends URIS> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind<S, A[number]>\n  readonly string: Kind<S, string>\n  readonly number: Kind<S, number>\n  readonly boolean: Kind<S, boolean>\n  readonly nullable: <A>(or: Kind<S, A>) => Kind<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: Kind<S, A>) => Kind<S, Record<string, A>>\n  readonly array: <A>(item: Kind<S, A>) => Kind<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, A>\n  readonly intersect: <B>(right: Kind<S, B>) => <A>(left: Kind<S, A>) => Kind<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind<S, A[K] & Record<T, K>> }) => Kind<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind<S, A>) => Kind<S, A>\n  readonly readonly: <A>(sa: Kind<S, A>) => Kind<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface Schemable2C<S extends URIS2, E> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind2<S, E, A[number]>\n  readonly string: Kind2<S, E, string>\n  readonly number: Kind2<S, E, number>\n  readonly boolean: Kind2<S, E, boolean>\n  readonly nullable: <A>(or: Kind2<S, E, A>) => Kind2<S, E, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<\n    S,\n    E,\n    Partial<{ [K in keyof A]: A[K] }>\n  >\n  readonly record: <A>(codomain: Kind2<S, E, A>) => Kind2<S, E, Record<string, A>>\n  readonly array: <A>(item: Kind2<S, E, A>) => Kind2<S, E, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(\n    ...components: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A>\n  readonly intersect: <B>(right: Kind2<S, E, B>) => <A>(left: Kind2<S, E, A>) => Kind2<S, E, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind2<S, E, A[K] & Record<T, K>> }) => Kind2<S, E, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind2<S, E, A>) => Kind2<S, E, A>\n  readonly readonly: <A>(sa: Kind2<S, E, A>) => Kind2<S, E, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers<S> {\n  readonly UnknownArray: HKT<S, Array<unknown>>\n  readonly UnknownRecord: HKT<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers1<S extends URIS> {\n  readonly UnknownArray: Kind<S, Array<unknown>>\n  readonly UnknownRecord: Kind<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnknownContainers2C<S extends URIS2, E> {\n  readonly UnknownArray: Kind2<S, E, Array<unknown>>\n  readonly UnknownRecord: Kind2<S, E, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion<S> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: HKT<S, A[K]> }\n  ) => HKT<S, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion1<S extends URIS> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind<S, A[K]> }\n  ) => Kind<S, A[number]>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnion2C<S extends URIS2, E> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine<S> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: HKT<S, A>) => HKT<S, B>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine1<S extends URIS> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Kind<S, A>) => Kind<S, B>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithRefine2C<S extends URIS2, E> {\n  readonly refine: <A, B extends A>(\n    refinement: Refinement<A, B>,\n    id: string\n  ) => (from: Kind2<S, E, A>) => Kind2<S, E, B>\n}\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst typeOf = (x: unknown): string => (x === null ? 'null' : typeof x)\n\n/**\n * @internal\n */\nexport const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport * as assert from 'assert'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as E from '../src/Encoder'\nimport * as H from './helpers'\n\ndescribe.concurrent('Encoder', () => {\n  it('contramap', () => {\n    const encoder = E.contramap((s: string) => s.length)(H.encoderNumberToString)\n    assert.deepStrictEqual(encoder.encode('aaa'), '3')\n  })\n\n  it('compose', () => {\n    const encoder = pipe(H.encoderBooleanToNumber, E.compose(H.encoderNumberToString))\n    assert.deepStrictEqual(encoder.encode(true), '1')\n  })\n\n  it('nullable', () => {\n    const encoder = E.nullable(H.encoderNumberToString)\n    assert.deepStrictEqual(encoder.encode(1), '1')\n    assert.deepStrictEqual(encoder.encode(null), null)\n  })\n\n  it('struct', () => {\n    const encoder = E.struct({ a: H.encoderNumberToString, b: H.encoderBooleanToNumber })\n    assert.deepStrictEqual(encoder.encode({ a: 1, b: true }), { a: '1', b: 1 })\n  })\n\n  it('partial', () => {\n    const encoder = E.partial({ a: H.encoderNumberToString, b: H.encoderBooleanToNumber })\n    assert.deepStrictEqual(encoder.encode({ a: 1, b: true }), { a: '1', b: 1 })\n    assert.deepStrictEqual(encoder.encode({ a: 1 }), { a: '1' })\n    assert.deepStrictEqual(encoder.encode({ a: 1, b: undefined }), { a: '1', b: undefined })\n    assert.deepStrictEqual(encoder.encode({ b: true }), { b: 1 })\n    assert.deepStrictEqual(encoder.encode({}), {})\n  })\n\n  it('record', () => {\n    const encoder = E.record(H.encoderNumberToString)\n    assert.deepStrictEqual(encoder.encode({ a: 1, b: 2 }), { a: '1', b: '2' })\n  })\n\n  it('array', () => {\n    const encoder = E.array(H.encoderNumberToString)\n    assert.deepStrictEqual(encoder.encode([1, 2]), ['1', '2'])\n  })\n\n  it('tuple', () => {\n    const encoder = E.tuple(H.encoderNumberToString, H.encoderBooleanToNumber)\n    assert.deepStrictEqual(encoder.encode([3, true]), ['3', 1])\n  })\n\n  it('intersect', () => {\n    const encoder = pipe(\n      E.struct({ a: H.encoderNumberToString }),\n      E.intersect(E.struct({ b: H.encoderBooleanToNumber }))\n    )\n    assert.deepStrictEqual(encoder.encode({ a: 1, b: true }), { a: '1', b: 1 })\n  })\n\n  it('sum', () => {\n    const S1 = E.struct({ _tag: E.id<'A'>(), a: H.encoderNumberToString })\n    const S2 = E.struct({ _tag: E.id<'B'>(), b: H.encoderBooleanToNumber })\n    const sum = E.sum('_tag')\n    const encoder = sum({ A: S1, B: S2 })\n    assert.deepStrictEqual(encoder.encode({ _tag: 'A', a: 1 }), { _tag: 'A', a: '1' })\n    assert.deepStrictEqual(encoder.encode({ _tag: 'B', b: true }), { _tag: 'B', b: 1 })\n  })\n\n  it('lazy', () => {\n    interface A {\n      a: number\n      bs: Array<B>\n    }\n    interface AOut {\n      a: string\n      bs: Array<BOut>\n    }\n    interface B {\n      b: boolean\n      as: Array<A>\n    }\n    interface BOut {\n      b: number\n      as: Array<AOut>\n    }\n    const A: E.Encoder<AOut, A> = E.lazy(() =>\n      E.struct({\n        a: H.encoderNumberToString,\n        bs: E.array(B)\n      })\n    )\n\n    const B: E.Encoder<BOut, B> = E.lazy(() =>\n      E.struct({\n        b: H.encoderBooleanToNumber,\n        as: E.array(A)\n      })\n    )\n    assert.deepStrictEqual(A.encode({ a: 1, bs: [] }), { a: '1', bs: [] })\n    assert.deepStrictEqual(A.encode({ a: 1, bs: [{ b: true, as: [] }] }), { a: '1', bs: [{ b: 1, as: [] }] })\n    assert.deepStrictEqual(A.encode({ a: 1, bs: [{ b: true, as: [{ a: 2, bs: [] }] }] }), {\n      a: '1',\n      bs: [{ b: 1, as: [{ a: '2', bs: [] }] }]\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\Eq.ts\\Eq.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.2\n */\nimport * as A from 'fp-ts/lib/Array'\nimport * as E from 'fp-ts/lib/Eq'\nimport { identity } from 'fp-ts/lib/function'\nimport * as R from 'fp-ts/lib/Record'\n\nimport { memoize, Schemable1, WithRefine1, WithUnknownContainers1 } from './Schemable'\nimport Eq = E.Eq\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport type URI = E.URI\n\n/**\n * @since 2.2.2\n */\nexport type TypeOf<E> = E extends Eq<infer A> ? A : never\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\n/**\n * @category primitives\n * @since 2.2.2\n */\nexport const string: Eq<string> = E.eqString\n\n/**\n * @category primitives\n * @since 2.2.2\n */\nexport const number: Eq<number> = E.eqNumber\n\n/**\n * @category primitives\n * @since 2.2.2\n */\nexport const boolean: Eq<boolean> = E.eqBoolean\n\n/**\n * @category primitives\n * @since 2.2.2\n */\nexport const UnknownArray: Eq<Array<unknown>> = E.fromEquals((x, y) => x.length === y.length)\n\n/**\n * @category primitives\n * @since 2.2.2\n */\nexport const UnknownRecord: Eq<Record<string, unknown>> = E.fromEquals((x, y) => {\n  for (const k in x) {\n    if (!(k in y)) {\n      return false\n    }\n  }\n  for (const k in y) {\n    if (!(k in x)) {\n      return false\n    }\n  }\n  return true\n})\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport function nullable<A>(or: Eq<A>): Eq<null | A> {\n  return {\n    equals: (x, y) => (x === null || y === null ? x === y : or.equals(x, y))\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const struct: <A>(eqs: { [K in keyof A]: Eq<A[K]> }) => Eq<{ [K in keyof A]: A[K] }> = E.getStructEq\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.2\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport function partial<A>(properties: { [K in keyof A]: Eq<A[K]> }): Eq<Partial<{ [K in keyof A]: A[K] }>> {\n  return {\n    equals: (x, y) => {\n      for (const k in properties) {\n        const xk = x[k]\n        const yk = y[k]\n        if (!(xk === undefined || yk === undefined ? xk === yk : properties[k].equals(xk as any, yk as any))) {\n          return false\n        }\n      }\n      return true\n    }\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport const record: <A>(codomain: Eq<A>) => Eq<Record<string, A>> = R.getEq\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport const array: <A>(eq: Eq<A>) => Eq<Array<A>> = A.getEq\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport const tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Eq<A[K]> }) => Eq<A> =\n  E.getTupleEq as any\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport const intersect =\n  <B>(right: Eq<B>) =>\n  <A>(left: Eq<A>): Eq<A & B> => ({\n    equals: (x, y) => left.equals(x, y) && right.equals(x, y)\n  })\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport function sum<T extends string>(\n  tag: T\n): <A>(members: { [K in keyof A]: Eq<A[K] & Record<T, K>> }) => Eq<A[keyof A]> {\n  return (members: Record<string, Eq<any>>) => {\n    return {\n      equals: (x: any, y: any) => {\n        const vx = x[tag]\n        const vy = y[tag]\n        if (vx !== vy) {\n          return false\n        }\n        return members[vx].equals(x, y)\n      }\n    }\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport function lazy<A>(f: () => Eq<A>): Eq<A> {\n  const get = memoize<void, Eq<A>>(f)\n  return {\n    equals: (x, y) => get().equals(x, y)\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const readonly: <A>(eq: Eq<A>) => Eq<Readonly<A>> = identity\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Schemable: Schemable1<E.URI> = {\n  URI: E.URI,\n  literal: () => E.eqStrict,\n  string,\n  number,\n  boolean,\n  nullable,\n  type,\n  struct,\n  partial,\n  record,\n  array,\n  tuple,\n  intersect,\n  sum,\n  lazy: (_, f) => lazy(f),\n  readonly\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnknownContainers: WithUnknownContainers1<E.URI> = {\n  UnknownArray,\n  UnknownRecord\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithRefine: WithRefine1<E.URI> = {\n  refine: () => (from) => from\n}\n\n### Source File Dependency Files Content\n### Dependency File: Schemable.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { Refinement } from 'fp-ts/lib/function'\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\n/**\n * @since 2.2.0\n */\nexport type Literal = string | number | boolean | null\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable<S> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => HKT<S, A[number]>\n  readonly string: HKT<S, string>\n  readonly number: HKT<S, number>\n  readonly boolean: HKT<S, boolean>\n  readonly nullable: <A>(or: HKT<S, A>) => HKT<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: HKT<S, A>) => HKT<S, Record<string, A>>\n  readonly array: <A>(item: HKT<S, A>) => HKT<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, A>\n  readonly intersect: <B>(right: HKT<S, B>) => <A>(left: HKT<S, A>) => HKT<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: HKT<S, A[K] & Record<T, K>> }) => HKT<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => HKT<S, A>) => HKT<S, A>\n  readonly readonly: <A>(sa: HKT<S, A>) => HKT<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable1<S extends URIS> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind<S, A[number]>\n  readonly string: Kind<S, string>\n  readonly number: Kind<S, number>\n  readonly boolean: Kind<S, boolean>\n  readonly nullable: <A>(or: Kind<S, A>) => Kind<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: Kind<S, A>) => Kind<S, Record<string, A>>\n  readonly array: <A>(item: Kind<S, A>) => Kind<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, A>\n  readonly intersect: <B>(right: Kind<S, B>) => <A>(left: Kind<S, A>) => Kind<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind<S, A[K] & Record<T, K>> }) => Kind<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind<S, A>) => Kind<S, A>\n  readonly readonly: <A>(sa: Kind<S, A>) => Kind<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface Schemable2C<S extends URIS2, E> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind2<S, E, A[number]>\n  readonly string: Kind2<S, E, string>\n  readonly number: Kind2<S, E, number>\n  readonly boolean: Kind2<S, E, boolean>\n  readonly nullable: <A>(or: Kind2<S, E, A>) => Kind2<S, E, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<\n    S,\n    E,\n    Partial<{ [K in keyof A]: A[K] }>\n  >\n  readonly record: <A>(codomain: Kind2<S, E, A>) => Kind2<S, E, Record<string, A>>\n  readonly array: <A>(item: Kind2<S, E, A>) => Kind2<S, E, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(\n    ...components: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A>\n  readonly intersect: <B>(right: Kind2<S, E, B>) => <A>(left: Kind2<S, E, A>) => Kind2<S, E, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind2<S, E, A[K] & Record<T, K>> }) => Kind2<S, E, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind2<S, E, A>) => Kind2<S, E, A>\n  readonly readonly: <A>(sa: Kind2<S, E, A>) => Kind2<S, E, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers<S> {\n  readonly UnknownArray: HKT<S, Array<unknown>>\n  readonly UnknownRecord: HKT<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers1<S extends URIS> {\n  readonly UnknownArray: Kind<S, Array<unknown>>\n  readonly UnknownRecord: Kind<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnknownContainers2C<S extends URIS2, E> {\n  readonly UnknownArray: Kind2<S, E, Array<unknown>>\n  readonly UnknownRecord: Kind2<S, E, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion<S> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: HKT<S, A[K]> }\n  ) => HKT<S, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion1<S extends URIS> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind<S, A[K]> }\n  ) => Kind<S, A[number]>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnion2C<S extends URIS2, E> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine<S> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: HKT<S, A>) => HKT<S, B>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine1<S extends URIS> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Kind<S, A>) => Kind<S, B>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithRefine2C<S extends URIS2, E> {\n  readonly refine: <A, B extends A>(\n    refinement: Refinement<A, B>,\n    id: string\n  ) => (from: Kind2<S, E, A>) => Kind2<S, E, B>\n}\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst typeOf = (x: unknown): string => (x === null ? 'null' : typeof x)\n\n/**\n * @internal\n */\nexport const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport * as assert from 'assert'\nimport { Eq } from 'fp-ts/lib/Eq'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as E from '../src/Eq'\n\ndescribe.concurrent('Eq', () => {\n  it('literal', () => {\n    const eq = E.Schemable.literal('a', null)\n    assert.deepStrictEqual(eq.equals('a', 'a'), true)\n    assert.deepStrictEqual(eq.equals(null, null), true)\n    assert.deepStrictEqual(eq.equals('a', null), false)\n  })\n\n  it('UnknownArray', () => {\n    const eq = E.UnknownArray\n    assert.deepStrictEqual(eq.equals(['a'], ['a']), true)\n    assert.deepStrictEqual(eq.equals(['a'], ['b']), true)\n    assert.deepStrictEqual(eq.equals(['a'], ['a', 'b']), false)\n  })\n\n  it('UnknownRecord', () => {\n    const eq = E.UnknownRecord\n    assert.deepStrictEqual(eq.equals({}, {}), true)\n    assert.deepStrictEqual(eq.equals({ a: 1 }, { a: 1 }), true)\n    assert.deepStrictEqual(eq.equals({ a: 1 }, { a: 2 }), true)\n    assert.deepStrictEqual(eq.equals({ a: 1 }, { a: 1, b: true }), false)\n    assert.deepStrictEqual(eq.equals({ a: 1, b: true }, { a: 1 }), false)\n  })\n\n  it('partial', () => {\n    const eq = E.partial({ a: E.number })\n    assert.deepStrictEqual(eq.equals({ a: 1 }, { a: 1 }), true)\n    assert.deepStrictEqual(eq.equals({ a: undefined }, { a: undefined }), true)\n    assert.deepStrictEqual(eq.equals({}, { a: undefined }), true)\n    assert.deepStrictEqual(eq.equals({}, {}), true)\n    assert.deepStrictEqual(eq.equals({ a: 1 }, {}), false)\n  })\n\n  it('tuple', () => {\n    const eq = E.tuple(E.string, E.number)\n    assert.deepStrictEqual(eq.equals(['a', 1], ['a', 1]), true)\n    assert.deepStrictEqual(eq.equals(['a', 1], ['b', 1]), false)\n    assert.deepStrictEqual(eq.equals(['a', 1], ['a', 2]), false)\n  })\n\n  it('intersect', () => {\n    const eq = pipe(E.struct({ a: E.string }), E.intersect(E.struct({ b: E.number })))\n    assert.deepStrictEqual(eq.equals({ a: 'a', b: 1 }, { a: 'a', b: 1 }), true)\n    assert.deepStrictEqual(eq.equals({ a: 'a', b: 1 }, { a: 'c', b: 1 }), false)\n    assert.deepStrictEqual(eq.equals({ a: 'a', b: 1 }, { a: 'a', b: 2 }), false)\n  })\n\n  it('lazy', () => {\n    interface A {\n      a: number\n      b: Array<A>\n    }\n\n    const eq: Eq<A> = E.Schemable.lazy('A', () =>\n      E.struct({\n        a: E.number,\n        b: E.array(eq)\n      })\n    )\n    assert.strictEqual(eq.equals({ a: 1, b: [] }, { a: 1, b: [] }), true)\n    assert.strictEqual(eq.equals({ a: 1, b: [{ a: 2, b: [] }] }, { a: 1, b: [{ a: 2, b: [] }] }), true)\n    assert.strictEqual(eq.equals({ a: 1, b: [] }, { a: 2, b: [] }), false)\n    assert.strictEqual(eq.equals({ a: 1, b: [{ a: 2, b: [] }] }, { a: 1, b: [{ a: 3, b: [] }] }), false)\n  })\n\n  it('sum', () => {\n    const sum = E.sum('_tag')\n    const eq = sum({\n      A: E.struct({ _tag: E.Schemable.literal('A'), a: E.string }),\n      B: E.struct({ _tag: E.Schemable.literal('B'), b: E.number })\n    })\n    assert.strictEqual(eq.equals({ _tag: 'A', a: 'a' }, { _tag: 'A', a: 'a' }), true)\n    assert.strictEqual(eq.equals({ _tag: 'B', b: 1 }, { _tag: 'B', b: 1 }), true)\n    assert.strictEqual(eq.equals({ _tag: 'A', a: 'a' }, { _tag: 'B', b: 1 }), false)\n    assert.strictEqual(eq.equals({ _tag: 'A', a: 'a' }, { _tag: 'A', a: 'b' }), false)\n    assert.strictEqual(eq.equals({ _tag: 'B', b: 1 }, { _tag: 'B', b: 2 }), false)\n  })\n\n  it('refine', () => {\n    interface NonEmptyStringBrand {\n      readonly NonEmptyString: unique symbol\n    }\n    type NonEmptyString = string & NonEmptyStringBrand\n    const eq = pipe(\n      E.string,\n      E.WithRefine.refine((s): s is NonEmptyString => s.length > 0, 'NonEmptyString')\n    )\n    const a: NonEmptyString = 'a' as any\n    const b: NonEmptyString = 'b' as any\n    assert.deepStrictEqual(eq.equals(a, a), true)\n    assert.deepStrictEqual(eq.equals(a, b), false)\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\FreeSemigroup.ts\\FreeSemigroup.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Semigroup } from 'fp-ts/lib/Semigroup'\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Of<A> {\n  readonly _tag: 'Of'\n  readonly value: A\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Concat<A> {\n  readonly _tag: 'Concat'\n  readonly left: FreeSemigroup<A>\n  readonly right: FreeSemigroup<A>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport type FreeSemigroup<A> = Of<A> | Concat<A>\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const of = <A>(a: A): FreeSemigroup<A> => ({ _tag: 'Of', value: a })\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const concat = <A>(left: FreeSemigroup<A>, right: FreeSemigroup<A>): FreeSemigroup<A> => ({\n  _tag: 'Concat',\n  left,\n  right\n})\n\n/**\n * @category destructors\n * @since 2.2.7\n */\nexport const fold =\n  <A, R>(onOf: (value: A) => R, onConcat: (left: FreeSemigroup<A>, right: FreeSemigroup<A>) => R) =>\n  (f: FreeSemigroup<A>): R => {\n    switch (f._tag) {\n      case 'Of':\n        return onOf(f.value)\n      case 'Concat':\n        return onConcat(f.left, f.right)\n    }\n  }\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport function getSemigroup<A = never>(): Semigroup<FreeSemigroup<A>> {\n  return { concat }\n}\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport * as FS from '../src/FreeSemigroup'\n\ndescribe.concurrent('FreeSemigroup', () => {\n  it('fold', () => {\n    const sum: (input: FS.FreeSemigroup<string>) => string = FS.fold(\n      (value) => value,\n      (left, right) => sum(left) + sum(right)\n    )\n\n    expect(sum(FS.of('1'))).toBe('1')\n    expect(sum(FS.concat(FS.of('1'), FS.of('2')))).toBe('12')\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\Guard.ts\\Guard.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { identity, Refinement } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.8\n */\nexport interface Guard<I, A extends I> {\n  is: (i: I) => i is A\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.2\n */\nexport type TypeOf<G> = G extends Guard<any, infer A> ? A : never\n\n/**\n * @since 2.2.8\n */\nexport type InputOf<G> = G extends Guard<infer I, any> ? I : never\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.0\n */\nexport const literal = <A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n): Guard<unknown, A[number]> => ({\n  is: (u: unknown): u is A[number] => values.findIndex((a) => a === u) !== -1\n})\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const string: Guard<unknown, string> = {\n  is: (u: unknown): u is string => typeof u === 'string'\n}\n\n/**\n * Note: `NaN` is excluded.\n *\n * @category primitives\n * @since 2.2.0\n */\nexport const number: Guard<unknown, number> = {\n  is: (u: unknown): u is number => typeof u === 'number' && !isNaN(u)\n}\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const boolean: Guard<unknown, boolean> = {\n  is: (u: unknown): u is boolean => typeof u === 'boolean'\n}\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const UnknownArray: Guard<unknown, Array<unknown>> = {\n  is: Array.isArray\n}\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const UnknownRecord: Guard<unknown, Record<string, unknown>> = {\n  is: (u: unknown): u is Record<string, unknown> => u !== null && typeof u === 'object' && !Array.isArray(u)\n}\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const refine =\n  <I, A extends I, B extends A>(refinement: Refinement<A, B>) =>\n  (from: Guard<I, A>): Guard<I, B> => ({\n    is: (i: I): i is B => from.is(i) && refinement(i)\n  })\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const nullable = <I, A extends I>(or: Guard<I, A>): Guard<null | I, null | A> => ({\n  is: (i): i is null | A => i === null || or.is(i)\n})\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const struct = <A>(properties: { [K in keyof A]: Guard<unknown, A[K]> }): Guard<\n  unknown,\n  { [K in keyof A]: A[K] }\n> =>\n  pipe(\n    UnknownRecord,\n    refine(\n      (\n        r\n      ): r is {\n        [K in keyof A]: A[K]\n      } => {\n        for (const k in properties) {\n          if (!(k in r) || !properties[k].is(r[k])) {\n            return false\n          }\n        }\n        return true\n      }\n    )\n  )\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.0\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const partial = <A>(properties: { [K in keyof A]: Guard<unknown, A[K]> }): Guard<\n  unknown,\n  Partial<{ [K in keyof A]: A[K] }>\n> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is Partial<A> => {\n      for (const k in properties) {\n        const v = r[k]\n        if (v !== undefined && !properties[k].is(v)) {\n          return false\n        }\n      }\n      return true\n    })\n  )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const array = <A>(item: Guard<unknown, A>): Guard<unknown, Array<A>> =>\n  pipe(\n    UnknownArray,\n    refine((us): us is Array<A> => us.every(item.is))\n  )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const record = <A>(codomain: Guard<unknown, A>): Guard<unknown, Record<string, A>> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is Record<string, A> => {\n      for (const k in r) {\n        if (!codomain.is(r[k])) {\n          return false\n        }\n      }\n      return true\n    })\n  )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, A> => ({\n  is: (u): u is A => Array.isArray(u) && u.length === components.length && components.every((c, i) => c.is(u[i]))\n})\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const intersect =\n  <B>(right: Guard<unknown, B>) =>\n  <A>(left: Guard<unknown, A>): Guard<unknown, A & B> => ({\n    is: (u: unknown): u is A & B => left.is(u) && right.is(u)\n  })\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const union = <A extends readonly [unknown, ...Array<unknown>]>(\n  ...members: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, A[number]> => ({\n  is: (u: unknown): u is A | A[number] => members.some((m) => m.is(u))\n})\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const sum =\n  <T extends string>(tag: T) =>\n  <A>(members: { [K in keyof A]: Guard<unknown, A[K] & Record<T, K>> }): Guard<unknown, A[keyof A]> =>\n    pipe(\n      UnknownRecord,\n      refine((r): r is any => {\n        const v = r[tag] as keyof A\n        if (v in members) {\n          return members[v].is(r)\n        }\n        return false\n      })\n    )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const lazy = <A>(f: () => Guard<unknown, A>): Guard<unknown, A> => {\n  const get = S.memoize<void, Guard<unknown, A>>(f)\n  return {\n    is: (u: unknown): u is A => get().is(u)\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const readonly: <I, A extends I>(guard: Guard<I, A>) => Guard<I, Readonly<A>> = identity\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const alt =\n  <I, A extends I>(that: () => Guard<I, A>) =>\n  (me: Guard<I, A>): Guard<I, A> => ({\n    is: (i): i is A => me.is(i) || that().is(i)\n  })\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const zero = <I, A extends I>(): Guard<I, A> => ({\n  is: (_): _ is A => false\n})\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const compose =\n  <I, A extends I, B extends A>(to: Guard<A, B>) =>\n  (from: Guard<I, A>): Guard<I, B> => ({\n    is: (i): i is B => from.is(i) && to.is(i)\n  })\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const id = <A>(): Guard<A, A> => ({\n  is: (_): _ is A => true\n})\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.0\n */\nexport const URI = 'io-ts/Guard'\n\n/**\n * @category instances\n * @since 2.2.0\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind<A> {\n    readonly [URI]: Guard<unknown, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Schemable: S.Schemable1<URI> = {\n  URI,\n  literal,\n  string,\n  number,\n  boolean,\n  nullable,\n  type,\n  struct,\n  partial,\n  record,\n  array,\n  tuple: tuple as S.Schemable1<URI>['tuple'],\n  intersect,\n  sum,\n  lazy: (_, f) => lazy(f),\n  readonly\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnknownContainers: S.WithUnknownContainers1<URI> = {\n  UnknownArray,\n  UnknownRecord\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnion: S.WithUnion1<URI> = {\n  union: union as S.WithUnion1<URI>['union']\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithRefine: S.WithRefine1<URI> = {\n  refine: refine as S.WithRefine1<URI>['refine']\n}\n\n### Source File Dependency Files Content\n### Dependency File: Schemable.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { Refinement } from 'fp-ts/lib/function'\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\n/**\n * @since 2.2.0\n */\nexport type Literal = string | number | boolean | null\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable<S> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => HKT<S, A[number]>\n  readonly string: HKT<S, string>\n  readonly number: HKT<S, number>\n  readonly boolean: HKT<S, boolean>\n  readonly nullable: <A>(or: HKT<S, A>) => HKT<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: HKT<S, A>) => HKT<S, Record<string, A>>\n  readonly array: <A>(item: HKT<S, A>) => HKT<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, A>\n  readonly intersect: <B>(right: HKT<S, B>) => <A>(left: HKT<S, A>) => HKT<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: HKT<S, A[K] & Record<T, K>> }) => HKT<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => HKT<S, A>) => HKT<S, A>\n  readonly readonly: <A>(sa: HKT<S, A>) => HKT<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable1<S extends URIS> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind<S, A[number]>\n  readonly string: Kind<S, string>\n  readonly number: Kind<S, number>\n  readonly boolean: Kind<S, boolean>\n  readonly nullable: <A>(or: Kind<S, A>) => Kind<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: Kind<S, A>) => Kind<S, Record<string, A>>\n  readonly array: <A>(item: Kind<S, A>) => Kind<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, A>\n  readonly intersect: <B>(right: Kind<S, B>) => <A>(left: Kind<S, A>) => Kind<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind<S, A[K] & Record<T, K>> }) => Kind<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind<S, A>) => Kind<S, A>\n  readonly readonly: <A>(sa: Kind<S, A>) => Kind<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface Schemable2C<S extends URIS2, E> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind2<S, E, A[number]>\n  readonly string: Kind2<S, E, string>\n  readonly number: Kind2<S, E, number>\n  readonly boolean: Kind2<S, E, boolean>\n  readonly nullable: <A>(or: Kind2<S, E, A>) => Kind2<S, E, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<\n    S,\n    E,\n    Partial<{ [K in keyof A]: A[K] }>\n  >\n  readonly record: <A>(codomain: Kind2<S, E, A>) => Kind2<S, E, Record<string, A>>\n  readonly array: <A>(item: Kind2<S, E, A>) => Kind2<S, E, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(\n    ...components: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A>\n  readonly intersect: <B>(right: Kind2<S, E, B>) => <A>(left: Kind2<S, E, A>) => Kind2<S, E, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind2<S, E, A[K] & Record<T, K>> }) => Kind2<S, E, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind2<S, E, A>) => Kind2<S, E, A>\n  readonly readonly: <A>(sa: Kind2<S, E, A>) => Kind2<S, E, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers<S> {\n  readonly UnknownArray: HKT<S, Array<unknown>>\n  readonly UnknownRecord: HKT<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers1<S extends URIS> {\n  readonly UnknownArray: Kind<S, Array<unknown>>\n  readonly UnknownRecord: Kind<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnknownContainers2C<S extends URIS2, E> {\n  readonly UnknownArray: Kind2<S, E, Array<unknown>>\n  readonly UnknownRecord: Kind2<S, E, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion<S> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: HKT<S, A[K]> }\n  ) => HKT<S, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion1<S extends URIS> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind<S, A[K]> }\n  ) => Kind<S, A[number]>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnion2C<S extends URIS2, E> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine<S> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: HKT<S, A>) => HKT<S, B>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine1<S extends URIS> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Kind<S, A>) => Kind<S, B>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithRefine2C<S extends URIS2, E> {\n  readonly refine: <A, B extends A>(\n    refinement: Refinement<A, B>,\n    id: string\n  ) => (from: Kind2<S, E, A>) => Kind2<S, E, B>\n}\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst typeOf = (x: unknown): string => (x === null ? 'null' : typeof x)\n\n/**\n * @internal\n */\nexport const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport * as assert from 'assert'\nimport { pipe } from 'fp-ts/lib/pipeable'\nimport { Stream } from 'stream'\n\nimport * as G from '../src/Guard'\n\ninterface NonEmptyStringBrand {\n  readonly NonEmptyString: unique symbol\n}\n\ntype NonEmptyString = string & NonEmptyStringBrand\n\nconst NonEmptyString: G.Guard<string, NonEmptyString> = {\n  is: (s): s is NonEmptyString => s.length > 0\n}\n\ndescribe.concurrent('Guard', () => {\n  it('alt', () => {\n    const guard = pipe(\n      G.string,\n      G.alt<unknown, string | number>(() => G.number)\n    )\n    assert.strictEqual(guard.is('a'), true)\n    assert.strictEqual(guard.is(1), true)\n    assert.strictEqual(guard.is(null), false)\n  })\n\n  it('zero', () => {\n    const guard = G.zero()\n    assert.strictEqual(guard.is('a'), false)\n  })\n\n  it('compose', () => {\n    const guard = pipe(G.string, G.compose(NonEmptyString))\n    assert.strictEqual(guard.is('a'), true)\n    assert.strictEqual(guard.is(null), false)\n    assert.strictEqual(guard.is(''), false)\n  })\n\n  it('id', () => {\n    const guard = G.id<string>()\n    assert.strictEqual(guard.is('a'), true)\n  })\n\n  describe.concurrent('number', () => {\n    it('should exclude NaN', () => {\n      assert.deepStrictEqual(G.number.is(NaN), false)\n    })\n  })\n\n  describe.concurrent('refine', () => {\n    it('should accept valid inputs', () => {\n      const guard = pipe(\n        G.string,\n        G.refine((s): s is string => s.length > 0)\n      )\n      assert.strictEqual(guard.is('a'), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = pipe(\n        G.string,\n        G.refine((s): s is string => s.length > 0)\n      )\n      assert.strictEqual(guard.is(undefined), false)\n      assert.strictEqual(guard.is(''), false)\n    })\n  })\n\n  describe.concurrent('nullable', () => {\n    it('should accept valid inputs', () => {\n      const guard = G.nullable(G.string)\n      assert.strictEqual(guard.is(null), true)\n      assert.strictEqual(guard.is('a'), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = G.nullable(G.string)\n      assert.strictEqual(guard.is(1), false)\n    })\n  })\n\n  describe.concurrent('struct', () => {\n    it('should accept valid inputs', () => {\n      const guard = G.struct({ a: G.string, b: G.number })\n      assert.strictEqual(guard.is({ a: 'a', b: 1 }), true)\n    })\n\n    it('should accept additional fields', () => {\n      const guard = G.struct({ a: G.string, b: G.number })\n      assert.strictEqual(guard.is({ a: 'a', b: 1, c: true }), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = G.struct({ a: G.string, b: G.number })\n      assert.strictEqual(guard.is(undefined), false)\n      assert.strictEqual(guard.is({ a: 'a' }), false)\n    })\n\n    it('should check missing fields', () => {\n      const undef: G.Guard<unknown, undefined> = {\n        is: (u): u is undefined => u === undefined\n      }\n      const guard = G.struct({ a: undef })\n      assert.strictEqual(guard.is({}), false)\n    })\n\n    it('should support getters', () => {\n      class A {\n        get a() {\n          return 'a'\n        }\n        get b() {\n          return 'b'\n        }\n      }\n      const guard = G.struct({ a: G.string, b: G.string })\n      assert.deepStrictEqual(guard.is(new A()), true)\n    })\n  })\n\n  describe.concurrent('partial', () => {\n    it('should accept valid inputs', () => {\n      const guard = G.partial({ a: G.string, b: G.number })\n      assert.strictEqual(guard.is({ a: 'a', b: 1 }), true)\n      assert.strictEqual(guard.is({ a: 'a' }), true)\n      assert.strictEqual(guard.is({ b: 1 }), true)\n      assert.strictEqual(guard.is({}), true)\n    })\n\n    it('should accept additional fields', () => {\n      const guard = G.partial({ a: G.string, b: G.number })\n      assert.strictEqual(guard.is({ a: 'a', b: 1, c: true }), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = G.partial({ a: G.string, b: G.number })\n      assert.strictEqual(guard.is(undefined), false)\n      assert.strictEqual(guard.is({ a: 'a', b: 'b' }), false)\n    })\n\n    it('should support getters', () => {\n      class A {\n        get a() {\n          return 'a'\n        }\n        get b() {\n          return 'b'\n        }\n      }\n      const guard = G.partial({ a: G.string, b: G.string })\n      assert.deepStrictEqual(guard.is(new A()), true)\n    })\n  })\n\n  describe.concurrent('record', () => {\n    it('should accept valid inputs', () => {\n      const guard = G.record(G.string)\n      assert.strictEqual(guard.is({}), true)\n      assert.strictEqual(guard.is({ a: 'a', b: 'b' }), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = G.record(G.string)\n      assert.strictEqual(guard.is(undefined), false)\n      assert.strictEqual(guard.is({ a: 'a', b: 1 }), false)\n    })\n  })\n\n  describe.concurrent('array', () => {\n    it('should accept valid inputs', () => {\n      const guard = G.array(G.number)\n      assert.strictEqual(guard.is([]), true)\n      assert.strictEqual(guard.is([1, 2, 3]), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = G.array(G.number)\n      assert.strictEqual(guard.is(undefined), false)\n      assert.strictEqual(guard.is(['a']), false)\n    })\n  })\n\n  describe.concurrent('tuple', () => {\n    it('should accept valid inputs', () => {\n      const guard = G.tuple(G.string, G.number)\n      assert.strictEqual(guard.is(['a', 1]), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = G.tuple(G.string, G.number)\n      assert.strictEqual(guard.is([1, 2]), false)\n    })\n\n    it('should reject additional fields', () => {\n      const guard = G.tuple(G.string, G.number)\n      assert.strictEqual(guard.is(['a', 1, true]), false)\n    })\n\n    it('should reject missing fields', () => {\n      const guard = G.tuple(G.string, G.number)\n      assert.strictEqual(guard.is(['a']), false)\n    })\n  })\n\n  describe.concurrent('intersect', () => {\n    it('should accept valid inputs', () => {\n      const guard = pipe(G.struct({ a: G.string }), G.intersect(G.struct({ b: G.number })))\n      assert.strictEqual(guard.is({ a: 'a', b: 1 }), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = pipe(G.struct({ a: G.string }), G.intersect(G.struct({ b: G.number })))\n      assert.strictEqual(guard.is({ a: 'a' }), false)\n    })\n  })\n\n  describe.concurrent('union', () => {\n    it('should accept valid inputs', () => {\n      const guard = G.union(G.string, G.number)\n      assert.strictEqual(guard.is('a'), true)\n      assert.strictEqual(guard.is(1), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = G.union(G.string, G.number)\n      assert.strictEqual(guard.is(undefined), false)\n    })\n  })\n\n  describe.concurrent('lazy', () => {\n    interface A {\n      a: number\n      b: Array<A>\n    }\n\n    const guard: G.Guard<unknown, A> = G.Schemable.lazy('A', () =>\n      G.struct({\n        a: G.number,\n        b: G.array(guard)\n      })\n    )\n\n    it('should accept valid inputs', () => {\n      assert.strictEqual(guard.is({ a: 1, b: [] }), true)\n      assert.strictEqual(guard.is({ a: 1, b: [{ a: 2, b: [] }] }), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = G.union(G.string, G.number)\n      assert.strictEqual(guard.is(undefined), false)\n    })\n  })\n\n  describe.concurrent('sum', () => {\n    const sum = G.sum('_tag')\n\n    it('should accept valid inputs', () => {\n      const guard = sum({\n        A: G.struct({ _tag: G.literal('A'), a: G.string }),\n        B: G.struct({ _tag: G.literal('B'), b: G.number })\n      })\n      assert.deepStrictEqual(guard.is({ _tag: 'A', a: 'a' }), true)\n      assert.deepStrictEqual(guard.is({ _tag: 'B', b: 1 }), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      const guard = sum({\n        A: G.struct({ _tag: G.literal('A'), a: G.string }),\n        B: G.struct({ _tag: G.literal('B'), b: G.number })\n      })\n      assert.strictEqual(guard.is(undefined), false)\n      assert.strictEqual(guard.is({}), false)\n    })\n\n    it('should support non-`string` tag values', () => {\n      const guard = G.sum('_tag')({\n        [1]: G.struct({ _tag: G.literal(1), a: G.string }),\n        [2]: G.struct({ _tag: G.literal(2), b: G.number })\n      })\n      assert.deepStrictEqual(guard.is({ _tag: 1, a: 'a' }), true)\n      assert.deepStrictEqual(guard.is({ _tag: 2, b: 1 }), true)\n      assert.deepStrictEqual(guard.is({ _tag: 2, b: 'a' }), false)\n    })\n  })\n\n  describe.concurrent('UnknownRecord', () => {\n    it('should accept valid inputs', () => {\n      assert.deepStrictEqual(G.UnknownRecord.is({}), true)\n      assert.deepStrictEqual(G.UnknownRecord.is(new String()), true)\n      assert.deepStrictEqual(G.UnknownRecord.is(new Number()), true)\n      assert.deepStrictEqual(G.UnknownRecord.is(new Set()), true)\n      assert.deepStrictEqual(G.UnknownRecord.is(new Map()), true)\n      assert.deepStrictEqual(G.UnknownRecord.is(new Stream()), true)\n    })\n\n    it('should reject invalid inputs', () => {\n      assert.deepStrictEqual(G.UnknownRecord.is(null), false)\n      assert.deepStrictEqual(G.UnknownRecord.is(undefined), false)\n      assert.deepStrictEqual(G.UnknownRecord.is([]), false)\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\JsonSchema.test.ts\\JsonSchema.test.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\nimport * as C from 'fp-ts/lib/Const'\nimport { identity } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\nimport * as R from 'fp-ts/lib/ReadonlyRecord'\nimport { JSONSchema7 } from 'json-schema'\n\nimport * as S from '../src/Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\nexport interface JsonSchema<A> {\n  readonly compile: (definitions?: Record<string, JSONSchema7 | undefined>) => C.Const<JSONSchema7, A>\n}\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\nexport function literal<A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n): JsonSchema<A[number]> {\n  return {\n    compile: () => C.make({ enum: [...values] })\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\nexport const string: JsonSchema<string> = {\n  compile: () => C.make({ type: 'string' })\n}\n\nexport const number: JsonSchema<number> = {\n  compile: () => C.make({ type: 'number' })\n}\n\nexport const boolean: JsonSchema<boolean> = {\n  compile: () => C.make({ type: 'boolean' })\n}\n\n// tslint:disable-next-line: readonly-array\nexport const UnknownArray: JsonSchema<Array<unknown>> = {\n  compile: () => C.make({ type: 'array' })\n}\n\nexport const UnknownRecord: JsonSchema<Record<string, unknown>> = {\n  compile: () => C.make({ type: 'object' })\n}\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\nconst nullJsonSchema: JsonSchema<null> = {\n  compile: () => C.make({ enum: [null] })\n}\n\nexport function nullable<A>(or: JsonSchema<A>): JsonSchema<null | A> {\n  return union(nullJsonSchema, or)\n}\n\nexport function struct<A>(properties: { [K in keyof A]: JsonSchema<A[K]> }): JsonSchema<A> {\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'object',\n        properties: pipe(\n          properties,\n          R.map<JsonSchema<unknown>, JSONSchema7>((p) => p.compile(lazy))\n        ),\n        required: Object.keys(properties)\n      })\n  }\n}\n\nexport function partial<A>(properties: { [K in keyof A]: JsonSchema<A[K]> }): JsonSchema<Partial<A>> {\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'object',\n        properties: pipe(\n          properties,\n          R.map<JsonSchema<unknown>, JSONSchema7>((p) => p.compile(lazy))\n        )\n      })\n  }\n}\n\nexport function record<A>(codomain: JsonSchema<A>): JsonSchema<Record<string, A>> {\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'object',\n        additionalProperties: codomain.compile(lazy)\n      })\n  }\n}\n\n// tslint:disable-next-line: readonly-array\nexport function array<A>(items: JsonSchema<A>): JsonSchema<Array<A>> {\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'array',\n        items: items.compile(lazy)\n      })\n  }\n}\n\nexport function tuple<A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: JsonSchema<A[K]> }\n): JsonSchema<A> {\n  const len = components.length\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'array',\n        items: len > 0 ? components.map((c) => c.compile(lazy)) : undefined,\n        minItems: len,\n        maxItems: len\n      })\n  }\n}\n\nexport const intersect =\n  <B>(right: JsonSchema<B>) =>\n  <A>(left: JsonSchema<A>): JsonSchema<A & B> => ({\n    compile: (lazy) => C.make({ allOf: [left.compile(lazy), right.compile(lazy)] })\n  })\n\nexport function sum<T extends string>(\n  _tag: T\n): <A>(members: { [K in keyof A]: JsonSchema<A[K] & Record<T, K>> }) => JsonSchema<A[keyof A]> {\n  return (members: Record<string, JsonSchema<unknown>>) => {\n    return {\n      compile: (lazy) => C.make({ anyOf: Object.keys(members).map((k) => members[k].compile(lazy)) })\n    }\n  }\n}\n\nexport function lazy<A>(id: string, f: () => JsonSchema<A>): JsonSchema<A> {\n  const $ref = `#/definitions/${id}`\n  return {\n    compile: (definitions) => {\n      if (definitions !== undefined) {\n        if (Object.prototype.hasOwnProperty.call(definitions, id)) {\n          return C.make({ $ref })\n        }\n        definitions[id] = undefined\n        return (definitions[id] = f().compile(definitions))\n      } else {\n        definitions = { [id]: undefined }\n        definitions[id] = f().compile(definitions)\n        return C.make({\n          definitions,\n          $ref\n        })\n      }\n    }\n  }\n}\n\nexport const readonly: <A>(arb: JsonSchema<A>) => JsonSchema<Readonly<A>> = identity\n\nexport function union<A extends readonly [unknown, ...ReadonlyArray<unknown>]>(\n  ...members: { [K in keyof A]: JsonSchema<A[K]> }\n): JsonSchema<A[number]> {\n  return {\n    compile: (lazy) => C.make({ anyOf: members.map((m) => m.compile(lazy)) })\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\nexport const URI = 'io-ts/JsonSchema'\n\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind<A> {\n    readonly [URI]: JsonSchema<A>\n  }\n}\n\nexport const Schemable: S.Schemable1<URI> & S.WithUnknownContainers1<URI> & S.WithUnion1<URI> = {\n  URI,\n  literal,\n  string,\n  number,\n  boolean,\n  UnknownArray,\n  UnknownRecord,\n  nullable,\n  type: struct,\n  struct,\n  partial,\n  record,\n  array,\n  tuple: tuple as S.Schemable1<URI>['tuple'],\n  intersect,\n  sum,\n  lazy,\n  readonly,\n  union: union as S.WithUnion1<URI>['union']\n}\n\n### Source File Dependency Files Content\n### Dependency File: Schemable.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { Refinement } from 'fp-ts/lib/function'\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\n/**\n * @since 2.2.0\n */\nexport type Literal = string | number | boolean | null\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable<S> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => HKT<S, A[number]>\n  readonly string: HKT<S, string>\n  readonly number: HKT<S, number>\n  readonly boolean: HKT<S, boolean>\n  readonly nullable: <A>(or: HKT<S, A>) => HKT<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: HKT<S, A>) => HKT<S, Record<string, A>>\n  readonly array: <A>(item: HKT<S, A>) => HKT<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, A>\n  readonly intersect: <B>(right: HKT<S, B>) => <A>(left: HKT<S, A>) => HKT<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: HKT<S, A[K] & Record<T, K>> }) => HKT<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => HKT<S, A>) => HKT<S, A>\n  readonly readonly: <A>(sa: HKT<S, A>) => HKT<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable1<S extends URIS> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind<S, A[number]>\n  readonly string: Kind<S, string>\n  readonly number: Kind<S, number>\n  readonly boolean: Kind<S, boolean>\n  readonly nullable: <A>(or: Kind<S, A>) => Kind<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: Kind<S, A>) => Kind<S, Record<string, A>>\n  readonly array: <A>(item: Kind<S, A>) => Kind<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, A>\n  readonly intersect: <B>(right: Kind<S, B>) => <A>(left: Kind<S, A>) => Kind<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind<S, A[K] & Record<T, K>> }) => Kind<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind<S, A>) => Kind<S, A>\n  readonly readonly: <A>(sa: Kind<S, A>) => Kind<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface Schemable2C<S extends URIS2, E> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind2<S, E, A[number]>\n  readonly string: Kind2<S, E, string>\n  readonly number: Kind2<S, E, number>\n  readonly boolean: Kind2<S, E, boolean>\n  readonly nullable: <A>(or: Kind2<S, E, A>) => Kind2<S, E, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<\n    S,\n    E,\n    Partial<{ [K in keyof A]: A[K] }>\n  >\n  readonly record: <A>(codomain: Kind2<S, E, A>) => Kind2<S, E, Record<string, A>>\n  readonly array: <A>(item: Kind2<S, E, A>) => Kind2<S, E, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(\n    ...components: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A>\n  readonly intersect: <B>(right: Kind2<S, E, B>) => <A>(left: Kind2<S, E, A>) => Kind2<S, E, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind2<S, E, A[K] & Record<T, K>> }) => Kind2<S, E, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind2<S, E, A>) => Kind2<S, E, A>\n  readonly readonly: <A>(sa: Kind2<S, E, A>) => Kind2<S, E, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers<S> {\n  readonly UnknownArray: HKT<S, Array<unknown>>\n  readonly UnknownRecord: HKT<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers1<S extends URIS> {\n  readonly UnknownArray: Kind<S, Array<unknown>>\n  readonly UnknownRecord: Kind<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnknownContainers2C<S extends URIS2, E> {\n  readonly UnknownArray: Kind2<S, E, Array<unknown>>\n  readonly UnknownRecord: Kind2<S, E, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion<S> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: HKT<S, A[K]> }\n  ) => HKT<S, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion1<S extends URIS> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind<S, A[K]> }\n  ) => Kind<S, A[number]>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnion2C<S extends URIS2, E> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine<S> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: HKT<S, A>) => HKT<S, B>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine1<S extends URIS> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Kind<S, A>) => Kind<S, B>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithRefine2C<S extends URIS2, E> {\n  readonly refine: <A, B extends A>(\n    refinement: Refinement<A, B>,\n    id: string\n  ) => (from: Kind2<S, E, A>) => Kind2<S, E, B>\n}\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst typeOf = (x: unknown): string => (x === null ? 'null' : typeof x)\n\n/**\n * @internal\n */\nexport const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport Ajv from 'ajv'\nimport * as assert from 'assert'\nimport * as C from 'fp-ts/lib/Const'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as J from './JsonSchema'\n\nconst ajv = new Ajv()\n\ndescribe.concurrent('JsonSchema', () => {\n  it('literal', () => {\n    const validate = ajv.compile(J.literal('a').compile())\n    assert.strictEqual(validate('a'), true)\n    assert.strictEqual(validate(1), false)\n  })\n\n  it('string', () => {\n    const validate = ajv.compile(J.string.compile())\n    assert.strictEqual(validate('a'), true)\n    assert.strictEqual(validate(1), false)\n  })\n\n  it('boolean', () => {\n    const validate = ajv.compile(J.boolean.compile())\n    assert.strictEqual(validate(true), true)\n    assert.strictEqual(validate(1), false)\n  })\n\n  it('UnknownArray', () => {\n    const validate = ajv.compile(J.UnknownArray.compile())\n    assert.strictEqual(validate([]), true)\n    assert.strictEqual(validate([1, 2, 3]), true)\n    assert.strictEqual(validate(1), false)\n    assert.strictEqual(validate([1, undefined, 3]), true)\n  })\n\n  it('UnknownRecord', () => {\n    const validate = ajv.compile(J.UnknownRecord.compile())\n    assert.strictEqual(validate({}), true)\n    assert.strictEqual(validate({ a: 'a', b: 1 }), true)\n    assert.strictEqual(validate(1), false)\n    assert.strictEqual(validate({ a: 'a', b: 1, c: undefined }), true)\n  })\n\n  it('struct', () => {\n    const schema = J.struct({ a: J.string, b: J.number }).compile()\n    const validate = ajv.compile(schema)\n    assert.strictEqual(validate({ a: 'a', b: 1 }), true)\n    assert.strictEqual(validate({ a: 'a' }), false)\n    assert.strictEqual(validate({ a: 'a', b: 'b' }), false)\n  })\n\n  it('partial', () => {\n    const validate = ajv.compile(J.partial({ a: J.string, b: J.number }).compile())\n    assert.strictEqual(validate({ a: 'a', b: 1 }), true)\n    assert.strictEqual(validate({ a: 'a' }), true)\n    assert.strictEqual(validate({ a: 'a', b: undefined }), true)\n    assert.strictEqual(validate({ a: 'a', b: 'b' }), false)\n  })\n\n  it('record', () => {\n    const validate = ajv.compile(J.record(J.string).compile())\n    assert.strictEqual(validate({ a: 'a', b: 'b' }), true)\n    assert.strictEqual(validate({ a: 'a', b: 1 }), false)\n  })\n\n  it('array', () => {\n    const validate = ajv.compile(J.array(J.number).compile())\n    assert.strictEqual(validate([]), true)\n    assert.strictEqual(validate([1, 2, 3]), true)\n    assert.strictEqual(validate([1, 'a', 3]), false)\n  })\n\n  it('tuple', () => {\n    const validate = ajv.compile(J.tuple(J.string, J.number).compile())\n    assert.strictEqual(validate(['a', 1]), true)\n    assert.strictEqual(validate(['a', 1, true]), false)\n    assert.strictEqual(validate(['a']), false)\n  })\n\n  describe.concurrent('intersection', () => {\n    it('should handle non primitive values', () => {\n      const validate = ajv.compile(pipe(J.struct({ a: J.string }), J.intersect(J.struct({ b: J.number }))).compile())\n      assert.strictEqual(validate({ a: 'a', b: 1 }), true)\n      assert.strictEqual(validate({ a: 'a' }), false)\n    })\n\n    interface IntBrand {\n      readonly Int: unique symbol\n    }\n    type Int = number & IntBrand\n\n    const Int: J.JsonSchema<Int> = {\n      compile: () =>\n        C.make({\n          type: 'integer'\n        })\n    }\n    const Positive: J.JsonSchema<number> = {\n      compile: () =>\n        C.make({\n          type: 'number',\n          minimum: 0\n        })\n    }\n\n    it('should handle primitives', () => {\n      const validate = ajv.compile(pipe(Int, J.intersect(Positive)).compile())\n      assert.strictEqual(validate(1), true)\n      assert.strictEqual(validate(-1), false)\n    })\n  })\n\n  it('sum', () => {\n    const sum = J.sum('_tag')\n\n    const A = J.struct({ _tag: J.literal('A'), a: J.string })\n    const B = J.struct({ _tag: J.literal('B'), b: J.number })\n    const validate = ajv.compile(sum({ A, B }).compile())\n    assert.strictEqual(validate({ _tag: 'A', a: 'a' }), true)\n    assert.strictEqual(validate({ _tag: 'B', b: 1 }), true)\n    assert.strictEqual(validate(undefined), false)\n    assert.strictEqual(validate({}), false)\n  })\n\n  it('union', () => {\n    const validate = ajv.compile(J.union(J.string, J.number).compile())\n    assert.strictEqual(validate('a'), true)\n    assert.strictEqual(validate(1), true)\n    assert.strictEqual(validate(true), false)\n  })\n\n  describe.concurrent('lazy', () => {\n    it('should support recursive json schemas', () => {\n      interface A {\n        readonly a: number\n        readonly b?: A\n      }\n\n      const schema: J.JsonSchema<A> = J.lazy('A', () =>\n        pipe(J.struct({ a: J.number }), J.intersect(J.partial({ b: schema })))\n      )\n\n      const jsonSchema = schema.compile()\n      const validate = ajv.compile(jsonSchema)\n      assert.strictEqual(validate({}), false)\n      assert.strictEqual(validate({ a: 1 }), true)\n      assert.strictEqual(validate({ a: 1, b: null }), false)\n      assert.strictEqual(validate({ a: 1, b: { a: 2 } }), true)\n    })\n\n    it('should support mutually recursive json schemas', () => {\n      interface A {\n        readonly b?: B\n      }\n      interface B {\n        readonly a?: A\n      }\n      const A: J.JsonSchema<A> = J.lazy('A', () => J.partial({ b: B }))\n      const B: J.JsonSchema<B> = J.lazy('B', () => J.partial({ a: A }))\n      const jsonSchema = A.compile()\n      const validateA = ajv.compile(jsonSchema)\n      assert.strictEqual(validateA({}), true)\n      assert.strictEqual(validateA({ b: {} }), true)\n      assert.strictEqual(validateA({ b: { a: {} } }), true)\n\n      const validateB = ajv.compile(B.compile())\n      assert.strictEqual(validateB({}), true)\n      assert.strictEqual(validateB({ a: {} }), true)\n      assert.strictEqual(validateB({ a: { b: {} } }), true)\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\Schema.ts\\Schema.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\nimport { memoize, Schemable, Schemable1, Schemable2C } from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.0\n */\nexport interface Schema<A> {\n  <S>(S: Schemable<S>): HKT<S, A>\n}\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.0\n */\nexport function make<A>(schema: Schema<A>): Schema<A> {\n  return memoize(schema)\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.0\n */\nexport type TypeOf<S> = S extends Schema<infer A> ? A : never\n\n/**\n * @since 2.2.3\n */\nexport function interpreter<S extends URIS2>(S: Schemable2C<S, unknown>): <A>(schema: Schema<A>) => Kind2<S, unknown, A>\nexport function interpreter<S extends URIS>(S: Schemable1<S>): <A>(schema: Schema<A>) => Kind<S, A>\nexport function interpreter<S>(S: Schemable<S>): <A>(schema: Schema<A>) => HKT<S, A> {\n  return (schema) => schema(S)\n}\n\n### Source File Dependency Files Content\n### Dependency File: Schemable.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { Refinement } from 'fp-ts/lib/function'\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\n/**\n * @since 2.2.0\n */\nexport type Literal = string | number | boolean | null\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable<S> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => HKT<S, A[number]>\n  readonly string: HKT<S, string>\n  readonly number: HKT<S, number>\n  readonly boolean: HKT<S, boolean>\n  readonly nullable: <A>(or: HKT<S, A>) => HKT<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: HKT<S, A>) => HKT<S, Record<string, A>>\n  readonly array: <A>(item: HKT<S, A>) => HKT<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, A>\n  readonly intersect: <B>(right: HKT<S, B>) => <A>(left: HKT<S, A>) => HKT<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: HKT<S, A[K] & Record<T, K>> }) => HKT<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => HKT<S, A>) => HKT<S, A>\n  readonly readonly: <A>(sa: HKT<S, A>) => HKT<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable1<S extends URIS> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind<S, A[number]>\n  readonly string: Kind<S, string>\n  readonly number: Kind<S, number>\n  readonly boolean: Kind<S, boolean>\n  readonly nullable: <A>(or: Kind<S, A>) => Kind<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: Kind<S, A>) => Kind<S, Record<string, A>>\n  readonly array: <A>(item: Kind<S, A>) => Kind<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, A>\n  readonly intersect: <B>(right: Kind<S, B>) => <A>(left: Kind<S, A>) => Kind<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind<S, A[K] & Record<T, K>> }) => Kind<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind<S, A>) => Kind<S, A>\n  readonly readonly: <A>(sa: Kind<S, A>) => Kind<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface Schemable2C<S extends URIS2, E> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind2<S, E, A[number]>\n  readonly string: Kind2<S, E, string>\n  readonly number: Kind2<S, E, number>\n  readonly boolean: Kind2<S, E, boolean>\n  readonly nullable: <A>(or: Kind2<S, E, A>) => Kind2<S, E, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<\n    S,\n    E,\n    Partial<{ [K in keyof A]: A[K] }>\n  >\n  readonly record: <A>(codomain: Kind2<S, E, A>) => Kind2<S, E, Record<string, A>>\n  readonly array: <A>(item: Kind2<S, E, A>) => Kind2<S, E, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(\n    ...components: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A>\n  readonly intersect: <B>(right: Kind2<S, E, B>) => <A>(left: Kind2<S, E, A>) => Kind2<S, E, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind2<S, E, A[K] & Record<T, K>> }) => Kind2<S, E, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind2<S, E, A>) => Kind2<S, E, A>\n  readonly readonly: <A>(sa: Kind2<S, E, A>) => Kind2<S, E, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers<S> {\n  readonly UnknownArray: HKT<S, Array<unknown>>\n  readonly UnknownRecord: HKT<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers1<S extends URIS> {\n  readonly UnknownArray: Kind<S, Array<unknown>>\n  readonly UnknownRecord: Kind<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnknownContainers2C<S extends URIS2, E> {\n  readonly UnknownArray: Kind2<S, E, Array<unknown>>\n  readonly UnknownRecord: Kind2<S, E, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion<S> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: HKT<S, A[K]> }\n  ) => HKT<S, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion1<S extends URIS> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind<S, A[K]> }\n  ) => Kind<S, A[number]>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnion2C<S extends URIS2, E> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine<S> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: HKT<S, A>) => HKT<S, B>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine1<S extends URIS> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Kind<S, A>) => Kind<S, B>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithRefine2C<S extends URIS2, E> {\n  readonly refine: <A, B extends A>(\n    refinement: Refinement<A, B>,\n    id: string\n  ) => (from: Kind2<S, E, A>) => Kind2<S, E, B>\n}\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst typeOf = (x: unknown): string => (x === null ? 'null' : typeof x)\n\n/**\n * @internal\n */\nexport const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport * as fc from 'fast-check'\nimport { isRight } from 'fp-ts/lib/Either'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as D from '../src/Decoder'\nimport * as Eq from '../src/Eq'\nimport * as G from '../src/Guard'\nimport { interpreter, make, Schema } from '../src/Schema'\nimport * as A from './Arbitrary'\n\nfunction check<A>(schema: Schema<A>): void {\n  const arb = interpreter(A.Schemable)(schema)\n  const decoder = interpreter(D.Schemable)(schema)\n  const guard = interpreter(G.Schemable)(schema)\n  const eq = interpreter(Eq.Schemable)(schema)\n  // decoders, guards and eqs should be aligned\n  fc.assert(fc.property(arb, (a) => isRight(decoder.decode(a)) && guard.is(a) && eq.equals(a, a)))\n}\ndescribe.concurrent('Schema', () => {\n  it('string', () => {\n    check(make((S) => S.string))\n  })\n\n  it('number', () => {\n    check(make((S) => S.number))\n  })\n\n  it('boolean', () => {\n    check(make((S) => S.boolean))\n  })\n\n  it('literal', () => {\n    check(make((S) => S.literal('a')))\n    check(make((S) => S.literal('a', 1)))\n    check(make((S) => S.literal('a', null)))\n  })\n\n  it('nullable', () => {\n    check(make((S) => S.nullable(S.string)))\n  })\n\n  it('struct', () => {\n    check(\n      make((S) =>\n        S.struct({\n          name: S.string,\n          age: S.number\n        })\n      )\n    )\n  })\n\n  it('partial', () => {\n    check(\n      make((S) =>\n        S.partial({\n          name: S.string,\n          age: S.number\n        })\n      )\n    )\n  })\n\n  it('record', () => {\n    check(make((S) => S.record(S.string)))\n  })\n\n  it('array', () => {\n    check(make((S) => S.array(S.string)))\n  })\n\n  it('tuple', () => {\n    check(make((S) => S.tuple()))\n    check(make((S) => S.tuple(S.string)))\n    check(make((S) => S.tuple(S.string, S.number)))\n  })\n\n  it('intersect', () => {\n    check(make((S) => pipe(S.struct({ a: S.string }), S.intersect(S.struct({ b: S.number })))))\n  })\n\n  it('sum', () => {\n    const A = make((S) => S.struct({ _tag: S.literal('A'), a: S.string }))\n    const B = make((S) => S.struct({ _tag: S.literal('B'), b: S.number }))\n    check(make((S) => S.sum('_tag')({ A: A(S), B: B(S) })))\n  })\n\n  it('lazy', () => {\n    interface A {\n      a: string\n      b?: A\n      c?: number\n    }\n\n    const schema: Schema<A> = make((S) =>\n      S.lazy('A', () => pipe(S.struct({ a: S.string }), S.intersect(S.partial({ b: schema(S), c: S.number }))))\n    )\n    check(schema)\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\Schemable.ts\\Schemable.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { Refinement } from 'fp-ts/lib/function'\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\n/**\n * @since 2.2.0\n */\nexport type Literal = string | number | boolean | null\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable<S> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => HKT<S, A[number]>\n  readonly string: HKT<S, string>\n  readonly number: HKT<S, number>\n  readonly boolean: HKT<S, boolean>\n  readonly nullable: <A>(or: HKT<S, A>) => HKT<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: HKT<S, A>) => HKT<S, Record<string, A>>\n  readonly array: <A>(item: HKT<S, A>) => HKT<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, A>\n  readonly intersect: <B>(right: HKT<S, B>) => <A>(left: HKT<S, A>) => HKT<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: HKT<S, A[K] & Record<T, K>> }) => HKT<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => HKT<S, A>) => HKT<S, A>\n  readonly readonly: <A>(sa: HKT<S, A>) => HKT<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable1<S extends URIS> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind<S, A[number]>\n  readonly string: Kind<S, string>\n  readonly number: Kind<S, number>\n  readonly boolean: Kind<S, boolean>\n  readonly nullable: <A>(or: Kind<S, A>) => Kind<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: Kind<S, A>) => Kind<S, Record<string, A>>\n  readonly array: <A>(item: Kind<S, A>) => Kind<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, A>\n  readonly intersect: <B>(right: Kind<S, B>) => <A>(left: Kind<S, A>) => Kind<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind<S, A[K] & Record<T, K>> }) => Kind<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind<S, A>) => Kind<S, A>\n  readonly readonly: <A>(sa: Kind<S, A>) => Kind<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface Schemable2C<S extends URIS2, E> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind2<S, E, A[number]>\n  readonly string: Kind2<S, E, string>\n  readonly number: Kind2<S, E, number>\n  readonly boolean: Kind2<S, E, boolean>\n  readonly nullable: <A>(or: Kind2<S, E, A>) => Kind2<S, E, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<\n    S,\n    E,\n    Partial<{ [K in keyof A]: A[K] }>\n  >\n  readonly record: <A>(codomain: Kind2<S, E, A>) => Kind2<S, E, Record<string, A>>\n  readonly array: <A>(item: Kind2<S, E, A>) => Kind2<S, E, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(\n    ...components: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A>\n  readonly intersect: <B>(right: Kind2<S, E, B>) => <A>(left: Kind2<S, E, A>) => Kind2<S, E, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind2<S, E, A[K] & Record<T, K>> }) => Kind2<S, E, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind2<S, E, A>) => Kind2<S, E, A>\n  readonly readonly: <A>(sa: Kind2<S, E, A>) => Kind2<S, E, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers<S> {\n  readonly UnknownArray: HKT<S, Array<unknown>>\n  readonly UnknownRecord: HKT<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers1<S extends URIS> {\n  readonly UnknownArray: Kind<S, Array<unknown>>\n  readonly UnknownRecord: Kind<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnknownContainers2C<S extends URIS2, E> {\n  readonly UnknownArray: Kind2<S, E, Array<unknown>>\n  readonly UnknownRecord: Kind2<S, E, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion<S> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: HKT<S, A[K]> }\n  ) => HKT<S, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion1<S extends URIS> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind<S, A[K]> }\n  ) => Kind<S, A[number]>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnion2C<S extends URIS2, E> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine<S> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: HKT<S, A>) => HKT<S, B>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine1<S extends URIS> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Kind<S, A>) => Kind<S, B>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithRefine2C<S extends URIS2, E> {\n  readonly refine: <A, B extends A>(\n    refinement: Refinement<A, B>,\n    id: string\n  ) => (from: Kind2<S, E, A>) => Kind2<S, E, B>\n}\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst typeOf = (x: unknown): string => (x === null ? 'null' : typeof x)\n\n/**\n * @internal\n */\nexport const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport * as assert from 'assert'\n\nimport * as S from '../src/Schemable'\n\ndescribe.concurrent('DecoderT', () => {\n  describe.concurrent('intersect', () => {\n    it('should concat strings', () => {\n      assert.deepStrictEqual(S.intersect_('a', 'b'), 'b')\n    })\n\n    it('should concat numbers', () => {\n      assert.deepStrictEqual(S.intersect_(1, 2), 2)\n    })\n\n    it('should concat booleans', () => {\n      assert.deepStrictEqual(S.intersect_(true, false), false)\n    })\n\n    it('should concat nulls', () => {\n      assert.deepStrictEqual(S.intersect_(null, null), null)\n    })\n\n    it('should concat undefineds', () => {\n      assert.deepStrictEqual(S.intersect_(undefined, undefined), undefined)\n    })\n\n    it('should concat objects', () => {\n      assert.deepStrictEqual(S.intersect_({ a: 1 }, { b: 2 }), { a: 1, b: 2 })\n    })\n\n    it('should concat a string with an object', () => {\n      assert.deepStrictEqual(S.intersect_('a', { a: 1 }), { 0: 'a', a: 1 })\n    })\n\n    it('should concat a number with an object', () => {\n      assert.deepStrictEqual(S.intersect_(1, { a: 1 }), { a: 1 })\n    })\n\n    it('should concat a boolean with an object', () => {\n      assert.deepStrictEqual(S.intersect_(true, { a: 1 }), { a: 1 })\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: io-ts\nTest File Path: io-ts\\TaskDecoder.ts\\TaskDecoder.ts\nProject Programming Language: typescript\nTesting Framework: vitest\n### Source File Content\n### Source File Content:\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Alt2, Alt2C } from 'fp-ts/lib/Alt'\nimport { Bifunctor2 } from 'fp-ts/lib/Bifunctor'\nimport { Category2 } from 'fp-ts/lib/Category'\nimport * as E from 'fp-ts/lib/Either'\nimport { identity, Refinement } from 'fp-ts/lib/function'\nimport { Functor2 } from 'fp-ts/lib/Functor'\nimport { MonadThrow2C } from 'fp-ts/lib/MonadThrow'\nimport { pipe } from 'fp-ts/lib/pipeable'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\n\nimport * as DE from './DecodeError'\nimport * as D from './Decoder'\nimport * as FS from './FreeSemigroup'\nimport * as G from './Guard'\nimport * as K from './Kleisli'\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// Kleisli config\n// -------------------------------------------------------------------------------------\n\nconst M: MonadThrow2C<TE.URI, DecodeError> & Bifunctor2<TE.URI> & Alt2C<TE.URI, DecodeError> = {\n  URI: TE.URI,\n  _E: undefined as any,\n  map: (fa, f) => pipe(fa, TE.map(f)),\n  ap: <A, B>(fab: TE.TaskEither<DecodeError, (a: A) => B>, fa: TE.TaskEither<DecodeError, A>) =>\n    pipe(\n      pipe(\n        fab,\n        T.map((h) => (ga: E.Either<DecodeError, A>) => D.ap(h, ga))\n      ),\n      T.ap(fa)\n    ),\n  of: TE.right,\n  chain: (ma, f) => pipe(ma, TE.chain(f)),\n  throwError: TE.left,\n  bimap: (fa, f, g) => pipe(fa, TE.bimap(f, g)),\n  mapLeft: (fa, f) => pipe(fa, TE.mapLeft(f)),\n  alt: (me, that) =>\n    pipe(\n      me,\n      T.chain((e1) =>\n        E.isRight(e1)\n          ? T.of(e1)\n          : pipe(\n              that(),\n              T.map((e2) => (E.isLeft(e2) ? E.left(D.SE.concat(e1.left, e2.left)) : e2))\n            )\n      )\n    )\n}\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.8\n */\nexport interface TaskDecoder<I, A> extends K.Kleisli<TE.URI, I, DecodeError, A> {}\n\n// -------------------------------------------------------------------------------------\n// DecodeError\n// -------------------------------------------------------------------------------------\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport type DecodeError = D.DecodeError\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const error: (actual: unknown, message: string) => DecodeError = D.error\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const success: <A>(a: A) => TE.TaskEither<DecodeError, A> = TE.right\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const failure = <A = never>(actual: unknown, message: string): TE.TaskEither<DecodeError, A> =>\n  TE.left(D.error(actual, message))\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const fromDecoder = <I, A>(decoder: D.Decoder<I, A>): TaskDecoder<I, A> => ({\n  decode: TE.fromEitherK(decoder.decode)\n})\n\n/**\n * @category constructors\n * @since 2.2.8\n */\nexport const fromRefinement = <I, A extends I>(refinement: Refinement<I, A>, expected: string): TaskDecoder<I, A> =>\n  fromDecoder(D.fromRefinement(refinement, expected))\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const fromGuard = <I, A extends I>(guard: G.Guard<I, A>, expected: string): TaskDecoder<I, A> =>\n  fromRefinement(guard.is, expected)\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n) => TaskDecoder<unknown, A[number]> =\n  /*#__PURE__*/\n  K.literal(M)((u, values) => error(u, values.map((value) => JSON.stringify(value)).join(' | ')))\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const string: TaskDecoder<unknown, string> =\n  /*#__PURE__*/\n  fromDecoder(D.string)\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const number: TaskDecoder<unknown, number> =\n  /*#__PURE__*/\n  fromDecoder(D.number)\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const boolean: TaskDecoder<unknown, boolean> =\n  /*#__PURE__*/\n  fromDecoder(D.boolean)\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const UnknownArray: TaskDecoder<unknown, Array<unknown>> =\n  /*#__PURE__*/\n  fromDecoder(D.UnknownArray)\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const UnknownRecord: TaskDecoder<unknown, Record<string, unknown>> =\n  /*#__PURE__*/\n  fromDecoder(D.UnknownRecord)\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const mapLeftWithInput: <I>(\n  f: (input: I, e: DecodeError) => DecodeError\n) => <A>(decoder: TaskDecoder<I, A>) => TaskDecoder<I, A> =\n  /*#__PURE__*/\n  K.mapLeftWithInput(M)\n\n/**\n * @category combinators\n * @since 2.2.9\n */\nexport const withMessage = <I>(\n  message: (input: I, e: DecodeError) => string\n): (<A>(decoder: TaskDecoder<I, A>) => TaskDecoder<I, A>) =>\n  mapLeftWithInput((input, e) => FS.of(DE.wrap(message(input, e), e)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const refine = <A, B extends A>(\n  refinement: Refinement<A, B>,\n  id: string\n): (<I>(from: TaskDecoder<I, A>) => TaskDecoder<I, B>) => K.refine(M)(refinement, (a) => error(a, id))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const parse: <A, B>(\n  parser: (a: A) => TE.TaskEither<DecodeError, B>\n) => <I>(from: TaskDecoder<I, A>) => TaskDecoder<I, B> =\n  /*#__PURE__*/\n  K.parse(M)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const nullable: <I, A>(or: TaskDecoder<I, A>) => TaskDecoder<null | I, null | A> =\n  /*#__PURE__*/\n  K.nullable(M)((u, e) => FS.concat(FS.of(DE.member(0, error(u, 'null'))), FS.of(DE.member(1, e))))\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const fromStruct = <P extends Record<string, TaskDecoder<any, any>>>(\n  properties: P\n): TaskDecoder<{ [K in keyof P]: InputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> =>\n  K.fromStruct(M)((k, e) => FS.of(DE.key(k, DE.required, e)))(properties)\n\n/**\n * Use `fromStruct` instead.\n *\n * @category combinators\n * @since 2.2.8\n * @deprecated\n */\nexport const fromType = fromStruct\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const struct = <A>(properties: { [K in keyof A]: TaskDecoder<unknown, A[K]> }): TaskDecoder<\n  unknown,\n  { [K in keyof A]: A[K] }\n> => pipe(UnknownRecord as any, compose(fromStruct(properties)))\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.7\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromPartial = <P extends Record<string, TaskDecoder<any, any>>>(\n  properties: P\n): TaskDecoder<Partial<{ [K in keyof P]: InputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> =>\n  K.fromPartial(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(properties)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const partial = <A>(properties: { [K in keyof A]: TaskDecoder<unknown, A[K]> }): TaskDecoder<\n  unknown,\n  Partial<{ [K in keyof A]: A[K] }>\n> => pipe(UnknownRecord as any, compose(fromPartial(properties)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromArray = <I, A>(item: TaskDecoder<I, A>): TaskDecoder<Array<I>, Array<A>> =>\n  K.fromArray(M)((i, e) => FS.of(DE.index(i, DE.optional, e)))(item)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const array = <A>(item: TaskDecoder<unknown, A>): TaskDecoder<unknown, Array<A>> =>\n  pipe(UnknownArray, compose(fromArray(item)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromRecord = <I, A>(codomain: TaskDecoder<I, A>): TaskDecoder<Record<string, I>, Record<string, A>> =>\n  K.fromRecord(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(codomain)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const record = <A>(codomain: TaskDecoder<unknown, A>): TaskDecoder<unknown, Record<string, A>> =>\n  pipe(UnknownRecord, compose(fromRecord(codomain)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromTuple = <C extends ReadonlyArray<TaskDecoder<any, any>>>(\n  ...components: C\n): TaskDecoder<{ [K in keyof C]: InputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> =>\n  K.fromTuple(M)((i, e) => FS.of(DE.index(i, DE.required, e)))(...components) as any\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: TaskDecoder<unknown, A[K]> }\n): TaskDecoder<unknown, A> => pipe(UnknownArray as any, compose(fromTuple(...components))) as any\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const union: <MS extends readonly [TaskDecoder<any, any>, ...Array<TaskDecoder<any, any>>]>(\n  ...members: MS\n) => TaskDecoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =\n  /*#__PURE__*/\n  K.union(M)((i, e) => FS.of(DE.member(i, e)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const intersect: <IB, B>(\n  right: TaskDecoder<IB, B>\n) => <IA, A>(left: TaskDecoder<IA, A>) => TaskDecoder<IA & IB, A & B> =\n  /*#__PURE__*/\n  K.intersect(M)\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromSum =\n  <T extends string>(tag: T) =>\n  <MS extends Record<string, TaskDecoder<any, any>>>(\n    members: MS\n  ): TaskDecoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =>\n    K.fromSum(M)((tag, value, keys) =>\n      FS.of(\n        DE.key(\n          tag,\n          DE.required,\n          error(value, keys.length === 0 ? 'never' : keys.map((k) => JSON.stringify(k)).join(' | '))\n        )\n      )\n    )(tag)(members)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const sum =\n  <T extends string>(tag: T) =>\n  <A>(members: { [K in keyof A]: TaskDecoder<unknown, A[K] & Record<T, K>> }): TaskDecoder<unknown, A[keyof A]> =>\n    pipe(UnknownRecord as any, compose(fromSum(tag)(members)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const lazy: <I, A>(id: string, f: () => TaskDecoder<I, A>) => TaskDecoder<I, A> =\n  /*#__PURE__*/\n  K.lazy(M)((id, e) => FS.of(DE.lazy(id, e)))\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const readonly: <I, A>(decoder: TaskDecoder<I, A>) => TaskDecoder<I, Readonly<A>> = identity\n\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n\nconst map_: Functor2<URI>['map'] = (fa, f) => pipe(fa, map(f))\n\nconst alt_: Alt2<URI>['alt'] = (me, that) => pipe(me, alt(that))\n\nconst compose_: Category2<URI>['compose'] = (ab, la) => pipe(la, compose(ab))\n\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n\n/**\n * @category Functor\n * @since 2.2.7\n */\nexport const map: <A, B>(f: (a: A) => B) => <I>(fa: TaskDecoder<I, A>) => TaskDecoder<I, B> =\n  /*#__PURE__*/\n  K.map(M)\n\n/**\n * @category Alt\n * @since 2.2.7\n */\nexport const alt: <I, A>(that: () => TaskDecoder<I, A>) => (me: TaskDecoder<I, A>) => TaskDecoder<I, A> =\n  /*#__PURE__*/\n  K.alt(M)\n\n/**\n * @category Semigroupoid\n * @since 2.2.8\n */\nexport const compose: <A, B>(to: TaskDecoder<A, B>) => <I>(from: TaskDecoder<I, A>) => TaskDecoder<I, B> =\n  /*#__PURE__*/\n  K.compose(M)\n\n/**\n * @category Category\n * @since 2.2.8\n */\nexport const id: <A>() => TaskDecoder<A, A> =\n  /*#__PURE__*/\n  K.id(M)\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport const URI = 'io-ts/TaskDecoder'\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind2<E, A> {\n    readonly [URI]: TaskDecoder<E, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Functor: Functor2<URI> = {\n  URI,\n  map: map_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Alt: Alt2<URI> = {\n  URI,\n  map: map_,\n  alt: alt_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Category: Category2<URI> = {\n  URI,\n  compose: compose_,\n  id\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Schemable: S.Schemable2C<URI, unknown> = {\n  URI,\n  literal,\n  string,\n  number,\n  boolean,\n  nullable,\n  type,\n  struct,\n  partial,\n  record,\n  array,\n  tuple: tuple as S.Schemable2C<URI, unknown>['tuple'],\n  intersect,\n  sum,\n  lazy,\n  readonly\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnknownContainers: S.WithUnknownContainers2C<URI, unknown> = {\n  UnknownArray,\n  UnknownRecord\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnion: S.WithUnion2C<URI, unknown> = {\n  union: union as S.WithUnion2C<URI, unknown>['union']\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithRefine: S.WithRefine2C<URI, unknown> = {\n  refine: refine as S.WithRefine2C<URI, unknown>['refine']\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.7\n */\nexport type TypeOf<KTD> = K.TypeOf<TE.URI, KTD>\n\n/**\n * @since 2.2.8\n */\nexport type InputOf<KTD> = K.InputOf<TE.URI, KTD>\n\n/**\n * @since 2.2.7\n */\nexport const draw: (e: DecodeError) => string = D.draw\n\n/**\n * @internal\n */\nexport const stringify: <A>(e: TE.TaskEither<DecodeError, A>) => T.Task<string> = TE.fold(\n  (e) => T.of(draw(e)),\n  (a) => T.of(JSON.stringify(a, null, 2))\n)\n\n### Source File Dependency Files Content\n### Dependency File: DecodeError.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Semigroup } from 'fp-ts/lib/Semigroup'\n\nimport * as FS from './FreeSemigroup'\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Leaf<E> {\n  readonly _tag: 'Leaf'\n  readonly actual: unknown\n  readonly error: E\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\n// eslint-disable-next-line @typescript-eslint/prefer-as-const\nexport const required: 'required' = 'required'\n\n/**\n * @category model\n * @since 2.2.7\n */\n// eslint-disable-next-line @typescript-eslint/prefer-as-const\nexport const optional: 'optional' = 'optional'\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport type Kind = 'required' | 'optional'\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Key<E> {\n  readonly _tag: 'Key'\n  readonly key: string\n  readonly kind: Kind\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Index<E> {\n  readonly _tag: 'Index'\n  readonly index: number\n  readonly kind: Kind\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Member<E> {\n  readonly _tag: 'Member'\n  readonly index: number\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Lazy<E> {\n  readonly _tag: 'Lazy'\n  readonly id: string\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.9\n */\nexport interface Wrap<E> {\n  readonly _tag: 'Wrap'\n  readonly error: E\n  readonly errors: FS.FreeSemigroup<DecodeError<E>>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport type DecodeError<E> = Leaf<E> | Key<E> | Index<E> | Member<E> | Lazy<E> | Wrap<E>\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const leaf = <E>(actual: unknown, error: E): DecodeError<E> => ({ _tag: 'Leaf', actual, error })\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const key = <E>(key: string, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Key',\n  key,\n  kind,\n  errors\n})\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const index = <E>(index: number, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Index',\n  index,\n  kind,\n  errors\n})\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const member = <E>(index: number, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Member',\n  index,\n  errors\n})\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const lazy = <E>(id: string, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Lazy',\n  id,\n  errors\n})\n\n/**\n * @category constructors\n * @since 2.2.9\n */\nexport const wrap = <E>(error: E, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Wrap',\n  error,\n  errors\n})\n\n/**\n * @category destructors\n * @since 2.2.7\n */\nexport const fold = <E, R>(patterns: {\n  Leaf: (input: unknown, error: E) => R\n  Key: (key: string, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Index: (index: number, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Member: (index: number, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Lazy: (id: string, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Wrap: (error: E, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n}): ((e: DecodeError<E>) => R) => {\n  const f = (e: DecodeError<E>): R => {\n    switch (e._tag) {\n      case 'Leaf':\n        return patterns.Leaf(e.actual, e.error)\n      case 'Key':\n        return patterns.Key(e.key, e.kind, e.errors)\n      case 'Index':\n        return patterns.Index(e.index, e.kind, e.errors)\n      case 'Member':\n        return patterns.Member(e.index, e.errors)\n      case 'Lazy':\n        return patterns.Lazy(e.id, e.errors)\n      case 'Wrap':\n        return patterns.Wrap(e.error, e.errors)\n    }\n  }\n  return f\n}\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport function getSemigroup<E = never>(): Semigroup<FS.FreeSemigroup<DecodeError<E>>> {\n  return FS.getSemigroup()\n}\n\n\n### Dependency File: Decoder.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Alt2, Alt2C } from 'fp-ts/lib/Alt'\nimport { Bifunctor2 } from 'fp-ts/lib/Bifunctor'\nimport { Category2 } from 'fp-ts/lib/Category'\nimport * as E from 'fp-ts/lib/Either'\nimport { identity, Refinement } from 'fp-ts/lib/function'\nimport { Functor2 } from 'fp-ts/lib/Functor'\nimport { MonadThrow2C } from 'fp-ts/lib/MonadThrow'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as DE from './DecodeError'\nimport * as FS from './FreeSemigroup'\nimport * as G from './Guard'\nimport * as K from './Kleisli'\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// Kleisli config\n// -------------------------------------------------------------------------------------\n\n/**\n * @internal\n */\nexport const SE =\n  /*#__PURE__*/\n  DE.getSemigroup<string>()\n\n/**\n * @internal\n */\nexport const ap = <A, B>(\n  fab: E.Either<DecodeError, (a: A) => B>,\n  fa: E.Either<DecodeError, A>\n): E.Either<DecodeError, B> =>\n  E.isLeft(fab)\n    ? E.isLeft(fa)\n      ? E.left(SE.concat(fab.left, fa.left))\n      : fab\n    : E.isLeft(fa)\n    ? fa\n    : E.right(fab.right(fa.right))\n\nconst M: MonadThrow2C<E.URI, DecodeError> & Bifunctor2<E.URI> & Alt2C<E.URI, DecodeError> = {\n  URI: E.URI,\n  _E: undefined as any,\n  map: (fa, f) => pipe(fa, E.map(f)),\n  ap,\n  of: E.right,\n  chain: (ma, f) => pipe(ma, E.chain(f)),\n  throwError: E.left,\n  bimap: (fa, f, g) => pipe(fa, E.bimap(f, g)),\n  mapLeft: (fa, f) => pipe(fa, E.mapLeft(f)),\n  alt: (me, that) => {\n    if (E.isRight(me)) {\n      return me\n    }\n    const ea = that()\n    return E.isLeft(ea) ? E.left(SE.concat(me.left, ea.left)) : ea\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.8\n */\nexport interface Decoder<I, A> extends K.Kleisli<E.URI, I, DecodeError, A> {}\n\n// -------------------------------------------------------------------------------------\n// DecodeError\n// -------------------------------------------------------------------------------------\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport type DecodeError = FS.FreeSemigroup<DE.DecodeError<string>>\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const error = (actual: unknown, message: string): DecodeError => FS.of(DE.leaf(actual, message))\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const success: <A>(a: A) => E.Either<DecodeError, A> = E.right\n\n/**\n * @category DecodeError\n * @since 2.2.7\n */\nexport const failure = <A = never>(actual: unknown, message: string): E.Either<DecodeError, A> =>\n  E.left(error(actual, message))\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.8\n */\nexport const fromRefinement = <I, A extends I>(refinement: Refinement<I, A>, expected: string): Decoder<I, A> =>\n  K.fromRefinement(M)(refinement, (u) => error(u, expected))\n\n/**\n * @category constructors\n * @since 2.2.8\n */\nexport const fromGuard = <I, A extends I>(guard: G.Guard<I, A>, expected: string): Decoder<I, A> =>\n  fromRefinement(guard.is, expected)\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n) => Decoder<unknown, A[number]> =\n  /*#__PURE__*/\n  K.literal(M)((u, values) => error(u, values.map((value) => JSON.stringify(value)).join(' | ')))\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const string: Decoder<unknown, string> =\n  /*#__PURE__*/\n  fromGuard(G.string, 'string')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const number: Decoder<unknown, number> =\n  /*#__PURE__*/\n  fromGuard(G.number, 'number')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const boolean: Decoder<unknown, boolean> =\n  /*#__PURE__*/\n  fromGuard(G.boolean, 'boolean')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const UnknownArray: Decoder<unknown, Array<unknown>> =\n  /*#__PURE__*/\n  fromGuard(G.UnknownArray, 'Array<unknown>')\n\n/**\n * @category primitives\n * @since 2.2.7\n */\nexport const UnknownRecord: Decoder<unknown, Record<string, unknown>> =\n  /*#__PURE__*/\n  fromGuard(G.UnknownRecord, 'Record<string, unknown>')\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const mapLeftWithInput: <I>(\n  f: (input: I, e: DecodeError) => DecodeError\n) => <A>(decoder: Decoder<I, A>) => Decoder<I, A> =\n  /*#__PURE__*/\n  K.mapLeftWithInput(M)\n\n/**\n * @category combinators\n * @since 2.2.9\n */\nexport const withMessage = <I>(\n  message: (input: I, e: DecodeError) => string\n): (<A>(decoder: Decoder<I, A>) => Decoder<I, A>) =>\n  mapLeftWithInput((input, e) => FS.of(DE.wrap(message(input, e), e)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const refine = <A, B extends A>(\n  refinement: Refinement<A, B>,\n  id: string\n): (<I>(from: Decoder<I, A>) => Decoder<I, B>) => K.refine(M)(refinement, (a) => error(a, id))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const parse: <A, B>(parser: (a: A) => E.Either<DecodeError, B>) => <I>(from: Decoder<I, A>) => Decoder<I, B> =\n  /*#__PURE__*/\n  K.parse(M)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const nullable: <I, A>(or: Decoder<I, A>) => Decoder<null | I, null | A> =\n  /*#__PURE__*/\n  K.nullable(M)((u, e) => FS.concat(FS.of(DE.member(0, error(u, 'null'))), FS.of(DE.member(1, e))))\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const fromStruct = <P extends Record<string, Decoder<any, any>>>(\n  properties: P\n): Decoder<{ [K in keyof P]: InputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> =>\n  K.fromStruct(M)((k, e) => FS.of(DE.key(k, DE.required, e)))(properties)\n\n/**\n * Use `fromStruct` instead.\n *\n * @category combinators\n * @since 2.2.8\n * @deprecated\n */\nexport const fromType = fromStruct\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const struct = <A>(properties: { [K in keyof A]: Decoder<unknown, A[K]> }): Decoder<\n  unknown,\n  { [K in keyof A]: A[K] }\n> => pipe(UnknownRecord as any, compose(fromStruct(properties)))\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.7\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromPartial = <P extends Record<string, Decoder<any, any>>>(\n  properties: P\n): Decoder<Partial<{ [K in keyof P]: InputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> =>\n  K.fromPartial(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(properties)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const partial = <A>(properties: { [K in keyof A]: Decoder<unknown, A[K]> }): Decoder<\n  unknown,\n  Partial<{ [K in keyof A]: A[K] }>\n> => pipe(UnknownRecord as any, compose(fromPartial(properties)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromArray = <I, A>(item: Decoder<I, A>): Decoder<Array<I>, Array<A>> =>\n  K.fromArray(M)((i, e) => FS.of(DE.index(i, DE.optional, e)))(item)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const array = <A>(item: Decoder<unknown, A>): Decoder<unknown, Array<A>> =>\n  pipe(UnknownArray, compose(fromArray(item)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromRecord = <I, A>(codomain: Decoder<I, A>): Decoder<Record<string, I>, Record<string, A>> =>\n  K.fromRecord(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(codomain)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const record = <A>(codomain: Decoder<unknown, A>): Decoder<unknown, Record<string, A>> =>\n  pipe(UnknownRecord, compose(fromRecord(codomain)))\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromTuple = <C extends ReadonlyArray<Decoder<any, any>>>(\n  ...components: C\n): Decoder<{ [K in keyof C]: InputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> =>\n  K.fromTuple(M)((i, e) => FS.of(DE.index(i, DE.required, e)))(...components) as any\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Decoder<unknown, A[K]> }\n): Decoder<unknown, A> => pipe(UnknownArray as any, compose(fromTuple(...components))) as any\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const union: <MS extends readonly [Decoder<any, any>, ...Array<Decoder<any, any>>]>(\n  ...members: MS\n) => Decoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =\n  /*#__PURE__*/\n  K.union(M)((i, e) => FS.of(DE.member(i, e)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const intersect: <IB, B>(right: Decoder<IB, B>) => <IA, A>(left: Decoder<IA, A>) => Decoder<IA & IB, A & B> =\n  /*#__PURE__*/\n  K.intersect(M)\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const fromSum =\n  <T extends string>(tag: T) =>\n  <MS extends Record<string, Decoder<any, any>>>(members: MS): Decoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =>\n    K.fromSum(M)((tag, value, keys) =>\n      FS.of(\n        DE.key(\n          tag,\n          DE.required,\n          error(value, keys.length === 0 ? 'never' : keys.map((k) => JSON.stringify(k)).join(' | '))\n        )\n      )\n    )(tag)(members)\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const sum =\n  <T extends string>(tag: T) =>\n  <A>(members: { [K in keyof A]: Decoder<unknown, A[K] & Record<T, K>> }): Decoder<unknown, A[keyof A]> =>\n    pipe(UnknownRecord as any, compose(fromSum(tag)(members)))\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport const lazy: <I, A>(id: string, f: () => Decoder<I, A>) => Decoder<I, A> =\n  /*#__PURE__*/\n  K.lazy(M)((id, e) => FS.of(DE.lazy(id, e)))\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const readonly: <I, A>(decoder: Decoder<I, A>) => Decoder<I, Readonly<A>> = identity\n\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n\nconst map_: Functor2<URI>['map'] = (fa, f) => pipe(fa, map(f))\n\nconst alt_: Alt2<URI>['alt'] = (me, that) => pipe(me, alt(that))\n\nconst compose_: Category2<URI>['compose'] = (ab, la) => pipe(la, compose(ab))\n\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n\n/**\n * @category Functor\n * @since 2.2.7\n */\nexport const map: <A, B>(f: (a: A) => B) => <I>(fa: Decoder<I, A>) => Decoder<I, B> =\n  /*#__PURE__*/\n  K.map(M)\n\n/**\n * @category Alt\n * @since 2.2.7\n */\nexport const alt: <I, A>(that: () => Decoder<I, A>) => (me: Decoder<I, A>) => Decoder<I, A> =\n  /*#__PURE__*/\n  K.alt(M)\n\n/**\n * @category Semigroupoid\n * @since 2.2.8\n */\nexport const compose: <A, B>(to: Decoder<A, B>) => <I>(from: Decoder<I, A>) => Decoder<I, B> =\n  /*#__PURE__*/\n  K.compose(M)\n\n/**\n * @category Category\n * @since 2.2.8\n */\nexport const id: <A>() => Decoder<A, A> =\n  /*#__PURE__*/\n  K.id(M)\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport const URI = 'io-ts/Decoder'\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind2<E, A> {\n    readonly [URI]: Decoder<E, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Functor: Functor2<URI> = {\n  URI,\n  map: map_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Alt: Alt2<URI> = {\n  URI,\n  map: map_,\n  alt: alt_\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Category: Category2<URI> = {\n  URI,\n  compose: compose_,\n  id\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Schemable: S.Schemable2C<URI, unknown> = {\n  URI,\n  literal,\n  string,\n  number,\n  boolean,\n  nullable,\n  type,\n  struct,\n  partial,\n  record,\n  array,\n  tuple: tuple as S.Schemable2C<URI, unknown>['tuple'],\n  intersect,\n  sum,\n  lazy,\n  readonly\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnknownContainers: S.WithUnknownContainers2C<URI, unknown> = {\n  UnknownArray,\n  UnknownRecord\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnion: S.WithUnion2C<URI, unknown> = {\n  union: union as S.WithUnion2C<URI, unknown>['union']\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithRefine: S.WithRefine2C<URI, unknown> = {\n  refine: refine as S.WithRefine2C<URI, unknown>['refine']\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.8\n */\nexport type InputOf<D> = K.InputOf<E.URI, D>\n\n/**\n * @since 2.2.7\n */\nexport type TypeOf<D> = K.TypeOf<E.URI, D>\n\ninterface Tree<A> {\n  readonly value: A\n  readonly forest: ReadonlyArray<Tree<A>>\n}\n\nconst empty: Array<never> = []\n\nconst make = <A>(value: A, forest: ReadonlyArray<Tree<A>> = empty): Tree<A> => ({\n  value,\n  forest\n})\n\nconst drawTree = (tree: Tree<string>): string => tree.value + drawForest('\\n', tree.forest)\n\nconst drawForest = (indentation: string, forest: ReadonlyArray<Tree<string>>): string => {\n  let r = ''\n  const len = forest.length\n  let tree: Tree<string>\n  for (let i = 0; i < len; i++) {\n    tree = forest[i]\n    const isLast = i === len - 1\n    r += indentation + (isLast ? '\u2514' : '\u251c') + '\u2500 ' + tree.value\n    r += drawForest(indentation + (len > 1 && !isLast ? '\u2502  ' : '   '), tree.forest)\n  }\n  return r\n}\n\nconst toTree: (e: DE.DecodeError<string>) => Tree<string> = DE.fold({\n  Leaf: (input, error) => make(`cannot decode ${JSON.stringify(input)}, should be ${error}`),\n  Key: (key, kind, errors) => make(`${kind} property ${JSON.stringify(key)}`, toForest(errors)),\n  Index: (index, kind, errors) => make(`${kind} index ${index}`, toForest(errors)),\n  Member: (index, errors) => make(`member ${index}`, toForest(errors)),\n  Lazy: (id, errors) => make(`lazy type ${id}`, toForest(errors)),\n  Wrap: (error, errors) => make(error, toForest(errors))\n})\n\nconst toForest = (e: DecodeError): ReadonlyArray<Tree<string>> => {\n  const stack = []\n  let focus = e\n  const res = []\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    switch (focus._tag) {\n      case 'Of':\n        {\n          res.push(toTree(focus.value))\n          const tmp = stack.pop()\n          if (tmp === undefined) {\n            return res\n          } else {\n            focus = tmp\n          }\n        }\n        break\n      case 'Concat':\n        stack.push(focus.right)\n        focus = focus.left\n        break\n    }\n  }\n}\n\n/**\n * @since 2.2.7\n */\nexport const draw = (e: DecodeError): string => toForest(e).map(drawTree).join('\\n')\n\n/**\n * @internal\n */\nexport const stringify: <A>(e: E.Either<DecodeError, A>) => string =\n  /*#__PURE__*/\n  E.fold(draw, (a) => JSON.stringify(a, null, 2))\n\n\n### Dependency File: FreeSemigroup.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Semigroup } from 'fp-ts/lib/Semigroup'\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Of<A> {\n  readonly _tag: 'Of'\n  readonly value: A\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Concat<A> {\n  readonly _tag: 'Concat'\n  readonly left: FreeSemigroup<A>\n  readonly right: FreeSemigroup<A>\n}\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport type FreeSemigroup<A> = Of<A> | Concat<A>\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const of = <A>(a: A): FreeSemigroup<A> => ({ _tag: 'Of', value: a })\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport const concat = <A>(left: FreeSemigroup<A>, right: FreeSemigroup<A>): FreeSemigroup<A> => ({\n  _tag: 'Concat',\n  left,\n  right\n})\n\n/**\n * @category destructors\n * @since 2.2.7\n */\nexport const fold =\n  <A, R>(onOf: (value: A) => R, onConcat: (left: FreeSemigroup<A>, right: FreeSemigroup<A>) => R) =>\n  (f: FreeSemigroup<A>): R => {\n    switch (f._tag) {\n      case 'Of':\n        return onOf(f.value)\n      case 'Concat':\n        return onConcat(f.left, f.right)\n    }\n  }\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport function getSemigroup<A = never>(): Semigroup<FreeSemigroup<A>> {\n  return { concat }\n}\n\n\n### Dependency File: Guard.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { identity, Refinement } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.8\n */\nexport interface Guard<I, A extends I> {\n  is: (i: I) => i is A\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.2\n */\nexport type TypeOf<G> = G extends Guard<any, infer A> ? A : never\n\n/**\n * @since 2.2.8\n */\nexport type InputOf<G> = G extends Guard<infer I, any> ? I : never\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.0\n */\nexport const literal = <A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n): Guard<unknown, A[number]> => ({\n  is: (u: unknown): u is A[number] => values.findIndex((a) => a === u) !== -1\n})\n\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const string: Guard<unknown, string> = {\n  is: (u: unknown): u is string => typeof u === 'string'\n}\n\n/**\n * Note: `NaN` is excluded.\n *\n * @category primitives\n * @since 2.2.0\n */\nexport const number: Guard<unknown, number> = {\n  is: (u: unknown): u is number => typeof u === 'number' && !isNaN(u)\n}\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const boolean: Guard<unknown, boolean> = {\n  is: (u: unknown): u is boolean => typeof u === 'boolean'\n}\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const UnknownArray: Guard<unknown, Array<unknown>> = {\n  is: Array.isArray\n}\n\n/**\n * @category primitives\n * @since 2.2.0\n */\nexport const UnknownRecord: Guard<unknown, Record<string, unknown>> = {\n  is: (u: unknown): u is Record<string, unknown> => u !== null && typeof u === 'object' && !Array.isArray(u)\n}\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const refine =\n  <I, A extends I, B extends A>(refinement: Refinement<A, B>) =>\n  (from: Guard<I, A>): Guard<I, B> => ({\n    is: (i: I): i is B => from.is(i) && refinement(i)\n  })\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const nullable = <I, A extends I>(or: Guard<I, A>): Guard<null | I, null | A> => ({\n  is: (i): i is null | A => i === null || or.is(i)\n})\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const struct = <A>(properties: { [K in keyof A]: Guard<unknown, A[K]> }): Guard<\n  unknown,\n  { [K in keyof A]: A[K] }\n> =>\n  pipe(\n    UnknownRecord,\n    refine(\n      (\n        r\n      ): r is {\n        [K in keyof A]: A[K]\n      } => {\n        for (const k in properties) {\n          if (!(k in r) || !properties[k].is(r[k])) {\n            return false\n          }\n        }\n        return true\n      }\n    )\n  )\n\n/**\n * Use `struct` instead.\n *\n * @category combinators\n * @since 2.2.0\n * @deprecated\n */\nexport const type = struct\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const partial = <A>(properties: { [K in keyof A]: Guard<unknown, A[K]> }): Guard<\n  unknown,\n  Partial<{ [K in keyof A]: A[K] }>\n> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is Partial<A> => {\n      for (const k in properties) {\n        const v = r[k]\n        if (v !== undefined && !properties[k].is(v)) {\n          return false\n        }\n      }\n      return true\n    })\n  )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const array = <A>(item: Guard<unknown, A>): Guard<unknown, Array<A>> =>\n  pipe(\n    UnknownArray,\n    refine((us): us is Array<A> => us.every(item.is))\n  )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const record = <A>(codomain: Guard<unknown, A>): Guard<unknown, Record<string, A>> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is Record<string, A> => {\n      for (const k in r) {\n        if (!codomain.is(r[k])) {\n          return false\n        }\n      }\n      return true\n    })\n  )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, A> => ({\n  is: (u): u is A => Array.isArray(u) && u.length === components.length && components.every((c, i) => c.is(u[i]))\n})\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const intersect =\n  <B>(right: Guard<unknown, B>) =>\n  <A>(left: Guard<unknown, A>): Guard<unknown, A & B> => ({\n    is: (u: unknown): u is A & B => left.is(u) && right.is(u)\n  })\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const union = <A extends readonly [unknown, ...Array<unknown>]>(\n  ...members: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, A[number]> => ({\n  is: (u: unknown): u is A | A[number] => members.some((m) => m.is(u))\n})\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const sum =\n  <T extends string>(tag: T) =>\n  <A>(members: { [K in keyof A]: Guard<unknown, A[K] & Record<T, K>> }): Guard<unknown, A[keyof A]> =>\n    pipe(\n      UnknownRecord,\n      refine((r): r is any => {\n        const v = r[tag] as keyof A\n        if (v in members) {\n          return members[v].is(r)\n        }\n        return false\n      })\n    )\n\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport const lazy = <A>(f: () => Guard<unknown, A>): Guard<unknown, A> => {\n  const get = S.memoize<void, Guard<unknown, A>>(f)\n  return {\n    is: (u: unknown): u is A => get().is(u)\n  }\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport const readonly: <I, A extends I>(guard: Guard<I, A>) => Guard<I, Readonly<A>> = identity\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const alt =\n  <I, A extends I>(that: () => Guard<I, A>) =>\n  (me: Guard<I, A>): Guard<I, A> => ({\n    is: (i): i is A => me.is(i) || that().is(i)\n  })\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const zero = <I, A extends I>(): Guard<I, A> => ({\n  is: (_): _ is A => false\n})\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const compose =\n  <I, A extends I, B extends A>(to: Guard<A, B>) =>\n  (from: Guard<I, A>): Guard<I, B> => ({\n    is: (i): i is B => from.is(i) && to.is(i)\n  })\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport const id = <A>(): Guard<A, A> => ({\n  is: (_): _ is A => true\n})\n\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.2.0\n */\nexport const URI = 'io-ts/Guard'\n\n/**\n * @category instances\n * @since 2.2.0\n */\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/lib/HKT' {\n  interface URItoKind<A> {\n    readonly [URI]: Guard<unknown, A>\n  }\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const Schemable: S.Schemable1<URI> = {\n  URI,\n  literal,\n  string,\n  number,\n  boolean,\n  nullable,\n  type,\n  struct,\n  partial,\n  record,\n  array,\n  tuple: tuple as S.Schemable1<URI>['tuple'],\n  intersect,\n  sum,\n  lazy: (_, f) => lazy(f),\n  readonly\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnknownContainers: S.WithUnknownContainers1<URI> = {\n  UnknownArray,\n  UnknownRecord\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithUnion: S.WithUnion1<URI> = {\n  union: union as S.WithUnion1<URI>['union']\n}\n\n/**\n * @category instances\n * @since 2.2.8\n */\nexport const WithRefine: S.WithRefine1<URI> = {\n  refine: refine as S.WithRefine1<URI>['refine']\n}\n\n\n### Dependency File: Kleisli.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.7\n */\nimport { Alt2C } from 'fp-ts/lib/Alt'\nimport { Applicative2C } from 'fp-ts/lib/Applicative'\nimport { Apply2C } from 'fp-ts/lib/Apply'\nimport { Bifunctor2 } from 'fp-ts/lib/Bifunctor'\nimport * as E from 'fp-ts/lib/Either'\nimport { Lazy, Refinement } from 'fp-ts/lib/function'\nimport { Functor2C } from 'fp-ts/lib/Functor'\nimport { Kind2, URIS2 } from 'fp-ts/lib/HKT'\nimport { Monad2C } from 'fp-ts/lib/Monad'\nimport { MonadThrow2C } from 'fp-ts/lib/MonadThrow'\n\nimport * as G from './Guard'\nimport * as S from './Schemable'\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category model\n * @since 2.2.7\n */\nexport interface Kleisli<M extends URIS2, I, E, A> {\n  readonly decode: (i: I) => Kind2<M, E, A>\n}\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport function fromRefinement<M extends URIS2, E>(\n  M: MonadThrow2C<M, E>\n): <I, A extends I>(refinement: Refinement<I, A>, onError: (i: I) => E) => Kleisli<M, I, E, A> {\n  return (refinement, onError) => ({\n    decode: (i) => (refinement(i) ? M.of(i) : M.throwError(onError(i)))\n  })\n}\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport function literal<M extends URIS2, E>(\n  M: MonadThrow2C<M, E>\n): <I>(\n  onError: (i: I, values: readonly [S.Literal, ...ReadonlyArray<S.Literal>]) => E\n) => <A extends readonly [L, ...ReadonlyArray<L>], L extends S.Literal = S.Literal>(\n  ...values: A\n) => Kleisli<M, I, E, A[number]> {\n  return (onError) =>\n    <A extends readonly [S.Literal, ...Array<S.Literal>]>(...values: A) => ({\n      decode: (i) => (G.literal(...values).is(i) ? M.of<A[number]>(i) : M.throwError(onError(i, values)))\n    })\n}\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function mapLeftWithInput<M extends URIS2>(\n  M: Bifunctor2<M>\n): <I, E>(f: (i: I, e: E) => E) => <A>(decoder: Kleisli<M, I, E, A>) => Kleisli<M, I, E, A> {\n  return (f) => (decoder) => ({\n    decode: (i) => M.mapLeft(decoder.decode(i), (e) => f(i, e))\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function refine<M extends URIS2, E>(\n  M: MonadThrow2C<M, E> & Bifunctor2<M>\n): <A, B extends A>(\n  refinement: (a: A) => a is B,\n  onError: (a: A) => E\n) => <I>(from: Kleisli<M, I, E, A>) => Kleisli<M, I, E, B> {\n  return (refinement, onError) => (from) => compose(M)(fromRefinement(M)(refinement, onError))(from)\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function parse<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(decode: (a: A) => Kind2<M, E, B>) => <I>(from: Kleisli<M, I, E, A>) => Kleisli<M, I, E, B> {\n  return (decode) => (from) => compose(M)({ decode })(from)\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function nullable<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): <I>(onError: (i: I, e: E) => E) => <A>(or: Kleisli<M, I, E, A>) => Kleisli<M, null | I, E, null | A> {\n  return <I>(onError: (i: I, e: E) => E) =>\n    <A>(or: Kleisli<M, I, E, A>): Kleisli<M, null | I, E, null | A> => ({\n      decode: (i) =>\n        i === null\n          ? M.of<null | A>(null)\n          : M.bimap(\n              or.decode(i),\n              (e) => onError(i, e),\n              (a): A | null => a\n            )\n    })\n}\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function fromStruct<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onPropertyError: (key: string, e: E) => E\n) => <P extends Record<string, Kleisli<M, any, E, any>>>(\n  properties: P\n) => Kleisli<M, { [K in keyof P]: InputOf<M, P[K]> }, E, { [K in keyof P]: TypeOf<M, P[K]> }> {\n  const traverse = traverseRecordWithIndex(M)\n  return (onPropertyError) => (properties) => ({\n    decode: (i) =>\n      traverse(properties as Record<string, Kleisli<M, unknown, E, unknown>>, (key, decoder) =>\n        M.mapLeft(decoder.decode(i[key]), (e) => onPropertyError(key, e))\n      ) as any\n  })\n}\n\n/**\n * Use `fromStruct` instead.\n *\n * @category combinators\n * @since 2.2.7\n * @deprecated\n */\nexport const fromType = fromStruct\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromPartial<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onPropertyError: (key: string, e: E) => E\n) => <P extends Record<string, Kleisli<M, any, E, any>>>(\n  properties: P\n) => Kleisli<M, Partial<{ [K in keyof P]: InputOf<M, P[K]> }>, E, Partial<{ [K in keyof P]: TypeOf<M, P[K]> }>> {\n  const traverse = traverseRecordWithIndex(M)\n  const undefinedProperty = M.of<E.Either<void, unknown>>(E.right(undefined))\n  const skipProperty = M.of<E.Either<void, unknown>>(E.left(undefined))\n  return (onPropertyError) => (properties) => ({\n    decode: (i) =>\n      M.map(\n        traverse(properties as Record<string, Kleisli<M, unknown, E, unknown>>, (key, decoder) => {\n          const ikey = i[key]\n          if (ikey === undefined) {\n            return key in i\n              ? // don't strip undefined properties\n                undefinedProperty\n              : // don't add missing properties\n                skipProperty\n          }\n          return M.bimap(\n            decoder.decode(ikey),\n            (e) => onPropertyError(key, e),\n            (a) => E.right<void, unknown>(a)\n          )\n        }),\n        compactRecord\n      ) as any\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromArray<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (onItemError: (index: number, e: E) => E) => <I, A>(item: Kleisli<M, I, E, A>) => Kleisli<M, Array<I>, E, Array<A>> {\n  const traverse = traverseArrayWithIndex(M)\n  return (onItemError) => (item) => ({\n    decode: (is) => traverse(is, (index, i) => M.mapLeft(item.decode(i), (e) => onItemError(index, e)))\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromRecord<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onKeyError: (key: string, e: E) => E\n) => <I, A>(codomain: Kleisli<M, I, E, A>) => Kleisli<M, Record<string, I>, E, Record<string, A>> {\n  const traverse = traverseRecordWithIndex(M)\n  return (onKeyError) => (codomain) => ({\n    decode: (ir) => traverse(ir, (key, i) => M.mapLeft(codomain.decode(i), (e) => onKeyError(key, e)))\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromTuple<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onIndexError: (index: number, e: E) => E\n) => <C extends ReadonlyArray<Kleisli<M, any, E, any>>>(\n  ...components: C\n) => Kleisli<M, { [K in keyof C]: InputOf<M, C[K]> }, E, { [K in keyof C]: TypeOf<M, C[K]> }> {\n  const traverse = traverseArrayWithIndex(M)\n  return (onIndexError) =>\n    (...components) => ({\n      decode: (is) =>\n        traverse(components as unknown as Array<Kleisli<M, unknown, E, unknown>>, (index, decoder) =>\n          M.mapLeft(decoder.decode(is[index]), (e) => onIndexError(index, e))\n        ) as any\n    })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function union<M extends URIS2, E>(\n  M: Alt2C<M, E> & Bifunctor2<M>\n): (\n  onMemberError: (index: number, e: E) => E\n) => <MS extends readonly [Kleisli<M, any, E, any>, ...Array<Kleisli<M, any, E, any>>]>(\n  ...members: MS\n) => Kleisli<M, InputOf<M, MS[keyof MS]>, E, TypeOf<M, MS[keyof MS]>> {\n  return (onMemberError) =>\n    <MS extends readonly [Kleisli<M, any, E, any>, ...Array<Kleisli<M, any, E, any>>]>(...members: MS) => ({\n      decode: (i) => {\n        let out: Kind2<M, E, TypeOf<M, MS[keyof MS]>> = M.mapLeft(members[0].decode(i), (e) => onMemberError(0, e))\n        for (let index = 1; index < members.length; index++) {\n          out = M.alt(out, () => M.mapLeft(members[index].decode(i), (e) => onMemberError(index, e)))\n        }\n        return out\n      }\n    })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function intersect<M extends URIS2, E>(\n  M: Apply2C<M, E>\n): <IB, B>(right: Kleisli<M, IB, E, B>) => <IA, A>(left: Kleisli<M, IA, E, A>) => Kleisli<M, IA & IB, E, A & B> {\n  return <IB, B>(right: Kleisli<M, IB, E, B>) =>\n    <IA, A>(left: Kleisli<M, IA, E, A>): Kleisli<M, IA & IB, E, A & B> => ({\n      decode: (i) =>\n        M.ap(\n          M.map(left.decode(i), (a: A) => (b: B) => S.intersect_(a, b)),\n          right.decode(i)\n        )\n    })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromSum<M extends URIS2, E>(\n  M: MonadThrow2C<M, E>\n): (\n  onTagError: (tag: string, value: unknown, tags: ReadonlyArray<string>) => E\n) => <T extends string>(\n  tag: T\n) => <MS extends Record<string, Kleisli<M, any, E, any>>>(\n  members: MS\n) => Kleisli<M, InputOf<M, MS[keyof MS]>, E, TypeOf<M, MS[keyof MS]>> {\n  return (onTagError) =>\n    (tag) =>\n    <I extends Record<string, unknown>, A>(members: { [K in keyof A]: Kleisli<M, I, E, A[K]> }): Kleisli<\n      M,\n      I,\n      E,\n      A[keyof A]\n    > => {\n      const keys = Object.keys(members)\n      return {\n        decode: (ir) => {\n          const v: any = ir[tag]\n          if (Object.prototype.hasOwnProperty.call(members, v)) {\n            return (members as any)[v].decode(ir)\n          }\n          return M.throwError(onTagError(tag, v, keys))\n        }\n      }\n    }\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function lazy<M extends URIS2>(\n  M: Bifunctor2<M>\n): <E>(onError: (id: string, e: E) => E) => <I, A>(id: string, f: () => Kleisli<M, I, E, A>) => Kleisli<M, I, E, A> {\n  return <E>(onError: (id: string, e: E) => E) =>\n    <I, A>(id: string, f: () => Kleisli<M, I, E, A>): Kleisli<M, I, E, A> => {\n      const get = S.memoize<void, Kleisli<M, I, E, A>>(f)\n      return {\n        decode: (u) => M.mapLeft(get().decode(u), (e) => onError(id, e))\n      }\n    }\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function compose<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(ab: Kleisli<M, A, E, B>) => <I>(ia: Kleisli<M, I, E, A>) => Kleisli<M, I, E, B> {\n  return (ab) => (ia) => ({\n    decode: (i) => M.chain(ia.decode(i), ab.decode)\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport function id<M extends URIS2, E>(M: Applicative2C<M, E>): <A>() => Kleisli<M, A, E, A> {\n  return () => ({\n    decode: M.of\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function map<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <A, B>(f: (a: A) => B) => <I>(ia: Kleisli<F, I, E, A>) => Kleisli<F, I, E, B> {\n  return (f) => (ia) => ({\n    decode: (i) => F.map(ia.decode(i), f)\n  })\n}\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function alt<F extends URIS2, E>(\n  A: Alt2C<F, E>\n): <I, A>(that: Lazy<Kleisli<F, I, E, A>>) => (me: Kleisli<F, I, E, A>) => Kleisli<F, I, E, A> {\n  return (that) => (me) => ({\n    decode: (i) => A.alt(me.decode(i), () => that().decode(i))\n  })\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst traverseArrayWithIndex =\n  <M extends URIS2, E>(M: Applicative2C<M, E>) =>\n  <A, B>(as: Array<A>, f: (i: number, a: A) => Kind2<M, E, B>): Kind2<M, E, Array<B>> => {\n    return as.reduce(\n      (mbs, a, i) =>\n        M.ap(\n          M.map(mbs, (bs) => (b: B) => {\n            bs.push(b)\n            return bs\n          }),\n          f(i, a)\n        ),\n      M.of<Array<B>>([])\n    )\n  }\n\nconst traverseRecordWithIndex =\n  <M extends URIS2, E>(M: Applicative2C<M, E>) =>\n  <A, B>(r: Record<string, A>, f: (k: string, a: A) => Kind2<M, E, B>): Kind2<M, E, Record<string, B>> => {\n    const ks = Object.keys(r)\n    if (ks.length === 0) {\n      return M.of({})\n    }\n    let fr: Kind2<M, E, Record<string, B>> = M.of({})\n    for (const key of ks) {\n      fr = M.ap(\n        M.map(fr, (r) => (b: B) => {\n          r[key] = b\n          return r\n        }),\n        f(key, r[key])\n      )\n    }\n    return fr\n  }\n\nconst compactRecord = <A>(r: Record<string, E.Either<void, A>>): Record<string, A> => {\n  const out: Record<string, A> = {}\n  for (const k in r) {\n    const rk = r[k]\n    if (E.isRight(rk)) {\n      out[k] = rk.right\n    }\n  }\n  return out\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.7\n */\nexport type TypeOf<M extends URIS2, KD> = KD extends Kleisli<M, any, any, infer A> ? A : never\n\n/**\n * @since 2.2.7\n */\nexport type InputOf<M extends URIS2, KD> = KD extends Kleisli<M, infer I, any, any> ? I : never\n\n\n### Dependency File: Schemable.ts\n/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community, see these tracking\n * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.2.0\n */\nimport { Refinement } from 'fp-ts/lib/function'\nimport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT'\n\n/**\n * @since 2.2.0\n */\nexport type Literal = string | number | boolean | null\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable<S> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => HKT<S, A[number]>\n  readonly string: HKT<S, string>\n  readonly number: HKT<S, number>\n  readonly boolean: HKT<S, boolean>\n  readonly nullable: <A>(or: HKT<S, A>) => HKT<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: HKT<S, A>) => HKT<S, Record<string, A>>\n  readonly array: <A>(item: HKT<S, A>) => HKT<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: HKT<S, A[K]> }) => HKT<S, A>\n  readonly intersect: <B>(right: HKT<S, B>) => <A>(left: HKT<S, A>) => HKT<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: HKT<S, A[K] & Record<T, K>> }) => HKT<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => HKT<S, A>) => HKT<S, A>\n  readonly readonly: <A>(sa: HKT<S, A>) => HKT<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface Schemable1<S extends URIS> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind<S, A[number]>\n  readonly string: Kind<S, string>\n  readonly number: Kind<S, number>\n  readonly boolean: Kind<S, boolean>\n  readonly nullable: <A>(or: Kind<S, A>) => Kind<S, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, Partial<{ [K in keyof A]: A[K] }>>\n  readonly record: <A>(codomain: Kind<S, A>) => Kind<S, Record<string, A>>\n  readonly array: <A>(item: Kind<S, A>) => Kind<S, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Kind<S, A[K]> }) => Kind<S, A>\n  readonly intersect: <B>(right: Kind<S, B>) => <A>(left: Kind<S, A>) => Kind<S, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind<S, A[K] & Record<T, K>> }) => Kind<S, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind<S, A>) => Kind<S, A>\n  readonly readonly: <A>(sa: Kind<S, A>) => Kind<S, Readonly<A>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface Schemable2C<S extends URIS2, E> {\n  readonly URI: S\n  readonly literal: <A extends readonly [L, ...ReadonlyArray<L>], L extends Literal = Literal>(\n    ...values: A\n  ) => Kind2<S, E, A[number]>\n  readonly string: Kind2<S, E, string>\n  readonly number: Kind2<S, E, number>\n  readonly boolean: Kind2<S, E, boolean>\n  readonly nullable: <A>(or: Kind2<S, E, A>) => Kind2<S, E, null | A>\n  /** @deprecated */\n  readonly type: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly struct: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<S, E, { [K in keyof A]: A[K] }>\n  readonly partial: <A>(properties: { [K in keyof A]: Kind2<S, E, A[K]> }) => Kind2<\n    S,\n    E,\n    Partial<{ [K in keyof A]: A[K] }>\n  >\n  readonly record: <A>(codomain: Kind2<S, E, A>) => Kind2<S, E, Record<string, A>>\n  readonly array: <A>(item: Kind2<S, E, A>) => Kind2<S, E, Array<A>>\n  readonly tuple: <A extends ReadonlyArray<unknown>>(\n    ...components: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A>\n  readonly intersect: <B>(right: Kind2<S, E, B>) => <A>(left: Kind2<S, E, A>) => Kind2<S, E, A & B>\n  readonly sum: <T extends string>(\n    tag: T\n  ) => <A>(members: { [K in keyof A]: Kind2<S, E, A[K] & Record<T, K>> }) => Kind2<S, E, A[keyof A]>\n  readonly lazy: <A>(id: string, f: () => Kind2<S, E, A>) => Kind2<S, E, A>\n  readonly readonly: <A>(sa: Kind2<S, E, A>) => Kind2<S, E, Readonly<A>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers<S> {\n  readonly UnknownArray: HKT<S, Array<unknown>>\n  readonly UnknownRecord: HKT<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnknownContainers1<S extends URIS> {\n  readonly UnknownArray: Kind<S, Array<unknown>>\n  readonly UnknownRecord: Kind<S, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnknownContainers2C<S extends URIS2, E> {\n  readonly UnknownArray: Kind2<S, E, Array<unknown>>\n  readonly UnknownRecord: Kind2<S, E, Record<string, unknown>>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion<S> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: HKT<S, A[K]> }\n  ) => HKT<S, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithUnion1<S extends URIS> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind<S, A[K]> }\n  ) => Kind<S, A[number]>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithUnion2C<S extends URIS2, E> {\n  readonly union: <A extends readonly [unknown, ...Array<unknown>]>(\n    ...members: { [K in keyof A]: Kind2<S, E, A[K]> }\n  ) => Kind2<S, E, A[number]>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine<S> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: HKT<S, A>) => HKT<S, B>\n}\n\n/**\n * @since 2.2.3\n */\nexport interface WithRefine1<S extends URIS> {\n  readonly refine: <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Kind<S, A>) => Kind<S, B>\n}\n\n/**\n * @since 2.2.8\n */\nexport interface WithRefine2C<S extends URIS2, E> {\n  readonly refine: <A, B extends A>(\n    refinement: Refinement<A, B>,\n    id: string\n  ) => (from: Kind2<S, E, A>) => Kind2<S, E, B>\n}\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst typeOf = (x: unknown): string => (x === null ? 'null' : typeof x)\n\n/**\n * @internal\n */\nexport const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:02:36"}, {"role": "assistant", "content": "```ts\nimport * as assert from 'assert'\nimport * as E from 'fp-ts/lib/Either'\nimport { pipe } from 'fp-ts/lib/pipeable'\nimport * as TE from 'fp-ts/lib/TaskEither'\n\nimport * as DE from '../src/DecodeError'\nimport * as D from '../src/Decoder'\nimport * as FS from '../src/FreeSemigroup'\nimport * as G from '../src/Guard'\nimport * as _ from '../src/TaskDecoder'\n\nconst undefinedGuard: G.Guard<unknown, undefined> = {\n  is: (u): u is undefined => u === undefined\n}\nconst undef: _.TaskDecoder<unknown, undefined> = _.fromGuard(undefinedGuard, 'undefined')\n\nconst NumberFromString: _.TaskDecoder<unknown, number> = pipe(\n  _.string,\n  _.parse((s) => {\n    const n = parseFloat(s)\n    return isNaN(n) ? _.failure(s, 'parsable to a number') : _.success(n)\n  })\n)\n\ninterface PositiveBrand {\n  readonly Positive: unique symbol\n}\ntype Positive = number & PositiveBrand\nconst Positive: _.TaskDecoder<unknown, Positive> = pipe(\n  _.number,\n  _.refine((n): n is Positive => n > 0, 'Positive')\n)\n\ninterface IntBrand {\n  readonly Int: unique symbol\n}\ntype Int = number & IntBrand\nconst Int: _.TaskDecoder<unknown, Int> = pipe(\n  _.number,\n  _.refine((n): n is Int => Number.isInteger(n), 'Int')\n)\n\ndescribe.concurrent('UnknownTaskDecoder', () => {\n  // -------------------------------------------------------------------------------------\n  // instances\n  // -------------------------------------------------------------------------------------\n\n  it('Functor', async () => {\n    const decoder = _.Functor.map(_.string, (s) => s + '!')\n    assert.deepStrictEqual(await decoder.decode('a')(), D.success('a!'))\n  })\n\n  it('Alt', async () => {\n    const decoder = _.Alt.alt<unknown, string | number>(_.string, () => _.number)\n    assert.deepStrictEqual(await decoder.decode('a')(), D.success('a'))\n    assert.deepStrictEqual(await decoder.decode(1)(), D.success(1))\n  })\n\n  it('Category', async () => {\n    const decoder = _.Category.compose(_.id<unknown>(), _.string)\n    assert.deepStrictEqual(await decoder.decode('a')(), D.success('a'))\n    assert.deepStrictEqual(await decoder.decode(1)(), D.failure(1, 'string'))\n  })\n\n  // -------------------------------------------------------------------------------------\n  // constructors\n  // -------------------------------------------------------------------------------------\n\n  it('fromRefinement', async () => {\n    const IntFromNumber = _.fromRefinement((n: number): n is Int => Number.isInteger(n), 'IntFromNumber')\n    assert.deepStrictEqual(await IntFromNumber.decode(1)(), D.success(1))\n    assert.deepStrictEqual(await IntFromNumber.decode(1.2)(), D.failure(1.2, 'IntFromNumber'))\n  })\n\n  // -------------------------------------------------------------------------------------\n  // primitives\n  // -------------------------------------------------------------------------------------\n\n  it('string', async () => {\n    assert.deepStrictEqual(await _.string.decode('a')(), D.success('a'))\n    assert.deepStrictEqual(await _.string.decode(null)(), D.failure(null, 'string'))\n  })\n\n  it('number', async () => {\n    assert.deepStrictEqual(await _.number.decode(1)(), D.success(1))\n    assert.deepStrictEqual(await _.number.decode(null)(), D.failure(null, 'number'))\n  })\n\n  it('boolean', async () => {\n    assert.deepStrictEqual(await _.boolean.decode(true)(), D.success(true))\n    assert.deepStrictEqual(await _.boolean.decode(null)(), D.failure(null, 'boolean'))\n  })\n\n  it('UnknownArray', async () => {\n    assert.deepStrictEqual(await _.UnknownArray.decode([1, 'a'])(), D.success([1, 'a']))\n    assert.deepStrictEqual(await _.UnknownArray.decode(null)(), D.failure(null, 'Array<unknown>'))\n  })\n\n  it('UnknownRecord', async () => {\n    assert.deepStrictEqual(await _.UnknownRecord.decode({ a: 1, b: 'b' })(), D.success({ a: 1, b: 'b' }))\n    assert.deepStrictEqual(await _.UnknownRecord.decode(null)(), D.failure(null, 'Record<string, unknown>'))\n  })\n\n  // -------------------------------------------------------------------------------------\n  // constructors\n  // -------------------------------------------------------------------------------------\n\n  it('fromGuard', async () => {\n    const decoder = _.fromGuard(G.string, 'string')\n    assert.deepStrictEqual(await decoder.decode('a')(), D.success('a'))\n    assert.deepStrictEqual(await decoder.decode(null)(), D.failure(null, 'string'))\n  })\n\n  describe.concurrent('literal', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.literal('a', null, 'b', 1, true)\n      assert.deepStrictEqual(await decoder.decode('a')(), D.success('a'))\n      assert.deepStrictEqual(await decoder.decode(null)(), D.success(null))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.literal('a', null)\n      assert.deepStrictEqual(await decoder.decode('b')(), D.failure('b', '\"a\" | null'))\n    })\n  })\n\n  // -------------------------------------------------------------------------------------\n  // combinators\n  // -------------------------------------------------------------------------------------\n\n  it('mapLeftWithInput', async () => {\n    const decoder = pipe(\n      _.number,\n      _.mapLeftWithInput((u) => FS.of(DE.leaf(u, 'not a number')))\n    )\n    assert.deepStrictEqual(await decoder.decode('a')(), D.failure('a', 'not a number'))\n  })\n\n  it('withMessage', async () => {\n    const decoder = pipe(\n      _.struct({\n        name: _.string,\n        age: _.number\n      }),\n      _.withMessage(() => 'Person')\n    )\n    assert.deepStrictEqual(\n      await pipe(decoder.decode({}), TE.mapLeft(_.draw))(),\n      E.left(`Person\n\u251c\u2500 required property \"name\"\n\u2502  \u2514\u2500 cannot decode undefined, should be string\n\u2514\u2500 required property \"age\"\n   \u2514\u2500 cannot decode undefined, should be number`)\n    )\n  })\n\n  it('compose', async () => {\n    interface IntBrand {\n      readonly Int: unique symbol\n    }\n\n    type Int = number & IntBrand\n\n    const decoder = pipe(_.number, _.compose(_.fromRefinement((n): n is Int => Number.isInteger(n), 'IntFromNumber')))\n    assert.deepStrictEqual(await decoder.decode(1)(), D.success(1))\n    assert.deepStrictEqual(await decoder.decode('a')(), D.failure('a', 'number'))\n    assert.deepStrictEqual(await decoder.decode(1.2)(), D.failure(1.2, 'IntFromNumber'))\n  })\n\n  describe.concurrent('nullable', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.nullable(NumberFromString)\n      assert.deepStrictEqual(await decoder.decode(null)(), D.success(null))\n      assert.deepStrictEqual(await decoder.decode('1')(), D.success(1))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.nullable(NumberFromString)\n      assert.deepStrictEqual(\n        await decoder.decode(undefined)(),\n        E.left(\n          FS.concat(\n            FS.of(DE.member(0, FS.of(DE.leaf(undefined, 'null')))),\n            FS.of(DE.member(1, FS.of(DE.leaf(undefined, 'string'))))\n          )\n        )\n      )\n      assert.deepStrictEqual(\n        await decoder.decode('a')(),\n        E.left(\n          FS.concat(\n            FS.of(DE.member(0, FS.of(DE.leaf('a', 'null')))),\n            FS.of(DE.member(1, FS.of(DE.leaf('a', 'parsable to a number'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('struct', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.struct({\n        a: _.string\n      })\n      assert.deepStrictEqual(await decoder.decode({ a: 'a' })(), D.success({ a: 'a' }))\n    })\n\n    it('should strip additional fields', async () => {\n      const decoder = _.struct({\n        a: _.string\n      })\n      assert.deepStrictEqual(await decoder.decode({ a: 'a', b: 1 })(), D.success({ a: 'a' }))\n    })\n\n    it('should not strip fields corresponding to undefined values', async () => {\n      const decoder = _.struct({\n        a: undef\n      })\n      assert.deepStrictEqual(await decoder.decode({})(), D.success({ a: undefined }))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.struct({\n        a: _.string\n      })\n      assert.deepStrictEqual(await decoder.decode(undefined)(), D.failure(undefined, 'Record<string, unknown>'))\n      assert.deepStrictEqual(\n        await decoder.decode({ a: 1 })(),\n        E.left(FS.of(DE.key('a', DE.required, FS.of(DE.leaf(1, 'string')))))\n      )\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.struct({\n        a: _.string,\n        b: _.number\n      })\n      assert.deepStrictEqual(\n        await decoder.decode({})(),\n        E.left(\n          FS.concat(\n            FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string')))),\n            FS.of(DE.key('b', DE.required, FS.of(DE.leaf(undefined, 'number'))))\n          )\n        )\n      )\n    })\n\n    it('should support getters', async () => {\n      class A {\n        get a() {\n          return 'a'\n        }\n        get b() {\n          return 'b'\n        }\n      }\n      const decoder = _.struct({ a: _.string, b: _.string })\n      assert.deepStrictEqual(await decoder.decode(new A())(), D.success({ a: 'a', b: 'b' }))\n    })\n  })\n\n  describe.concurrent('partial', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(await decoder.decode({ a: 'a' })(), D.success({ a: 'a' }))\n      assert.deepStrictEqual(await decoder.decode({})(), D.success({}))\n    })\n\n    it('should strip additional fields', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(await decoder.decode({ a: 'a', b: 1 })(), D.success({ a: 'a' }))\n    })\n\n    it('should not add missing fields', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(await decoder.decode({})(), D.success({}))\n    })\n\n    it('should not strip fields corresponding to undefined values', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(await decoder.decode({ a: undefined })(), D.success({ a: undefined }))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.partial({ a: _.string })\n      assert.deepStrictEqual(await decoder.decode(undefined)(), D.failure(undefined, 'Record<string, unknown>'))\n      assert.deepStrictEqual(\n        await decoder.decode({ a: 1 })(),\n        E.left(FS.of(DE.key('a', DE.optional, FS.of(DE.leaf(1, 'string')))))\n      )\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.partial({\n        a: _.string,\n        b: _.number\n      })\n      assert.deepStrictEqual(\n        await decoder.decode({ a: 1, b: 'b' })(),\n        E.left(\n          FS.concat(\n            FS.of(DE.key('a', DE.optional, FS.of(DE.leaf(1, 'string')))),\n            FS.of(DE.key('b', DE.optional, FS.of(DE.leaf('b', 'number'))))\n          )\n        )\n      )\n    })\n\n    it('should support getters', async () => {\n      class A {\n        get a() {\n          return 'a'\n        }\n        get b() {\n          return 'b'\n        }\n      }\n      const decoder = _.partial({ a: _.string, b: _.string })\n      assert.deepStrictEqual(await decoder.decode(new A())(), D.success({ a: 'a', b: 'b' }))\n    })\n  })\n\n  describe.concurrent('array', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.array(_.string)\n      assert.deepStrictEqual(await decoder.decode([])(), D.success([]))\n      assert.deepStrictEqual(await decoder.decode(['a'])(), D.success(['a']))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.array(_.string)\n      assert.deepStrictEqual(await decoder.decode(undefined)(), D.failure(undefined, 'Array<unknown>'))\n      assert.deepStrictEqual(\n        await decoder.decode([1])(),\n        E.left(FS.of(DE.index(0, DE.optional, FS.of(DE.leaf(1, 'string')))))\n      )\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.array(_.string)\n      assert.deepStrictEqual(\n        await decoder.decode([1, 2])(),\n        E.left(\n          FS.concat(\n            FS.of(DE.index(0, DE.optional, FS.of(DE.leaf(1, 'string')))),\n            FS.of(DE.index(1, DE.optional, FS.of(DE.leaf(2, 'string'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('record', () => {\n    it('should decode a valid value', async () => {\n      const decoder = _.record(_.number)\n      assert.deepStrictEqual(await decoder.decode({})(), D.success({}))\n      assert.deepStrictEqual(await decoder.decode({ a: 1 })(), D.success({ a: 1 }))\n    })\n\n    it('should reject an invalid value', async () => {\n      const decoder = _.record(_.number)\n      assert.deepStrictEqual(await decoder.decode(undefined)(), D.failure(undefined, 'Record<string, unknown>'))\n      assert.deepStrictEqual(\n        await decoder.decode({ a: 'a' })(),\n        E.left(FS.of(DE.key('a', DE.optional, FS.of(DE.leaf('a', 'number')))))\n      )\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.record(_.number)\n      assert.deepStrictEqual(\n        await decoder.decode({ a: 'a', b: 'b' })(),\n        E.left(\n          FS.concat(\n            FS.of(DE.key('a', DE.optional, FS.of(DE.leaf('a', 'number')))),\n            FS.of(DE.key('b', DE.optional, FS.of(DE.leaf('b', 'number'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('tuple', () => {\n    it('should decode a valid input', async () => {\n      const decoder = _.tuple(_.string, _.number)\n      assert.deepStrictEqual(await decoder.decode(['a', 1])(), D.success(['a', 1]))\n    })\n\n    it('should handle zero components', async () => {\n      assert.deepStrictEqual(await _.tuple().decode([])(), D.success([]))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.tuple(_.string, _.number)\n      assert.deepStrictEqual(await decoder.decode(undefined)(), D.failure(undefined, 'Array<unknown>'))\n      assert.deepStrictEqual(\n        await decoder.decode(['a'])(),\n        E.left(FS.of(DE.index(1, DE.required, FS.of(DE.leaf(undefined, 'number')))))\n      )\n      assert.deepStrictEqual(\n        await decoder.decode([1, 2])(),\n        E.left(FS.of(DE.index(0, DE.required, FS.of(DE.leaf(1, 'string')))))\n      )\n    })\n\n    it('should collect all errors', async () => {\n      const decoder = _.tuple(_.string, _.number)\n      assert.deepStrictEqual(\n        await decoder.decode([1, 'a'])(),\n        E.left(\n          FS.concat(\n            FS.of(DE.index(0, DE.required, FS.of(DE.leaf(1, 'string')))),\n            FS.of(DE.index(1, DE.required, FS.of(DE.leaf('a', 'number'))))\n          )\n        )\n      )\n    })\n\n    it('should strip additional components', async () => {\n      const decoder = _.tuple(_.string, _.number)\n      assert.deepStrictEqual(await decoder.decode(['a', 1, true])(), D.success(['a', 1]))\n    })\n  })\n\n  describe.concurrent('union', () => {\n    it('should decode a valid input', async () => {\n      assert.deepStrictEqual(await _.union(_.string).decode('a')(), D.success('a'))\n      const decoder = _.union(_.string, _.number)\n      assert.deepStrictEqual(await decoder.decode('a')(), D.success('a'))\n      assert.deepStrictEqual(await decoder.decode(1)(), D.success(1))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = _.union(_.string, _.number)\n      assert.deepStrictEqual(\n        await decoder.decode(true)(),\n        E.left(\n          FS.concat(\n            FS.of(DE.member(0, FS.of(DE.leaf(true, 'string')))),\n            FS.of(DE.member(1, FS.of(DE.leaf(true, 'number'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('refine', () => {\n    it('should decode a valid input', async () => {\n      const decoder = pipe(\n        _.string,\n        _.refine((s): s is string => s.length > 0, 'NonEmptyString')\n      )\n      assert.deepStrictEqual(await decoder.decode('a')(), D.success('a'))\n    })\n\n    it('should reject an invalid input', async () => {\n      const decoder = pipe(\n        _.string,\n        _.refine((s): s is string => s.length > 0, 'NonEmptyString')\n      )\n      assert.deepStrictEqual(await decoder.decode(undefined)(), D.failure(undefined, 'string'))\n      assert.deepStrictEqual(await decoder.decode('')(), D.failure('', 'NonEmptyString'))\n    })\n  })\n\n  describe.concurrent('intersect', () => {\n    it('should decode a valid input', async () => {\n      const decoder = pipe(_.struct({ a: _.string }), _.intersect(_.struct({ b: _.number })))\n      assert.deepStrictEqual(await decoder.decode({ a: 'a', b: 1 })(), D.success({ a: 'a', b: 1 }))\n    })\n\n    it('should handle primitives', async () => {\n      const decoder = pipe(Int, _.intersect(Positive))\n      assert.deepStrictEqual(await decoder.decode(1)(), D.success(1))\n    })\n\n    it('should accumulate all errors', async () => {\n      const decoder = pipe(_.struct({ a: _.string }), _.intersect(_.struct({ b: _.number })))\n      assert.deepStrictEqual(\n        await decoder.decode({ a: 'a' })(),\n        E.left(FS.of(DE.key('b', DE.required, FS.of(DE.leaf(undefined, 'number')))))\n      )\n      assert.deepStrictEqual(\n        await decoder.decode({ b: 1 })(),\n        E.left(FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string')))))\n      )\n      assert.deepStrictEqual(\n        await decoder.decode({})(),\n        E.left(\n          FS.concat(\n            FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string')))),\n            FS.of(DE.key('b', DE.required, FS.of(DE.leaf(undefined, 'number'))))\n          )\n        )\n      )\n    })\n  })\n\n  describe.concurrent('sum', () => {\n    const sum = _.sum('_tag')\n\n    it('should decode a valid input', async () => {\n      const A = _.struct({ _tag: _.literal('A'), a: _.string })\n      const B = _.struct({ _tag: _.literal('B'), b: _.number })\n      const decoder = sum({ A, B })\n      assert.deepStrictEqual(await decoder.decode({ _tag: 'A', a: 'a' })(), D.success({ _tag: 'A', a: 'a' }))\n      assert.deepStrictEqual(await decoder.decode({ _tag: 'B', b: 1 })(), D.success({ _tag: 'B', b: 1 }))\n    })\n\n    it('should reject an invalid input', async () => {\n      const A = _.struct({ _tag: _.literal('A'), a: _.string })\n      const B = _.struct({ _tag: _.literal('B'), b: _.number })\n      const decoder = sum({ A, B })\n      assert.deepStrictEqual(await decoder.decode(null)(), D.failure(null, 'Record<string, unknown>'))\n      assert.deepStrictEqual(\n        await decoder.decode({})(),\n        E.left(FS.of(DE.key('_tag', DE.required, FS.of(DE.leaf(undefined, '\"A\" | \"B\"')))))\n      )\n      assert.deepStrictEqual(\n        await decoder.decode({ _tag: 'A', a: 1 })(),\n        E.left(FS.of(DE.key('a', DE.required, FS.of(DE.leaf(1, 'string')))))\n      )\n    })\n\n    it('should support empty records', async () => {\n      const decoder = sum({})\n      assert.deepStrictEqual(\n        await decoder.decode({})(),\n        E.left(FS.of(DE.key('_tag', DE.required, FS.of(DE.leaf(undefined, 'never')))))\n      )\n    })\n  })\n\n  interface A {\n    a: number\n    b?: A\n  }\n\n  const lazyDecoder: _.TaskDecoder<unknown, A> = _.lazy('A', () =>\n    pipe(_.struct({ a: NumberFromString }), _.intersect(_.partial({ b: lazyDecoder })))\n  )\n\n  describe.concurrent('lazy', () => {\n    it('should decode a valid input', async () => {\n      assert.deepStrictEqual(await lazyDecoder.decode({ a: '1' })(), D.success({ a: 1 }))\n      assert.deepStrictEqual(await lazyDecoder.decode({ a: '1', b: { a: '2' } })(), D.success({ a: 1, b: { a: 2 } }))\n    })\n\n    it('should reject an invalid input', async () => {\n      assert.deepStrictEqual(\n        await lazyDecoder.decode({ a: 1 })(),\n        E.left(FS.of(DE.lazy('A', FS.of(DE.key('a', DE.required, FS.of(DE.leaf(1, 'string')))))))\n      )\n      assert.deepStrictEqual(\n        await lazyDecoder.decode({ a: 'a' })(),\n        E.left(FS.of(DE.lazy('A', FS.of(DE.key('a', DE.required, FS.of(DE.leaf('a', 'parsable to a number')))))))\n      )\n      assert.deepStrictEqual(\n        await lazyDecoder.decode({ a: '1', b: {} })(),\n        E.left(\n          FS.of(\n            DE.lazy(\n              'A',\n              FS.of(\n                DE.key(\n                  'b',\n                  DE.optional,\n                  FS.of(DE.lazy('A', FS.of(DE.key('a', DE.required, FS.of(DE.leaf(undefined, 'string'))))))\n                )\n              )\n            )\n          )\n        )\n      )\n    })\n  })\n\n  // -------------------------------------------------------------------------------------\n  // utils\n  // -------------------------------------------------------------------------------------\n\n  describe.concurrent('draw', () => {\n    it('draw', async () => {\n      const decoder = _.struct({\n        a: _.string,\n        b: _.number,\n        c: _.array(_.boolean),\n        d: _.nullable(_.string)\n      })\n      assert.deepStrictEqual(\n        await pipe(decoder.decode({ c: [1] }), TE.mapLeft(_.draw))(),\n        E.left(`required property \"a\"\n\u2514\u2500 cannot decode undefined, should be string\nrequired property \"b\"\n\u2514\u2500 cannot decode undefined, should be number\nrequired property \"c\"\n\u2514\u2500 optional index 0\n   \u2514\u2500 cannot decode 1, should be boolean\nrequired property \"d\"\n\u251c\u2500 member 0\n\u2502  \u2514\u2500 cannot decode undefined, should be null\n\u2514\u2500 member 1\n   \u2514\u2500 cannot decode undefined, should be string`)\n      )\n    })\n\n    it('should support lazy combinators', async () => {\n      assert.deepStrictEqual(\n        await pipe(lazyDecoder.decode({ a: '1', b: {} }), TE.mapLeft(_.draw))(),\n        E.left(`lazy type A\n\u2514\u2500 optional property \"b\"\n   \u2514\u2500 lazy type A\n      \u2514\u2500 required property \"a\"\n         \u2514\u2500 cannot decode undefined, should be string`)\n      )\n    })\n  })\n\n  it('stringify', async () => {\n    assert.deepStrictEqual(await _.stringify(_.string.decode('a'))(), '\"a\"')\n    assert.deepStrictEqual(await _.stringify(_.string.decode(null))(), 'cannot decode null, should be string')\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\infiniteQueryOptions.test.tsx\\infiniteQueryOptions.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type {\n  DataTag,\n  DefaultError,\n  InfiniteData,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryKey,\n  SkipToken,\n} from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions } from './types'\n\nexport type UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData?:\n    | undefined\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | InitialDataFunction<\n        NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n      >\n}\n\nexport type UnusedSkipTokenInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = OmitKeyof<\n  UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  'queryFn'\n> & {\n  queryFn?: Exclude<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >['queryFn'],\n    SkipToken | undefined\n  >\n}\n\ntype NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData:\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | (() => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>)\n    | undefined\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UnusedSkipTokenInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UnusedSkipTokenInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions(options: unknown) {\n  return options\n}\n\n### Source File Dependency Files Content\n### Dependency File: types.ts\n/* istanbul ignore file */\n\nimport type {\n  DefaultError,\n  DefinedInfiniteQueryObserverResult,\n  DefinedQueryObserverResult,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  MutateFunction,\n  MutationObserverOptions,\n  MutationObserverResult,\n  OmitKeyof,\n  Override,\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n  SkipToken,\n} from '@tanstack/query-core'\n\nexport type AnyUseBaseQueryOptions = UseBaseQueryOptions<\n  any,\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseBaseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n  /**\n   * Set this to `false` to unsubscribe this observer from updates to the query cache.\n   * Defaults to `true`.\n   */\n  subscribed?: boolean\n}\n\nexport type AnyUseQueryOptions = UseQueryOptions<any, any, any, any>\nexport interface UseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends OmitKeyof<\n    UseBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>,\n    'suspense'\n  > {}\n\nexport type AnyUseSuspenseQueryOptions = UseSuspenseQueryOptions<\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseSuspenseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryFn' | 'enabled' | 'throwOnError' | 'placeholderData'\n  > {\n  queryFn?: Exclude<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>['queryFn'],\n    SkipToken\n  >\n}\n\nexport type AnyUseInfiniteQueryOptions = UseInfiniteQueryOptions<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends OmitKeyof<\n    InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'suspense'\n  > {\n  /**\n   * Set this to `false` to unsubscribe this observer from updates to the query cache.\n   * Defaults to `true`.\n   */\n  subscribed?: boolean\n}\n\nexport type AnyUseSuspenseInfiniteQueryOptions =\n  UseSuspenseInfiniteQueryOptions<any, any, any, any, any, any>\nexport interface UseSuspenseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends OmitKeyof<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'queryFn' | 'enabled' | 'throwOnError' | 'placeholderData'\n  > {\n  queryFn?: Exclude<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >['queryFn'],\n    SkipToken\n  >\n}\n\nexport type UseBaseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = QueryObserverResult<TData, TError>\n\nexport type UseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = UseBaseQueryResult<TData, TError>\n\nexport type UseSuspenseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = OmitKeyof<\n  DefinedQueryObserverResult<TData, TError>,\n  'isPlaceholderData' | 'promise'\n>\n\nexport type DefinedUseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = DefinedQueryObserverResult<TData, TError>\n\nexport type UseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = InfiniteQueryObserverResult<TData, TError>\n\nexport type DefinedUseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = DefinedInfiniteQueryObserverResult<TData, TError>\n\nexport type UseSuspenseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = OmitKeyof<\n  DefinedInfiniteQueryObserverResult<TData, TError>,\n  'isPlaceholderData' | 'promise'\n>\n\nexport type AnyUseMutationOptions = UseMutationOptions<any, any, any, any>\nexport interface UseMutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends OmitKeyof<\n    MutationObserverOptions<TData, TError, TVariables, TContext>,\n    '_defaulted'\n  > {}\n\nexport type UseMutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...args: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\nexport type UseMutateAsyncFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = MutateFunction<TData, TError, TVariables, TContext>\n\nexport type UseBaseMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = Override<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  { mutate: UseMutateFunction<TData, TError, TVariables, TContext> }\n> & { mutateAsync: UseMutateAsyncFunction<TData, TError, TVariables, TContext> }\n\nexport type UseMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = UseBaseMutationResult<TData, TError, TVariables, TContext>\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:46"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it } from 'vitest'\n\nimport { infiniteQueryOptions } from '../infiniteQueryOptions'\nimport type { UseInfiniteQueryOptions } from '../types'\n\ndescribe('infiniteQueryOptions', () => {\n  it('should return the object received as a parameter without any modification.', () => {\n    const object: UseInfiniteQueryOptions = {\n      queryKey: ['key'],\n      queryFn: () => Promise.resolve(5),\n      getNextPageParam: () => null,\n      initialPageParam: null,\n    }\n\n    expect(infiniteQueryOptions(object)).toStrictEqual(object)\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\QueryClientProvider.test.tsx\\QueryClientProvider.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\n'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:46"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, test, vi } from 'vitest'\nimport { render, waitFor } from '@testing-library/react'\nimport { QueryCache, QueryClientProvider, useQuery, useQueryClient } from '..'\nimport { createQueryClient, queryKey, sleep } from './utils'\n\ndescribe('QueryClientProvider', () => {\n  test('sets a specific cache for all queries to use', async () => {\n    const key = queryKey()\n\n    const queryCache = new QueryCache()\n    const queryClient = createQueryClient({ queryCache })\n\n    function Page() {\n      const { data } = useQuery({\n        queryKey: key,\n        queryFn: async () => {\n          await sleep(10)\n          return 'test'\n        },\n      })\n\n      return (\n        <div>\n          <h1>{data}</h1>\n        </div>\n      )\n    }\n\n    const rendered = render(\n      <QueryClientProvider client={queryClient}>\n        <Page />\n      </QueryClientProvider>,\n    )\n\n    await waitFor(() => rendered.getByText('test'))\n\n    expect(queryCache.find({ queryKey: key })).toBeDefined()\n  })\n\n  test('allows multiple caches to be partitioned', async () => {\n    const key1 = queryKey()\n    const key2 = queryKey()\n\n    const queryCache1 = new QueryCache()\n    const queryCache2 = new QueryCache()\n\n    const queryClient1 = createQueryClient({ queryCache: queryCache1 })\n    const queryClient2 = createQueryClient({ queryCache: queryCache2 })\n\n    function Page1() {\n      const { data } = useQuery({\n        queryKey: key1,\n        queryFn: async () => {\n          await sleep(10)\n          return 'test1'\n        },\n      })\n\n      return (\n        <div>\n          <h1>{data}</h1>\n        </div>\n      )\n    }\n    function Page2() {\n      const { data } = useQuery({\n        queryKey: key2,\n        queryFn: async () => {\n          await sleep(10)\n          return 'test2'\n        },\n      })\n\n      return (\n        <div>\n          <h1>{data}</h1>\n        </div>\n      )\n    }\n\n    const rendered = render(\n      <>\n        <QueryClientProvider client={queryClient1}>\n          <Page1 />\n        </QueryClientProvider>\n        <QueryClientProvider client={queryClient2}>\n          <Page2 />\n        </QueryClientProvider>\n      </>,\n    )\n\n    await waitFor(() => rendered.getByText('test1'))\n    await waitFor(() => rendered.getByText('test2'))\n\n    expect(queryCache1.find({ queryKey: key1 })).toBeDefined()\n    expect(queryCache1.find({ queryKey: key2 })).not.toBeDefined()\n    expect(queryCache2.find({ queryKey: key1 })).not.toBeDefined()\n    expect(queryCache2.find({ queryKey: key2 })).toBeDefined()\n  })\n\n  test(\"uses defaultOptions for queries when they don't provide their own config\", async () => {\n    const key = queryKey()\n\n    const queryCache = new QueryCache()\n    const queryClient = createQueryClient({\n      queryCache,\n      defaultOptions: {\n        queries: {\n          gcTime: Infinity,\n        },\n      },\n    })\n\n    function Page() {\n      const { data } = useQuery({\n        queryKey: key,\n        queryFn: async () => {\n          await sleep(10)\n          return 'test'\n        },\n      })\n\n      return (\n        <div>\n          <h1>{data}</h1>\n        </div>\n      )\n    }\n\n    const rendered = render(\n      <QueryClientProvider client={queryClient}>\n        <Page />\n      </QueryClientProvider>,\n    )\n\n    await waitFor(() => rendered.getByText('test'))\n\n    expect(queryCache.find({ queryKey: key })).toBeDefined()\n    expect(queryCache.find({ queryKey: key })?.options.gcTime).toBe(Infinity)\n  })\n\n  describe('useQueryClient', () => {\n    test('should throw an error if no query client has been set', () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      function Page() {\n        useQueryClient()\n        return null\n      }\n\n      expect(() => render(<Page />)).toThrow(\n        'No QueryClient set, use QueryClientProvider to set one',\n      )\n\n      consoleMock.mockRestore()\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\queryOptions.test.tsx\\queryOptions.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type {\n  DataTag,\n  DefaultError,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunction,\n  QueryKey,\n  SkipToken,\n} from '@tanstack/query-core'\nimport type { UseQueryOptions } from './types'\n\nexport type UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData?:\n    | undefined\n    | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>\n    | NonUndefinedGuard<TQueryFnData>\n}\n\nexport type UnusedSkipTokenOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'queryFn'\n> & {\n  queryFn?: Exclude<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>['queryFn'],\n    SkipToken | undefined\n  >\n}\n\ntype NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'queryFn'> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>)\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UnusedSkipTokenOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UnusedSkipTokenOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n\n### Source File Dependency Files Content\n### Dependency File: types.ts\n/* istanbul ignore file */\n\nimport type {\n  DefaultError,\n  DefinedInfiniteQueryObserverResult,\n  DefinedQueryObserverResult,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  MutateFunction,\n  MutationObserverOptions,\n  MutationObserverResult,\n  OmitKeyof,\n  Override,\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n  SkipToken,\n} from '@tanstack/query-core'\n\nexport type AnyUseBaseQueryOptions = UseBaseQueryOptions<\n  any,\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseBaseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n  /**\n   * Set this to `false` to unsubscribe this observer from updates to the query cache.\n   * Defaults to `true`.\n   */\n  subscribed?: boolean\n}\n\nexport type AnyUseQueryOptions = UseQueryOptions<any, any, any, any>\nexport interface UseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends OmitKeyof<\n    UseBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>,\n    'suspense'\n  > {}\n\nexport type AnyUseSuspenseQueryOptions = UseSuspenseQueryOptions<\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseSuspenseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryFn' | 'enabled' | 'throwOnError' | 'placeholderData'\n  > {\n  queryFn?: Exclude<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>['queryFn'],\n    SkipToken\n  >\n}\n\nexport type AnyUseInfiniteQueryOptions = UseInfiniteQueryOptions<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends OmitKeyof<\n    InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'suspense'\n  > {\n  /**\n   * Set this to `false` to unsubscribe this observer from updates to the query cache.\n   * Defaults to `true`.\n   */\n  subscribed?: boolean\n}\n\nexport type AnyUseSuspenseInfiniteQueryOptions =\n  UseSuspenseInfiniteQueryOptions<any, any, any, any, any, any>\nexport interface UseSuspenseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends OmitKeyof<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'queryFn' | 'enabled' | 'throwOnError' | 'placeholderData'\n  > {\n  queryFn?: Exclude<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >['queryFn'],\n    SkipToken\n  >\n}\n\nexport type UseBaseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = QueryObserverResult<TData, TError>\n\nexport type UseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = UseBaseQueryResult<TData, TError>\n\nexport type UseSuspenseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = OmitKeyof<\n  DefinedQueryObserverResult<TData, TError>,\n  'isPlaceholderData' | 'promise'\n>\n\nexport type DefinedUseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = DefinedQueryObserverResult<TData, TError>\n\nexport type UseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = InfiniteQueryObserverResult<TData, TError>\n\nexport type DefinedUseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = DefinedInfiniteQueryObserverResult<TData, TError>\n\nexport type UseSuspenseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = OmitKeyof<\n  DefinedInfiniteQueryObserverResult<TData, TError>,\n  'isPlaceholderData' | 'promise'\n>\n\nexport type AnyUseMutationOptions = UseMutationOptions<any, any, any, any>\nexport interface UseMutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends OmitKeyof<\n    MutationObserverOptions<TData, TError, TVariables, TContext>,\n    '_defaulted'\n  > {}\n\nexport type UseMutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...args: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\nexport type UseMutateAsyncFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = MutateFunction<TData, TError, TVariables, TContext>\n\nexport type UseBaseMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = Override<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  { mutate: UseMutateFunction<TData, TError, TVariables, TContext> }\n> & { mutateAsync: UseMutateAsyncFunction<TData, TError, TVariables, TContext> }\n\nexport type UseMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = UseBaseMutationResult<TData, TError, TVariables, TContext>\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:46"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it } from 'vitest'\nimport { queryOptions } from '../queryOptions'\nimport type { UseQueryOptions } from '../types'\n\ndescribe('queryOptions', () => {\n  it('should return the object received as a parameter without any modification.', () => {\n    const object: UseQueryOptions = {\n      queryKey: ['key'],\n      queryFn: () => Promise.resolve(5),\n    } as const\n\n    expect(queryOptions(object)).toStrictEqual(object)\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\QueryResetErrorBoundary.test.tsx\\QueryResetErrorBoundary.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\n'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:46"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it, vi } from 'vitest'\nimport { fireEvent, waitFor } from '@testing-library/react'\nimport { ErrorBoundary } from 'react-error-boundary'\nimport * as React from 'react'\n\nimport {\n  QueryCache,\n  QueryErrorResetBoundary,\n  useQueries,\n  useQuery,\n  useSuspenseQueries,\n  useSuspenseQuery,\n} from '..'\nimport { createQueryClient, queryKey, renderWithClient, sleep } from './utils'\n\ndescribe('QueryErrorResetBoundary', () => {\n  const queryCache = new QueryCache()\n  const queryClient = createQueryClient({ queryCache })\n\n  describe('useQuery', () => {\n    it('should retry fetch if the reset error boundary has been reset', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n      const key = queryKey()\n\n      let succeed = false\n\n      function Page() {\n        const { data } = useQuery({\n          queryKey: key,\n          queryFn: async () => {\n            await sleep(10)\n            if (!succeed) {\n              throw new Error('Error')\n            } else {\n              return 'data'\n            }\n          },\n          retry: false,\n          throwOnError: true,\n        })\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      succeed = true\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('data'))\n      consoleMock.mockRestore()\n    })\n\n    it('should not throw error if query is disabled', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n      const key = queryKey()\n\n      let succeed = false\n\n      function Page() {\n        const { data, status } = useQuery({\n          queryKey: key,\n          queryFn: async () => {\n            await sleep(10)\n            if (!succeed) {\n              throw new Error('Error')\n            } else {\n              return 'data'\n            }\n          },\n          retry: false,\n          enabled: !succeed,\n          throwOnError: true,\n        })\n        return (\n          <div>\n            <div>status: {status}</div>\n            <div>{data}</div>\n          </div>\n        )\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      succeed = true\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('status: error'))\n      consoleMock.mockRestore()\n    })\n\n    it('should not throw error if query is disabled, and refetch if query becomes enabled again', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      const key = queryKey()\n\n      let succeed = false\n\n      function Page() {\n        const [enabled, setEnabled] = React.useState(false)\n        const { data } = useQuery({\n          queryKey: key,\n          queryFn: async () => {\n            await sleep(10)\n            if (!succeed) {\n              throw new Error('Error')\n            } else {\n              return 'data'\n            }\n          },\n          retry: false,\n          enabled,\n          throwOnError: true,\n        })\n\n        React.useEffect(() => {\n          setEnabled(true)\n        }, [])\n\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      succeed = true\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('data'))\n      consoleMock.mockRestore()\n    })\n\n    it('should throw error if query is disabled and manually refetch', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      const key = queryKey()\n\n      function Page() {\n        const { data, refetch, status, fetchStatus } = useQuery<string>({\n          queryKey: key,\n          queryFn: async () => {\n            throw new Error('Error')\n          },\n          retry: false,\n          enabled: false,\n          throwOnError: true,\n        })\n\n        return (\n          <div>\n            <button onClick={() => refetch()}>refetch</button>\n            <div>\n              status: {status}, fetchStatus: {fetchStatus}\n            </div>\n            <div>{data}</div>\n          </div>\n        )\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() =>\n        rendered.getByText('status: pending, fetchStatus: idle'),\n      )\n      fireEvent.click(rendered.getByRole('button', { name: /refetch/i }))\n      await waitFor(() => rendered.getByText('error boundary'))\n      consoleMock.mockRestore()\n    })\n\n    it('should not retry fetch if the reset error boundary has not been reset', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      const key = queryKey()\n\n      let succeed = false\n\n      function Page() {\n        const { data } = useQuery({\n          queryKey: key,\n          queryFn: async () => {\n            await sleep(10)\n            if (!succeed) {\n              throw new Error('Error')\n            } else {\n              return 'data'\n            }\n          },\n          retry: false,\n          throwOnError: true,\n        })\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {() => (\n            <ErrorBoundary\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      succeed = true\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('error boundary'))\n      consoleMock.mockRestore()\n    })\n\n    it('should retry fetch if the reset error boundary has been reset and the query contains data from a previous fetch', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      const key = queryKey()\n\n      let succeed = false\n\n      function Page() {\n        const { data } = useQuery({\n          queryKey: key,\n          queryFn: async () => {\n            await sleep(10)\n            if (!succeed) {\n              throw new Error('Error')\n            } else {\n              return 'data'\n            }\n          },\n          retry: false,\n          throwOnError: true,\n          initialData: 'initial',\n        })\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      succeed = true\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('data'))\n      consoleMock.mockRestore()\n    })\n\n    it('should not retry fetch if the reset error boundary has not been reset after a previous reset', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      const key = queryKey()\n\n      let succeed = false\n      let shouldReset = true\n\n      function Page() {\n        const { data } = useQuery({\n          queryKey: key,\n          queryFn: async () => {\n            await sleep(10)\n            if (!succeed) {\n              throw new Error('Error')\n            } else {\n              return 'data'\n            }\n          },\n          retry: false,\n          throwOnError: true,\n        })\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={() => {\n                if (shouldReset) {\n                  reset()\n                }\n              }}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      shouldReset = true\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('error boundary'))\n      succeed = true\n      shouldReset = false\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('error boundary'))\n      consoleMock.mockRestore()\n    })\n\n    it('should throw again on error after the reset error boundary has been reset', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      const key = queryKey()\n      let fetchCount = 0\n\n      function Page() {\n        const { data } = useQuery<string>({\n          queryKey: key,\n          queryFn: async () => {\n            fetchCount++\n            await sleep(10)\n            throw new Error('Error')\n          },\n          retry: false,\n          throwOnError: true,\n        })\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('error boundary'))\n      expect(fetchCount).toBe(3)\n      consoleMock.mockRestore()\n    })\n\n    it('should never render the component while the query is in error state', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      const key = queryKey()\n      let fetchCount = 0\n      let renders = 0\n\n      function Page() {\n        const { data } = useSuspenseQuery({\n          queryKey: key,\n          queryFn: async () => {\n            fetchCount++\n            await sleep(10)\n            if (fetchCount > 2) {\n              return 'data'\n            } else {\n              throw new Error('Error')\n            }\n          },\n          retry: false,\n        })\n        renders++\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <React.Suspense fallback={<div>loading</div>}>\n                <Page />\n              </React.Suspense>\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('data'))\n      expect(fetchCount).toBe(3)\n      expect(renders).toBe(1)\n      consoleMock.mockRestore()\n    })\n\n    it('should render children', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      function Page() {\n        return (\n          <div>\n            <span>page</span>\n          </div>\n        )\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          <Page />\n        </QueryErrorResetBoundary>,\n      )\n\n      expect(rendered.queryByText('page')).not.toBeNull()\n      consoleMock.mockRestore()\n    })\n\n    it('should show error boundary when using tracked queries even though we do not track the error field', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      const key = queryKey()\n\n      let succeed = false\n\n      function Page() {\n        const { data } = useQuery({\n          queryKey: key,\n          queryFn: async () => {\n            await sleep(10)\n            if (!succeed) {\n              throw new Error('Error')\n            } else {\n              return 'data'\n            }\n          },\n          retry: false,\n          throwOnError: true,\n        })\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      succeed = true\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('data'))\n      consoleMock.mockRestore()\n    })\n  })\n  describe('useQueries', () => {\n    it('should retry fetch if the reset error boundary has been reset', async () => {\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n      const key = queryKey()\n\n      let succeed = false\n\n      function Page() {\n        const [{ data }] = useQueries({\n          queries: [\n            {\n              queryKey: key,\n              queryFn: async () => {\n                await sleep(10)\n                if (!succeed) {\n                  throw new Error('Error')\n                } else {\n                  return 'data'\n                }\n              },\n              retry: false,\n              throwOnError: true,\n              retryOnMount: true,\n            },\n          ],\n        })\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <Page />\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      succeed = true\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('data'))\n      consoleMock.mockRestore()\n    })\n\n    it('with suspense should retry fetch if the reset error boundary has been reset', async () => {\n      const key = queryKey()\n      const consoleMock = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => undefined)\n\n      let succeed = false\n\n      function Page() {\n        const [{ data }] = useSuspenseQueries({\n          queries: [\n            {\n              queryKey: key,\n              queryFn: async () => {\n                await sleep(10)\n                if (!succeed) {\n                  throw new Error('Error')\n                } else {\n                  return 'data'\n                }\n              },\n              retry: false,\n              retryOnMount: true,\n            },\n          ],\n        })\n        return <div>{data}</div>\n      }\n\n      const rendered = renderWithClient(\n        queryClient,\n        <QueryErrorResetBoundary>\n          {({ reset }) => (\n            <ErrorBoundary\n              onReset={reset}\n              fallbackRender={({ resetErrorBoundary }) => (\n                <div>\n                  <div>error boundary</div>\n                  <button\n                    onClick={() => {\n                      resetErrorBoundary()\n                    }}\n                  >\n                    retry\n                  </button>\n                </div>\n              )}\n            >\n              <React.Suspense fallback=\"Loader\">\n                <Page />\n              </React.Suspense>\n            </ErrorBoundary>\n          )}\n        </QueryErrorResetBoundary>,\n      )\n\n      await waitFor(() => rendered.getByText('error boundary'))\n      await waitFor(() => rendered.getByText('retry'))\n      succeed = true\n      fireEvent.click(rendered.getByText('retry'))\n      await waitFor(() => rendered.getByText('data'))\n      consoleMock.mockRestore()\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\suspense.test.tsx\\suspense.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  const originalStaleTime = defaultedOptions.staleTime\n\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => Math.max(originalStaleTime(...args), 1000)\n        : Math.max(originalStaleTime ?? 1000, 1000)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n\n### Source File Dependency Files Content\n### Dependency File: QueryErrorResetBoundary.tsx\n'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:46"}, {"role": "assistant", "content": "```ts\nimport { act, render, waitFor } from '@testing-library/react'\nimport { Suspense } from 'react'\nimport {\n  afterAll,\n  beforeAll,\n  beforeEach,\n  describe,\n  expect,\n  it,\n  vi,\n} from 'vitest'\nimport { QueryClient, QueryClientProvider, useSuspenseQuery } from '..'\nimport { queryKey } from './utils'\nimport type { QueryKey } from '..'\n\nfunction renderWithSuspense(client: QueryClient, ui: React.ReactNode) {\n  return render(\n    <QueryClientProvider client={client}>\n      <Suspense fallback=\"loading\">{ui}</Suspense>\n    </QueryClientProvider>,\n  )\n}\n\nfunction createTestQuery(options: {\n  fetchCount: { count: number }\n  queryKey: QueryKey\n  staleTime?: number | (() => number)\n}) {\n  return function TestComponent() {\n    const { data } = useSuspenseQuery({\n      queryKey: options.queryKey,\n      queryFn: () => {\n        options.fetchCount.count++\n        return 'data'\n      },\n      staleTime: options.staleTime,\n    })\n    return <div>data: {data}</div>\n  }\n}\n\ndescribe('Suspense Timer Tests', () => {\n  let queryClient: QueryClient\n  let fetchCount: { count: number }\n\n  beforeAll(() => {\n    vi.useFakeTimers({ shouldAdvanceTime: true })\n  })\n\n  afterAll(() => {\n    vi.useRealTimers()\n  })\n\n  beforeEach(() => {\n    queryClient = new QueryClient({\n      defaultOptions: {\n        queries: {\n          retry: false,\n        },\n      },\n    })\n    fetchCount = { count: 0 }\n  })\n\n  it('should enforce minimum staleTime of 1000ms when using suspense with number', async () => {\n    const TestComponent = createTestQuery({\n      fetchCount,\n      queryKey: ['test'],\n      staleTime: 10,\n    })\n\n    const rendered = renderWithSuspense(queryClient, <TestComponent />)\n\n    await waitFor(() => rendered.getByText('data: data'))\n\n    rendered.rerender(\n      <QueryClientProvider client={queryClient}>\n        <Suspense fallback=\"loading\">\n          <TestComponent />\n        </Suspense>\n      </QueryClientProvider>,\n    )\n\n    act(() => {\n      vi.advanceTimersByTime(100)\n    })\n\n    expect(fetchCount.count).toBe(1)\n  })\n\n  it('should enforce minimum staleTime of 1000ms when using suspense with function', async () => {\n    const TestComponent = createTestQuery({\n      fetchCount,\n      queryKey: ['test-func'],\n      staleTime: () => 10,\n    })\n\n    const rendered = renderWithSuspense(queryClient, <TestComponent />)\n\n    await waitFor(() => rendered.getByText('data: data'))\n\n    rendered.rerender(\n      <QueryClientProvider client={queryClient}>\n        <Suspense fallback=\"loading\">\n          <TestComponent />\n        </Suspense>\n      </QueryClientProvider>,\n    )\n\n    act(() => {\n      vi.advanceTimersByTime(100)\n    })\n\n    expect(fetchCount.count).toBe(1)\n  })\n\n  it('should respect staleTime when value is greater than 1000ms', async () => {\n    const TestComponent = createTestQuery({\n      fetchCount,\n      queryKey: queryKey(),\n      staleTime: 2000,\n    })\n\n    const rendered = renderWithSuspense(queryClient, <TestComponent />)\n\n    await waitFor(() => rendered.getByText('data: data'))\n\n    rendered.rerender(\n      <QueryClientProvider client={queryClient}>\n        <Suspense fallback=\"loading\">\n          <TestComponent />\n        </Suspense>\n      </QueryClientProvider>,\n    )\n\n    act(() => {\n      vi.advanceTimersByTime(1500)\n    })\n\n    expect(fetchCount.count).toBe(1)\n  })\n\n  it('should enforce minimum staleTime when undefined is provided', async () => {\n    const TestComponent = createTestQuery({\n      fetchCount,\n      queryKey: queryKey(),\n      staleTime: undefined,\n    })\n\n    const rendered = renderWithSuspense(queryClient, <TestComponent />)\n\n    await waitFor(() => rendered.getByText('data: data'))\n\n    rendered.rerender(\n      <QueryClientProvider client={queryClient}>\n        <Suspense fallback=\"loading\">\n          <TestComponent />\n        </Suspense>\n      </QueryClientProvider>,\n    )\n\n    act(() => {\n      vi.advanceTimersByTime(500)\n    })\n\n    expect(fetchCount.count).toBe(1)\n  })\n\n  it('should respect staleTime when function returns value greater than 1000ms', async () => {\n    const TestComponent = createTestQuery({\n      fetchCount,\n      queryKey: queryKey(),\n      staleTime: () => 3000,\n    })\n\n    const rendered = renderWithSuspense(queryClient, <TestComponent />)\n\n    await waitFor(() => rendered.getByText('data: data'))\n\n    rendered.rerender(\n      <QueryClientProvider client={queryClient}>\n        <Suspense fallback=\"loading\">\n          <TestComponent />\n        </Suspense>\n      </QueryClientProvider>,\n    )\n\n    act(() => {\n      vi.advanceTimersByTime(2000)\n    })\n\n    expect(fetchCount.count).toBe(1)\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\useMutationState.test.tsx\\useMutationState.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n\n### Source File Dependency Files Content\n### Dependency File: QueryClientProvider.tsx\n'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:46"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, expectTypeOf, it } from 'vitest'\nimport { fireEvent, render, waitFor } from '@testing-library/react'\nimport * as React from 'react'\nimport { useIsMutating, useMutationState } from '../useMutationState'\nimport { useMutation } from '../useMutation'\nimport {\n  createQueryClient,\n  doNotExecute,\n  renderWithClient,\n  sleep,\n} from './utils'\nimport type { MutationState, MutationStatus } from '@tanstack/query-core'\n\ndescribe('useIsMutating', () => {\n  it('should return the number of fetching mutations', async () => {\n    const isMutatingArray: Array<number> = []\n    const queryClient = createQueryClient()\n\n    function IsMutating() {\n      const isMutating = useIsMutating()\n      isMutatingArray.push(isMutating)\n      return null\n    }\n\n    function Mutations() {\n      const { mutate: mutate1 } = useMutation({\n        mutationKey: ['mutation1'],\n        mutationFn: async () => {\n          await sleep(50)\n          return 'data'\n        },\n      })\n      const { mutate: mutate2 } = useMutation({\n        mutationKey: ['mutation2'],\n        mutationFn: async () => {\n          await sleep(10)\n          return 'data'\n        },\n      })\n\n      return (\n        <div>\n          <button onClick={() => mutate1()}>mutate1</button>\n          <button onClick={() => mutate2()}>mutate2</button>\n        </div>\n      )\n    }\n\n    function Page() {\n      return (\n        <div>\n          <IsMutating />\n          <Mutations />\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <Page />)\n    fireEvent.click(rendered.getByRole('button', { name: /mutate1/i }))\n    await sleep(10)\n    fireEvent.click(rendered.getByRole('button', { name: /mutate2/i }))\n\n    // we don't really care if this yields\n    // [ +0, 1, 2, +0 ]\n    // or\n    // [ +0, 1, 2, 1, +0 ]\n    // our batching strategy might yield different results\n\n    await waitFor(() => expect(isMutatingArray[0]).toEqual(0))\n    await waitFor(() => expect(isMutatingArray[1]).toEqual(1))\n    await waitFor(() => expect(isMutatingArray[2]).toEqual(2))\n    await waitFor(() =>\n      expect(isMutatingArray[isMutatingArray.length - 1]).toEqual(0),\n    )\n  })\n\n  it('should filter correctly by mutationKey', async () => {\n    const isMutatingArray: Array<number> = []\n    const queryClient = createQueryClient()\n\n    function IsMutating() {\n      const isMutating = useIsMutating({ mutationKey: ['mutation1'] })\n      isMutatingArray.push(isMutating)\n      return null\n    }\n\n    function Page() {\n      const { mutate: mutate1 } = useMutation({\n        mutationKey: ['mutation1'],\n        mutationFn: async () => {\n          await sleep(100)\n          return 'data'\n        },\n      })\n      const { mutate: mutate2 } = useMutation({\n        mutationKey: ['mutation2'],\n        mutationFn: async () => {\n          await sleep(100)\n          return 'data'\n        },\n      })\n\n      React.useEffect(() => {\n        mutate1()\n        mutate2()\n      }, [mutate1, mutate2])\n\n      return <IsMutating />\n    }\n\n    renderWithClient(queryClient, <Page />)\n    await waitFor(() => expect(isMutatingArray).toEqual([0, 1, 0]))\n  })\n\n  it('should filter correctly by predicate', async () => {\n    const isMutatingArray: Array<number> = []\n    const queryClient = createQueryClient()\n\n    function IsMutating() {\n      const isMutating = useIsMutating({\n        predicate: (mutation) =>\n          mutation.options.mutationKey?.[0] === 'mutation1',\n      })\n      isMutatingArray.push(isMutating)\n      return null\n    }\n\n    function Page() {\n      const { mutate: mutate1 } = useMutation({\n        mutationKey: ['mutation1'],\n        mutationFn: async () => {\n          await sleep(100)\n          return 'data'\n        },\n      })\n      const { mutate: mutate2 } = useMutation({\n        mutationKey: ['mutation2'],\n        mutationFn: async () => {\n          await sleep(100)\n          return 'data'\n        },\n      })\n\n      React.useEffect(() => {\n        mutate1()\n        mutate2()\n      }, [mutate1, mutate2])\n\n      return <IsMutating />\n    }\n\n    renderWithClient(queryClient, <Page />)\n    await waitFor(() => expect(isMutatingArray).toEqual([0, 1, 0]))\n  })\n\n  it('should use provided custom queryClient', async () => {\n    const queryClient = createQueryClient()\n\n    function Page() {\n      const isMutating = useIsMutating({}, queryClient)\n      const { mutate } = useMutation(\n        {\n          mutationKey: ['mutation1'],\n          mutationFn: async () => {\n            await sleep(10)\n            return 'data'\n          },\n        },\n        queryClient,\n      )\n\n      React.useEffect(() => {\n        mutate()\n      }, [mutate])\n\n      return (\n        <div>\n          <div>mutating: {isMutating}</div>\n        </div>\n      )\n    }\n\n    const rendered = render(<Page></Page>)\n\n    await waitFor(() => rendered.getByText('mutating: 1'))\n  })\n})\n\ndescribe('useMutationState', () => {\n  describe('types', () => {\n    it('should default to QueryState', () => {\n      doNotExecute(() => {\n        const result = useMutationState({\n          filters: { status: 'pending' },\n        })\n\n        expectTypeOf(result).toEqualTypeOf<Array<MutationState>>()\n      })\n    })\n    it('should infer with select', () => {\n      doNotExecute(() => {\n        const result = useMutationState({\n          filters: { status: 'pending' },\n          select: (mutation) => mutation.state.status,\n        })\n\n        expectTypeOf(result).toEqualTypeOf<Array<MutationStatus>>()\n      })\n    })\n  })\n  it('should return variables after calling mutate', async () => {\n    const queryClient = createQueryClient()\n    const variables: Array<Array<unknown>> = []\n    const mutationKey = ['mutation']\n\n    function Variables() {\n      variables.push(\n        useMutationState({\n          filters: { mutationKey, status: 'pending' },\n          select: (mutation) => mutation.state.variables,\n        }),\n      )\n\n      return null\n    }\n\n    function Mutate() {\n      const { mutate, data } = useMutation({\n        mutationKey,\n        mutationFn: async (input: number) => {\n          await sleep(150)\n          return 'data' + input\n        },\n      })\n\n      return (\n        <div>\n          data: {data ?? 'null'}\n          <button onClick={() => mutate(1)}>mutate</button>\n        </div>\n      )\n    }\n\n    function Page() {\n      return (\n        <div>\n          <Variables />\n          <Mutate />\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <Page />)\n\n    await waitFor(() => rendered.getByText('data: null'))\n\n    fireEvent.click(rendered.getByRole('button', { name: /mutate/i }))\n\n    await waitFor(() => rendered.getByText('data: data1'))\n\n    expect(variables).toEqual([[], [1], []])\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\usePrefetchInfiniteQuery.test.tsx\\usePrefetchInfiniteQuery.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DefaultError,\n  FetchInfiniteQueryOptions,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\n\nexport function usePrefetchInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: FetchInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchInfiniteQuery(options)\n  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: usePrefetchInfiniteQuery.tsx\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DefaultError,\n  FetchInfiniteQueryOptions,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\n\nexport function usePrefetchInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: FetchInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchInfiniteQuery(options)\n  }\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:46"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it, vi } from 'vitest'\nimport React from 'react'\nimport { fireEvent, waitFor } from '@testing-library/react'\n\nimport {\n  QueryCache,\n  usePrefetchInfiniteQuery,\n  useSuspenseInfiniteQuery,\n} from '..'\nimport { createQueryClient, queryKey, renderWithClient, sleep } from './utils'\n\nimport type { InfiniteData, UseSuspenseInfiniteQueryOptions } from '..'\nimport type { Mock } from 'vitest'\n\nconst generateInfiniteQueryOptions = (\n  data: Array<{ data: string; currentPage: number; totalPages: number }>,\n) => {\n  let currentPage = 0\n\n  return {\n    queryFn: vi\n      .fn<(...args: Array<any>) => Promise<(typeof data)[number]>>()\n      .mockImplementation(async () => {\n        const currentPageData = data[currentPage]\n        if (!currentPageData) {\n          throw new Error('No data defined for page ' + currentPage)\n        }\n\n        await sleep(10)\n        currentPage++\n\n        return currentPageData\n      }),\n    initialPageParam: 1,\n    getNextPageParam: (lastPage: (typeof data)[number]) =>\n      lastPage.currentPage === lastPage.totalPages\n        ? undefined\n        : lastPage.currentPage + 1,\n  }\n}\n\ndescribe('usePrefetchInfiniteQuery', () => {\n  const queryCache = new QueryCache()\n  const queryClient = createQueryClient({ queryCache })\n\n  const Fallback = vi.fn().mockImplementation(() => <div>Loading...</div>)\n\n  function Suspended<T = unknown>(props: {\n    queryOpts: UseSuspenseInfiniteQueryOptions<\n      T,\n      Error,\n      InfiniteData<T>,\n      any,\n      Array<string>,\n      any\n    >\n    renderPage: (page: T) => React.JSX.Element\n  }) {\n    const state = useSuspenseInfiniteQuery(props.queryOpts)\n\n    return (\n      <div>\n        {state.data.pages.map((page, index) => (\n          <div key={index}>{props.renderPage(page)}</div>\n        ))}\n        <button onClick={() => state.fetchNextPage()}>Next Page</button>\n      </div>\n    )\n  }\n\n  it('should prefetch an infinite query if query state does not exist', async () => {\n    const data = [\n      { data: 'Do you fetch on render?', currentPage: 1, totalPages: 3 },\n      { data: 'Or do you render as you fetch?', currentPage: 2, totalPages: 3 },\n      {\n        data: 'Either way, Tanstack Query helps you!',\n        currentPage: 3,\n        totalPages: 3,\n      },\n    ]\n\n    const queryOpts = {\n      queryKey: queryKey(),\n      ...generateInfiniteQueryOptions(data),\n    }\n\n    function App() {\n      usePrefetchInfiniteQuery({ ...queryOpts, pages: data.length })\n\n      return (\n        <React.Suspense fallback={<Fallback />}>\n          <Suspended\n            queryOpts={queryOpts}\n            renderPage={(page) => <div>data: {page.data}</div>}\n          />\n        </React.Suspense>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    await waitFor(() => rendered.getByText('data: Do you fetch on render?'))\n    fireEvent.click(rendered.getByText('Next Page'))\n    await waitFor(() =>\n      rendered.getByText('data: Or do you render as you fetch?'),\n    )\n    fireEvent.click(rendered.getByText('Next Page'))\n    await waitFor(() =>\n      rendered.getByText('data: Either way, Tanstack Query helps you!'),\n    )\n    expect(Fallback).toHaveBeenCalledTimes(1)\n    expect(queryOpts.queryFn).toHaveBeenCalledTimes(3)\n  })\n\n  it('should not display fallback if the query cache is already populated', async () => {\n    const queryOpts = {\n      queryKey: queryKey(),\n      ...generateInfiniteQueryOptions([\n        { data: 'Prefetch rocks!', currentPage: 1, totalPages: 3 },\n        { data: 'No waterfalls, boy!', currentPage: 2, totalPages: 3 },\n        { data: 'Tanstack Query #ftw', currentPage: 3, totalPages: 3 },\n      ]),\n    }\n\n    await queryClient.prefetchInfiniteQuery({ ...queryOpts, pages: 3 })\n    ;(queryOpts.queryFn as Mock).mockClear()\n\n    function App() {\n      usePrefetchInfiniteQuery(queryOpts)\n\n      return (\n        <React.Suspense fallback={<Fallback />}>\n          <Suspended\n            queryOpts={queryOpts}\n            renderPage={(page) => <div>data: {page.data}</div>}\n          />\n        </React.Suspense>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    await waitFor(() => rendered.getByText('data: Prefetch rocks!'))\n    fireEvent.click(rendered.getByText('Next Page'))\n    await waitFor(() => rendered.getByText('data: No waterfalls, boy!'))\n    fireEvent.click(rendered.getByText('Next Page'))\n    await waitFor(() => rendered.getByText('data: Tanstack Query #ftw'))\n    expect(queryOpts.queryFn).not.toHaveBeenCalled()\n    expect(Fallback).not.toHaveBeenCalled()\n  })\n\n  it('should not create an endless loop when using inside a suspense boundary', async () => {\n    const queryOpts = {\n      queryKey: queryKey(),\n      ...generateInfiniteQueryOptions([\n        { data: 'Infinite Page 1', currentPage: 1, totalPages: 3 },\n        { data: 'Infinite Page 2', currentPage: 1, totalPages: 3 },\n        { data: 'Infinite Page 3', currentPage: 1, totalPages: 3 },\n      ]),\n    }\n\n    function Prefetch({ children }: { children: React.ReactNode }) {\n      usePrefetchInfiniteQuery(queryOpts)\n      return <>{children}</>\n    }\n\n    function App() {\n      return (\n        <React.Suspense>\n          <Prefetch>\n            <Suspended\n              queryOpts={queryOpts}\n              renderPage={(page) => <div>data: {page.data}</div>}\n            />\n          </Prefetch>\n        </React.Suspense>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n    await waitFor(() => rendered.getByText('data: Infinite Page 1'))\n    fireEvent.click(rendered.getByText('Next Page'))\n    await waitFor(() => rendered.getByText('data: Infinite Page 2'))\n    fireEvent.click(rendered.getByText('Next Page'))\n    await waitFor(() => rendered.getByText('data: Infinite Page 3'))\n    expect(queryOpts.queryFn).toHaveBeenCalledTimes(3)\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\usePrefetchQuery.test.tsx\\usePrefetchQuery.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DefaultError,\n  FetchQueryOptions,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\n\nexport function usePrefetchQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchQuery(options)\n  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: usePrefetchInfiniteQuery.tsx\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DefaultError,\n  FetchInfiniteQueryOptions,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\n\nexport function usePrefetchInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: FetchInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchInfiniteQuery(options)\n  }\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:46"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it, vi } from 'vitest'\nimport React from 'react'\nimport { fireEvent, waitFor } from '@testing-library/react'\nimport { ErrorBoundary } from 'react-error-boundary'\nimport {\n  QueryCache,\n  usePrefetchQuery,\n  useQueryErrorResetBoundary,\n  useSuspenseQuery,\n} from '..'\nimport { createQueryClient, queryKey, renderWithClient, sleep } from './utils'\n\nimport type { UseSuspenseQueryOptions } from '..'\n\nconst generateQueryFn = (data: string) =>\n  vi\n    .fn<(...args: Array<any>) => Promise<string>>()\n    .mockImplementation(async () => {\n      await sleep(10)\n\n      return data\n    })\n\ndescribe('usePrefetchQuery', () => {\n  const queryCache = new QueryCache()\n  const queryClient = createQueryClient({ queryCache })\n\n  function Suspended<TData = unknown>(props: {\n    queryOpts: UseSuspenseQueryOptions<TData, Error, TData, Array<string>>\n    children?: React.ReactNode\n  }) {\n    const state = useSuspenseQuery(props.queryOpts)\n\n    return (\n      <div>\n        <div>data: {String(state.data)}</div>\n        {props.children}\n      </div>\n    )\n  }\n\n  it('should prefetch query if query state does not exist', async () => {\n    const queryOpts = {\n      queryKey: queryKey(),\n      queryFn: generateQueryFn('prefetchQuery'),\n    }\n\n    const componentQueryOpts = {\n      ...queryOpts,\n      queryFn: generateQueryFn('useSuspenseQuery'),\n    }\n\n    function App() {\n      usePrefetchQuery(queryOpts)\n\n      return (\n        <React.Suspense fallback=\"Loading...\">\n          <Suspended queryOpts={componentQueryOpts} />\n        </React.Suspense>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    await waitFor(() => rendered.getByText('data: prefetchQuery'))\n    expect(queryOpts.queryFn).toHaveBeenCalledTimes(1)\n  })\n\n  it('should not prefetch query if query state exists', async () => {\n    const queryOpts = {\n      queryKey: queryKey(),\n      queryFn: generateQueryFn('The usePrefetchQuery hook is smart!'),\n    }\n\n    function App() {\n      usePrefetchQuery(queryOpts)\n\n      return (\n        <React.Suspense fallback=\"Loading...\">\n          <Suspended queryOpts={queryOpts} />\n        </React.Suspense>\n      )\n    }\n\n    await queryClient.fetchQuery(queryOpts)\n    queryOpts.queryFn.mockClear()\n    const rendered = renderWithClient(queryClient, <App />)\n\n    expect(rendered.queryByText('fetching: true')).not.toBeInTheDocument()\n    await waitFor(() =>\n      rendered.getByText('data: The usePrefetchQuery hook is smart!'),\n    )\n    expect(queryOpts.queryFn).not.toHaveBeenCalled()\n  })\n\n  it('should let errors fall through and not refetch failed queries', async () => {\n    const consoleMock = vi.spyOn(console, 'error')\n    consoleMock.mockImplementation(() => undefined)\n    const queryFn = generateQueryFn('Not an error')\n\n    const queryOpts = {\n      queryKey: queryKey(),\n      queryFn,\n    }\n\n    queryFn.mockImplementationOnce(async () => {\n      await sleep(10)\n\n      throw new Error('Oops! Server error!')\n    })\n\n    function App() {\n      usePrefetchQuery(queryOpts)\n\n      return (\n        <ErrorBoundary fallbackRender={() => <div>Oops!</div>}>\n          <React.Suspense fallback=\"Loading...\">\n            <Suspended queryOpts={queryOpts} />\n          </React.Suspense>\n        </ErrorBoundary>\n      )\n    }\n\n    await queryClient.prefetchQuery(queryOpts)\n    queryFn.mockClear()\n    const rendered = renderWithClient(queryClient, <App />)\n\n    await waitFor(() => rendered.getByText('Oops!'))\n    expect(rendered.queryByText('data: Not an error')).not.toBeInTheDocument()\n    expect(queryOpts.queryFn).not.toHaveBeenCalled()\n\n    consoleMock.mockRestore()\n  })\n\n  it('should not create an endless loop when using inside a suspense boundary', async () => {\n    const queryFn = generateQueryFn('prefetchedQuery')\n\n    const queryOpts = {\n      queryKey: queryKey(),\n      queryFn,\n    }\n\n    function Prefetch({ children }: { children: React.ReactNode }) {\n      usePrefetchQuery(queryOpts)\n      return <>{children}</>\n    }\n\n    function App() {\n      return (\n        <React.Suspense>\n          <Prefetch>\n            <Suspended queryOpts={queryOpts} />\n          </Prefetch>\n        </React.Suspense>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n    await waitFor(() => rendered.getByText('data: prefetchedQuery'))\n    expect(queryOpts.queryFn).toHaveBeenCalledTimes(1)\n  })\n\n  it('should be able to recover from errors and try fetching again', async () => {\n    const consoleMock = vi.spyOn(console, 'error')\n    consoleMock.mockImplementation(() => undefined)\n    const queryFn = generateQueryFn('This is fine :dog: :fire:')\n\n    const queryOpts = {\n      queryKey: queryKey(),\n      queryFn,\n    }\n\n    queryFn.mockImplementationOnce(async () => {\n      await sleep(10)\n\n      throw new Error('Oops! Server error!')\n    })\n\n    function App() {\n      const { reset } = useQueryErrorResetBoundary()\n      usePrefetchQuery(queryOpts)\n\n      return (\n        <ErrorBoundary\n          onReset={reset}\n          fallbackRender={({ resetErrorBoundary }) => (\n            <div>\n              <div>Oops!</div>\n              <button onClick={resetErrorBoundary}>Try again</button>\n            </div>\n          )}\n        >\n          <React.Suspense fallback=\"Loading...\">\n            <Suspended queryOpts={queryOpts} />\n          </React.Suspense>\n        </ErrorBoundary>\n      )\n    }\n\n    await queryClient.prefetchQuery(queryOpts)\n    queryFn.mockClear()\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    await waitFor(() => rendered.getByText('Oops!'))\n    fireEvent.click(rendered.getByText('Try again'))\n    await waitFor(() => rendered.getByText('data: This is fine :dog: :fire:'))\n    expect(queryOpts.queryFn).toHaveBeenCalledTimes(1)\n    consoleMock.mockRestore()\n  })\n\n  it('should not create a suspense waterfall if prefetch is fired', async () => {\n    const firstQueryOpts = {\n      queryKey: queryKey(),\n      queryFn: generateQueryFn('Prefetch is nice!'),\n    }\n\n    const secondQueryOpts = {\n      queryKey: queryKey(),\n      queryFn: generateQueryFn('Prefetch is really nice!!'),\n    }\n\n    const thirdQueryOpts = {\n      queryKey: queryKey(),\n      queryFn: generateQueryFn('Prefetch does not create waterfalls!!'),\n    }\n\n    const Fallback = vi.fn().mockImplementation(() => <div>Loading...</div>)\n\n    function App() {\n      usePrefetchQuery(firstQueryOpts)\n      usePrefetchQuery(secondQueryOpts)\n      usePrefetchQuery(thirdQueryOpts)\n\n      return (\n        <React.Suspense fallback={<Fallback />}>\n          <Suspended queryOpts={firstQueryOpts}>\n            <Suspended queryOpts={secondQueryOpts}>\n              <Suspended queryOpts={thirdQueryOpts} />\n            </Suspended>\n          </Suspended>\n        </React.Suspense>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n    expect(\n      queryClient.getQueryState(firstQueryOpts.queryKey)?.fetchStatus,\n    ).toBe('fetching')\n    expect(\n      queryClient.getQueryState(secondQueryOpts.queryKey)?.fetchStatus,\n    ).toBe('fetching')\n    expect(\n      queryClient.getQueryState(thirdQueryOpts.queryKey)?.fetchStatus,\n    ).toBe('fetching')\n    await waitFor(() => rendered.getByText('Loading...'))\n    await waitFor(() => rendered.getByText('data: Prefetch is nice!'))\n    await waitFor(() => rendered.getByText('data: Prefetch is really nice!!'))\n    await waitFor(() =>\n      rendered.getByText('data: Prefetch does not create waterfalls!!'),\n    )\n    expect(Fallback).toHaveBeenCalledTimes(1)\n    expect(firstQueryOpts.queryFn).toHaveBeenCalledTimes(1)\n    expect(secondQueryOpts.queryFn).toHaveBeenCalledTimes(1)\n    expect(thirdQueryOpts.queryFn).toHaveBeenCalledTimes(1)\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\useSuspenseQueries.test.tsx\\useSuspenseQueries.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\n'use client'\nimport { skipToken } from '@tanstack/query-core'\nimport { useQueries } from './useQueries'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type {\n  DefaultError,\n  QueryClient,\n  QueryFunction,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseSuspenseQueryOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryOptions<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryOptions<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryOptions<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryOptions<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryOptions<\n                    TQueryFnData,\n                    TError,\n                    TData,\n                    TQueryKey\n                  >\n                : T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                        | SkipTokenForUseQueries\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryOptions<\n                      TQueryFnData,\n                      TError,\n                      TQueryFnData,\n                      TQueryKey\n                    >\n                  : // Fallback\n                    UseSuspenseQueryOptions\n\ntype GetUseSuspenseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseSuspenseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryResult<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryResult<TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? UseSuspenseQueryResult<TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryResult<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryResult<TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryResult<\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, any>\n                        | SkipTokenForUseQueries\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryResult<\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : // Fallback\n                    UseSuspenseQueryResult\n\n/**\n * SuspenseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type SuspenseQueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryOptions>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseSuspenseQueryOptions<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? SuspenseQueriesOptions<\n            [...Tails],\n            [...TResults, GetUseSuspenseQueryOptions<Head>],\n            [...TDepth, 1]\n          >\n        : Array<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseSuspenseQueryOptions<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n              >\n            : // Fallback\n              Array<UseSuspenseQueryOptions>\n\n/**\n * SuspenseQueriesResults reducer recursively maps type param to results\n */\nexport type SuspenseQueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseSuspenseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? SuspenseQueriesResults<\n            [...Tails],\n            [...TResults, GetUseSuspenseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseSuspenseQueryResult<T[K]> }\n\nexport function useSuspenseQueries<\n  T extends Array<any>,\n  TCombinedResult = SuspenseQueriesResults<T>,\n>(\n  options: {\n    queries:\n      | readonly [...SuspenseQueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseSuspenseQueryOptions<T[K]> }]\n    combine?: (result: SuspenseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult\n\nexport function useSuspenseQueries<\n  T extends Array<any>,\n  TCombinedResult = SuspenseQueriesResults<T>,\n>(\n  options: {\n    queries: readonly [...SuspenseQueriesOptions<T>]\n    combine?: (result: SuspenseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult\n\nexport function useSuspenseQueries(options: any, queryClient?: QueryClient) {\n  return useQueries(\n    {\n      ...options,\n      queries: options.queries.map((query: any) => {\n        if (process.env.NODE_ENV !== 'production') {\n          if (query.queryFn === skipToken) {\n            console.error('skipToken is not allowed for useSuspenseQueries')\n          }\n        }\n\n        return {\n          ...query,\n          suspense: true,\n          throwOnError: defaultThrowOnError,\n          enabled: true,\n          placeholderData: undefined,\n        }\n      }),\n    },\n    queryClient,\n  )\n}\n\n### Source File Dependency Files Content\n### Dependency File: suspense.ts\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  const originalStaleTime = defaultedOptions.staleTime\n\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => Math.max(originalStaleTime(...args), 1000)\n        : Math.max(originalStaleTime ?? 1000, 1000)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n\n\n### Dependency File: types.ts\n/* istanbul ignore file */\n\nimport type {\n  DefaultError,\n  DefinedInfiniteQueryObserverResult,\n  DefinedQueryObserverResult,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  MutateFunction,\n  MutationObserverOptions,\n  MutationObserverResult,\n  OmitKeyof,\n  Override,\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n  SkipToken,\n} from '@tanstack/query-core'\n\nexport type AnyUseBaseQueryOptions = UseBaseQueryOptions<\n  any,\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseBaseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n  /**\n   * Set this to `false` to unsubscribe this observer from updates to the query cache.\n   * Defaults to `true`.\n   */\n  subscribed?: boolean\n}\n\nexport type AnyUseQueryOptions = UseQueryOptions<any, any, any, any>\nexport interface UseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends OmitKeyof<\n    UseBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>,\n    'suspense'\n  > {}\n\nexport type AnyUseSuspenseQueryOptions = UseSuspenseQueryOptions<\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseSuspenseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryFn' | 'enabled' | 'throwOnError' | 'placeholderData'\n  > {\n  queryFn?: Exclude<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>['queryFn'],\n    SkipToken\n  >\n}\n\nexport type AnyUseInfiniteQueryOptions = UseInfiniteQueryOptions<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends OmitKeyof<\n    InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'suspense'\n  > {\n  /**\n   * Set this to `false` to unsubscribe this observer from updates to the query cache.\n   * Defaults to `true`.\n   */\n  subscribed?: boolean\n}\n\nexport type AnyUseSuspenseInfiniteQueryOptions =\n  UseSuspenseInfiniteQueryOptions<any, any, any, any, any, any>\nexport interface UseSuspenseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends OmitKeyof<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'queryFn' | 'enabled' | 'throwOnError' | 'placeholderData'\n  > {\n  queryFn?: Exclude<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >['queryFn'],\n    SkipToken\n  >\n}\n\nexport type UseBaseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = QueryObserverResult<TData, TError>\n\nexport type UseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = UseBaseQueryResult<TData, TError>\n\nexport type UseSuspenseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = OmitKeyof<\n  DefinedQueryObserverResult<TData, TError>,\n  'isPlaceholderData' | 'promise'\n>\n\nexport type DefinedUseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = DefinedQueryObserverResult<TData, TError>\n\nexport type UseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = InfiniteQueryObserverResult<TData, TError>\n\nexport type DefinedUseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = DefinedInfiniteQueryObserverResult<TData, TError>\n\nexport type UseSuspenseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = OmitKeyof<\n  DefinedInfiniteQueryObserverResult<TData, TError>,\n  'isPlaceholderData' | 'promise'\n>\n\nexport type AnyUseMutationOptions = UseMutationOptions<any, any, any, any>\nexport interface UseMutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends OmitKeyof<\n    MutationObserverOptions<TData, TError, TVariables, TContext>,\n    '_defaulted'\n  > {}\n\nexport type UseMutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...args: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\nexport type UseMutateAsyncFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = MutateFunction<TData, TError, TVariables, TContext>\n\nexport type UseBaseMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = Override<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  { mutate: UseMutateFunction<TData, TError, TVariables, TContext> }\n> & { mutateAsync: UseMutateAsyncFunction<TData, TError, TVariables, TContext> }\n\nexport type UseMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = UseBaseMutationResult<TData, TError, TVariables, TContext>\n\n\n### Dependency File: useQueries.ts\n'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport { noop } from './utils'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  OmitKeyof,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'subscribed'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    unknown extends TError ? DefaultError : TError,\n                    unknown extends TData ? TQueryFnData : TData,\n                    TQueryKey\n                  >\n                : // Fallback\n                  UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : // Fallback\n                  UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseQueryResult<T[K]> }\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries:\n      | readonly [...QueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseQueryOptionsForUseQueries<T[K]> }]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n    subscribed?: boolean\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(\n          opts as QueryObserverOptions,\n        )\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(\n      defaultedQueries,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop,\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index]\n      return (\n        query &&\n        getHasError({\n          result,\n          errorResetBoundary,\n          throwOnError: query.throwOnError,\n          query: client.getQueryCache().get(query.queryHash),\n          suspense: query.suspense,\n        })\n      )\n    },\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:47"}, {"role": "assistant", "content": "```ts\nimport {\n  afterAll,\n  afterEach,\n  beforeAll,\n  describe,\n  expect,\n  it,\n  vi,\n} from 'vitest'\nimport { act, fireEvent, render, waitFor } from '@testing-library/react'\nimport * as React from 'react'\nimport { ErrorBoundary } from 'react-error-boundary'\nimport { skipToken, useSuspenseQueries, useSuspenseQuery } from '..'\nimport { createQueryClient, queryKey, renderWithClient, sleep } from './utils'\nimport type { UseSuspenseQueryOptions } from '..'\n\ntype NumberQueryOptions = UseSuspenseQueryOptions<number>\n\nconst QUERY_DURATION = 1000\n\nconst createQuery: (id: number) => NumberQueryOptions = (id) => ({\n  queryKey: [id],\n  queryFn: async () => {\n    await sleep(QUERY_DURATION)\n    return id\n  },\n})\nconst resolveQueries = () => vi.advanceTimersByTimeAsync(QUERY_DURATION)\n\nconst queryClient = createQueryClient()\n\ndescribe('useSuspenseQueries', () => {\n  const onSuspend = vi.fn()\n  const onQueriesResolution = vi.fn()\n\n  beforeAll(() => {\n    vi.useFakeTimers()\n  })\n\n  afterAll(() => {\n    vi.useRealTimers()\n  })\n\n  afterEach(() => {\n    queryClient.clear()\n    onSuspend.mockClear()\n    onQueriesResolution.mockClear()\n  })\n\n  function SuspenseFallback() {\n    React.useEffect(() => {\n      onSuspend()\n    }, [])\n\n    return null\n  }\n\n  const withSuspenseWrapper = <T extends object>(Component: React.FC<T>) => {\n    function SuspendedComponent(props: T) {\n      return (\n        <React.Suspense fallback={<SuspenseFallback />}>\n          <Component {...props} />\n        </React.Suspense>\n      )\n    }\n\n    return SuspendedComponent\n  }\n\n  function QueriesContainer({\n    queries,\n  }: {\n    queries: Array<NumberQueryOptions>\n  }) {\n    const queriesResults = useSuspenseQueries(\n      { queries, combine: (results) => results.map((r) => r.data) },\n      queryClient,\n    )\n\n    React.useEffect(() => {\n      onQueriesResolution(queriesResults)\n    }, [queriesResults])\n\n    return null\n  }\n\n  const TestComponent = withSuspenseWrapper(QueriesContainer)\n\n  it('should suspend on mount', () => {\n    render(<TestComponent queries={[1, 2].map(createQuery)} />)\n\n    expect(onSuspend).toHaveBeenCalledOnce()\n  })\n\n  it('should resolve queries', async () => {\n    render(<TestComponent queries={[1, 2].map(createQuery)} />)\n\n    await act(resolveQueries)\n\n    expect(onQueriesResolution).toHaveBeenCalledTimes(1)\n    expect(onQueriesResolution).toHaveBeenLastCalledWith([1, 2])\n  })\n\n  it('should not suspend on mount if query has been already fetched', () => {\n    const query = createQuery(1)\n\n    queryClient.setQueryData(query.queryKey, query.queryFn)\n\n    render(<TestComponent queries={[query]} />)\n\n    expect(onSuspend).not.toHaveBeenCalled()\n  })\n\n  it('should not break suspense when queries change without resolving', async () => {\n    const initQueries = [1, 2].map(createQuery)\n    const nextQueries = [3, 4, 5, 6].map(createQuery)\n\n    const { rerender } = render(<TestComponent queries={initQueries} />)\n\n    rerender(<TestComponent queries={nextQueries} />)\n\n    await act(resolveQueries)\n\n    expect(onSuspend).toHaveBeenCalledTimes(1)\n    expect(onQueriesResolution).toHaveBeenCalledTimes(1)\n    expect(onQueriesResolution).toHaveBeenLastCalledWith([3, 4, 5, 6])\n  })\n\n  it('should suspend only once per queries change', async () => {\n    const initQueries = [1, 2].map(createQuery)\n    const nextQueries = [3, 4, 5, 6].map(createQuery)\n\n    const { rerender } = render(<TestComponent queries={initQueries} />)\n\n    await act(resolveQueries)\n\n    rerender(<TestComponent queries={nextQueries} />)\n\n    await act(resolveQueries)\n\n    expect(onSuspend).toHaveBeenCalledTimes(2)\n    expect(onQueriesResolution).toHaveBeenCalledTimes(2)\n    expect(onQueriesResolution).toHaveBeenLastCalledWith([3, 4, 5, 6])\n  })\n\n  it('should only call combine after resolving', async () => {\n    const spy = vi.fn()\n    const key = queryKey()\n\n    function Page() {\n      const data = useSuspenseQueries({\n        queries: [1, 2, 3].map((value) => ({\n          queryKey: [...key, { value }],\n          queryFn: async () => {\n            await sleep(value * 10)\n            return { value: value * 10 }\n          },\n        })),\n        combine: (result) => {\n          spy(result)\n          return 'data'\n        },\n      })\n\n      return <h1>{data}</h1>\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <React.Suspense fallback=\"loading...\">\n        <Page />\n      </React.Suspense>,\n    )\n\n    await act(() => vi.advanceTimersByTimeAsync(10))\n\n    rendered.getByText('loading...')\n\n    expect(spy).not.toHaveBeenCalled()\n\n    await act(() => vi.advanceTimersByTimeAsync(30))\n    rendered.getByText('data')\n\n    expect(spy).toHaveBeenCalled()\n  })\n})\n\ndescribe('useSuspenseQueries 2', () => {\n  it('should suspend all queries in parallel', async () => {\n    const key1 = queryKey()\n    const key2 = queryKey()\n    const results: Array<string> = []\n\n    function Fallback() {\n      results.push('loading')\n      return <div>loading</div>\n    }\n\n    function Page() {\n      const result = useSuspenseQueries({\n        queries: [\n          {\n            queryKey: key1,\n            queryFn: async () => {\n              results.push('1')\n              await sleep(10)\n              return '1'\n            },\n          },\n          {\n            queryKey: key2,\n            queryFn: async () => {\n              results.push('2')\n              await sleep(20)\n              return '2'\n            },\n          },\n        ],\n      })\n      return (\n        <div>\n          <h1>data: {result.map((item) => item.data ?? 'null').join(',')}</h1>\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <React.Suspense fallback={<Fallback />}>\n        <Page />\n      </React.Suspense>,\n    )\n\n    await waitFor(() => rendered.getByText('loading'))\n    await waitFor(() => rendered.getByText('data: 1,2'))\n\n    expect(results).toEqual(['1', '2', 'loading'])\n  })\n\n  it(\"shouldn't unmount before all promises fetched\", async () => {\n    const key1 = queryKey()\n    const key2 = queryKey()\n    const results: Array<string> = []\n    const refs: Array<number> = []\n\n    function Fallback() {\n      results.push('loading')\n      return <div>loading</div>\n    }\n\n    function Page() {\n      const ref = React.useRef(Math.random())\n      const result = useSuspenseQueries({\n        queries: [\n          {\n            queryKey: key1,\n            queryFn: async () => {\n              refs.push(ref.current)\n              results.push('1')\n              await sleep(10)\n              return '1'\n            },\n          },\n          {\n            queryKey: key2,\n            queryFn: async () => {\n              refs.push(ref.current)\n              results.push('2')\n              await sleep(20)\n              return '2'\n            },\n          },\n        ],\n      })\n      return (\n        <div>\n          <h1>data: {result.map((item) => item.data ?? 'null').join(',')}</h1>\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <React.Suspense fallback={<Fallback />}>\n        <Page />\n      </React.Suspense>,\n    )\n    await waitFor(() => rendered.getByText('loading'))\n    expect(refs.length).toBe(2)\n    await waitFor(() => rendered.getByText('data: 1,2'))\n    expect(refs[0]).toBe(refs[1])\n  })\n\n  // this addresses the following issue:\n  // https://github.com/TanStack/query/issues/6344\n  it('should suspend on offline when query changes, and data should not be undefined', async () => {\n    function Page() {\n      const [id, setId] = React.useState(0)\n\n      const { data } = useSuspenseQuery({\n        queryKey: [id],\n        queryFn: () => Promise.resolve(`Data ${id}`),\n      })\n\n      // defensive guard here\n      if (data === undefined) {\n        throw new Error('data cannot be undefined')\n      }\n\n      return (\n        <>\n          <div>{data}</div>\n          <button onClick={() => setId(id + 1)}>fetch</button>\n        </>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <React.Suspense fallback={<div>loading</div>}>\n        <Page />\n      </React.Suspense>,\n    )\n\n    await waitFor(() => rendered.getByText('loading'))\n    await waitFor(() => rendered.getByText('Data 0'))\n\n    // go offline\n    document.dispatchEvent(new CustomEvent('offline'))\n\n    fireEvent.click(rendered.getByText('fetch'))\n    await waitFor(() => rendered.getByText('Data 0'))\n\n    // go back online\n    document.dispatchEvent(new CustomEvent('online'))\n    fireEvent.click(rendered.getByText('fetch'))\n\n    // query should resume\n    await waitFor(() => rendered.getByText('Data 1'))\n  })\n\n  it('should throw error when queryKey changes and new query fails', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    const key = queryKey()\n\n    function Page() {\n      const [fail, setFail] = React.useState(false)\n      const { data } = useSuspenseQuery({\n        queryKey: [key, fail],\n        queryFn: async () => {\n          await sleep(10)\n\n          if (fail) {\n            throw new Error('Suspense Error Bingo')\n          } else {\n            return 'data'\n          }\n        },\n        retry: 0,\n      })\n\n      return (\n        <div>\n          <button onClick={() => setFail(true)}>trigger fail</button>\n\n          <div>rendered: {String(data)}</div>\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <ErrorBoundary fallbackRender={() => <div>error boundary</div>}>\n        <React.Suspense fallback={'Loading...'}>\n          <Page />\n        </React.Suspense>\n      </ErrorBoundary>,\n    )\n\n    await waitFor(() => rendered.getByText('Loading...'))\n\n    await waitFor(() => rendered.getByText('rendered: data'))\n\n    fireEvent.click(rendered.getByText('trigger fail'))\n\n    await waitFor(() => rendered.getByText('error boundary'))\n\n    expect(consoleMock.mock.calls[0]?.[1]).toStrictEqual(\n      new Error('Suspense Error Bingo'),\n    )\n\n    consoleMock.mockRestore()\n  })\n\n  it('should keep previous data when wrapped in a transition', async () => {\n    const key = queryKey()\n\n    function Page() {\n      const [count, setCount] = React.useState(0)\n      const [isPending, startTransition] = React.useTransition()\n      const { data } = useSuspenseQuery({\n        queryKey: [key, count],\n        queryFn: async () => {\n          await sleep(10)\n          return 'data' + count\n        },\n      })\n\n      return (\n        <div>\n          <button onClick={() => startTransition(() => setCount(count + 1))}>\n            inc\n          </button>\n\n          <div>{isPending ? 'Pending...' : String(data)}</div>\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <React.Suspense fallback={'Loading...'}>\n        <Page />\n      </React.Suspense>,\n    )\n\n    await waitFor(() => rendered.getByText('Loading...'))\n\n    await waitFor(() => rendered.getByText('data0'))\n\n    fireEvent.click(rendered.getByText('inc'))\n\n    await waitFor(() => rendered.getByText('Pending...'))\n\n    await waitFor(() => rendered.getByText('data1'))\n  })\n\n  it('should not request old data inside transitions (issue #6486)', async () => {\n    const key = queryKey()\n    let queryFnCount = 0\n\n    function App() {\n      const [count, setCount] = React.useState(0)\n\n      return (\n        <div>\n          <button\n            onClick={() => React.startTransition(() => setCount(count + 1))}\n          >\n            inc\n          </button>\n          <React.Suspense fallback={'Loading...'}>\n            <Page count={count} />\n          </React.Suspense>\n        </div>\n      )\n    }\n\n    function Page({ count }: { count: number }) {\n      const { data } = useSuspenseQuery({\n        queryKey: [key, count],\n        queryFn: async () => {\n          queryFnCount++\n          await sleep(10)\n          return 'data' + count\n        },\n      })\n\n      return (\n        <div>\n          <div>{String(data)}</div>\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n\n      <App />,\n    )\n\n    await waitFor(() => rendered.getByText('Loading...'))\n\n    await waitFor(() => rendered.getByText('data0'))\n\n    fireEvent.click(rendered.getByText('inc'))\n\n    await waitFor(() => rendered.getByText('data1'))\n\n    await sleep(20)\n\n    expect(queryFnCount).toBe(2)\n  })\n\n  it('should still suspense if queryClient has placeholderData config', async () => {\n    const key = queryKey()\n    const queryClientWithPlaceholder = createQueryClient({\n      defaultOptions: {\n        queries: {\n          placeholderData: (previousData: any) => previousData,\n        },\n      },\n    })\n\n    function Page() {\n      const [count, setCount] = React.useState(0)\n      const [isPending, startTransition] = React.useTransition()\n      const { data } = useSuspenseQuery({\n        queryKey: [key, count],\n        queryFn: async () => {\n          await sleep(10)\n          return 'data' + count\n        },\n      })\n\n      return (\n        <div>\n          <button onClick={() => startTransition(() => setCount(count + 1))}>\n            inc\n          </button>\n\n          <div>{isPending ? 'Pending...' : String(data)}</div>\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClientWithPlaceholder,\n      <React.Suspense fallback={'Loading...'}>\n        <Page />\n      </React.Suspense>,\n    )\n\n    await waitFor(() => rendered.getByText('Loading...'))\n\n    await waitFor(() => rendered.getByText('data0'))\n\n    fireEvent.click(rendered.getByText('inc'))\n\n    await waitFor(() => rendered.getByText('Pending...'))\n\n    await waitFor(() => rendered.getByText('data1'))\n  })\n\n  it('should show error boundary even with gcTime:0 (#7853)', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    const key = queryKey()\n    let count = 0\n\n    function Page() {\n      useSuspenseQuery({\n        queryKey: key,\n        queryFn: () => {\n          count++\n          return Promise.reject(new Error('Query failed'))\n        },\n        gcTime: 0,\n        retry: false,\n      })\n\n      return null\n    }\n\n    function App() {\n      return (\n        <React.Suspense fallback=\"loading\">\n          <ErrorBoundary\n            fallbackRender={() => {\n              return <div>There was an error!</div>\n            }}\n          >\n            <Page />\n          </ErrorBoundary>\n        </React.Suspense>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    await waitFor(() => rendered.getByText('There was an error!'))\n    expect(count).toBe(1)\n    consoleMock.mockRestore()\n  })\n\n  describe('gc (with fake timers)', () => {\n    beforeAll(() => {\n      vi.useFakeTimers()\n    })\n\n    afterAll(() => {\n      vi.useRealTimers()\n    })\n\n    it('should gc when unmounted while fetching with low gcTime (#8159)', async () => {\n      const key = queryKey()\n\n      function Page() {\n        return (\n          <React.Suspense fallback=\"loading\">\n            <Component />\n          </React.Suspense>\n        )\n      }\n\n      function Component() {\n        const { data } = useSuspenseQuery({\n          queryKey: key,\n          queryFn: async () => {\n            await sleep(3000)\n            return 'data'\n          },\n          gcTime: 1000,\n        })\n\n        return <div>{data}</div>\n      }\n\n      function Page2() {\n        return <div>page2</div>\n      }\n\n      function App() {\n        const [show, setShow] = React.useState(true)\n        return (\n          <div>\n            {show ? <Page /> : <Page2 />}\n            <button onClick={() => setShow(false)}>hide</button>\n          </div>\n        )\n      }\n\n      const rendered = renderWithClient(queryClient, <App />)\n\n      await act(() => vi.advanceTimersByTimeAsync(200))\n\n      rendered.getByText('loading')\n\n      // unmount while still fetching\n      fireEvent.click(rendered.getByText('hide'))\n\n      await act(() => vi.advanceTimersByTimeAsync(800))\n\n      rendered.getByText('page2')\n\n      // wait for query to be resolved\n      await act(() => vi.advanceTimersByTimeAsync(2000))\n\n      expect(queryClient.getQueryData(key)).toBe('data')\n\n      // wait for gc\n      await act(() => vi.advanceTimersByTimeAsync(1000))\n\n      expect(queryClient.getQueryData(key)).toBe(undefined)\n    })\n  })\n\n  it('should log an error when skipToken is passed as queryFn', () => {\n    const consoleErrorSpy = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => {})\n    const key = queryKey()\n\n    function Page() {\n      useSuspenseQueries({\n        queries: [\n          {\n            queryKey: key,\n            // @ts-expect-error\n            queryFn: Math.random() >= 0 ? skipToken : () => Promise.resolve(5),\n          },\n        ],\n      })\n\n      return null\n    }\n\n    function App() {\n      return (\n        <React.Suspense fallback=\"Loading...\">\n          <Page />\n        </React.Suspense>\n      )\n    }\n\n    renderWithClient(queryClient, <App />)\n\n    expect(consoleErrorSpy).toHaveBeenCalledWith(\n      'skipToken is not allowed for useSuspenseQueries',\n    )\n    consoleErrorSpy.mockRestore()\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: query\nTest File Path: query\\useSuspenseQuery.test.tsx\\useSuspenseQuery.test.tsx\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\n'use client'\nimport { QueryObserver, skipToken } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\n\nexport function useSuspenseQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseSuspenseQueryResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if ((options.queryFn as any) === skipToken) {\n      console.error('skipToken is not allowed for useSuspenseQuery')\n    }\n  }\n\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n      placeholderData: undefined,\n    },\n    QueryObserver,\n    queryClient,\n  ) as UseSuspenseQueryResult<TData, TError>\n}\n\n### Source File Dependency Files Content\n### Dependency File: suspense.ts\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  const originalStaleTime = defaultedOptions.staleTime\n\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => Math.max(originalStaleTime(...args), 1000)\n        : Math.max(originalStaleTime ?? 1000, 1000)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n\n\n### Dependency File: types.ts\n/* istanbul ignore file */\n\nimport type {\n  DefaultError,\n  DefinedInfiniteQueryObserverResult,\n  DefinedQueryObserverResult,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  MutateFunction,\n  MutationObserverOptions,\n  MutationObserverResult,\n  OmitKeyof,\n  Override,\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n  SkipToken,\n} from '@tanstack/query-core'\n\nexport type AnyUseBaseQueryOptions = UseBaseQueryOptions<\n  any,\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseBaseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n  /**\n   * Set this to `false` to unsubscribe this observer from updates to the query cache.\n   * Defaults to `true`.\n   */\n  subscribed?: boolean\n}\n\nexport type AnyUseQueryOptions = UseQueryOptions<any, any, any, any>\nexport interface UseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends OmitKeyof<\n    UseBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>,\n    'suspense'\n  > {}\n\nexport type AnyUseSuspenseQueryOptions = UseSuspenseQueryOptions<\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseSuspenseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryFn' | 'enabled' | 'throwOnError' | 'placeholderData'\n  > {\n  queryFn?: Exclude<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>['queryFn'],\n    SkipToken\n  >\n}\n\nexport type AnyUseInfiniteQueryOptions = UseInfiniteQueryOptions<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\nexport interface UseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends OmitKeyof<\n    InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'suspense'\n  > {\n  /**\n   * Set this to `false` to unsubscribe this observer from updates to the query cache.\n   * Defaults to `true`.\n   */\n  subscribed?: boolean\n}\n\nexport type AnyUseSuspenseInfiniteQueryOptions =\n  UseSuspenseInfiniteQueryOptions<any, any, any, any, any, any>\nexport interface UseSuspenseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends OmitKeyof<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'queryFn' | 'enabled' | 'throwOnError' | 'placeholderData'\n  > {\n  queryFn?: Exclude<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >['queryFn'],\n    SkipToken\n  >\n}\n\nexport type UseBaseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = QueryObserverResult<TData, TError>\n\nexport type UseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = UseBaseQueryResult<TData, TError>\n\nexport type UseSuspenseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = OmitKeyof<\n  DefinedQueryObserverResult<TData, TError>,\n  'isPlaceholderData' | 'promise'\n>\n\nexport type DefinedUseQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = DefinedQueryObserverResult<TData, TError>\n\nexport type UseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = InfiniteQueryObserverResult<TData, TError>\n\nexport type DefinedUseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = DefinedInfiniteQueryObserverResult<TData, TError>\n\nexport type UseSuspenseInfiniteQueryResult<\n  TData = unknown,\n  TError = DefaultError,\n> = OmitKeyof<\n  DefinedInfiniteQueryObserverResult<TData, TError>,\n  'isPlaceholderData' | 'promise'\n>\n\nexport type AnyUseMutationOptions = UseMutationOptions<any, any, any, any>\nexport interface UseMutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends OmitKeyof<\n    MutationObserverOptions<TData, TError, TVariables, TContext>,\n    '_defaulted'\n  > {}\n\nexport type UseMutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...args: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\nexport type UseMutateAsyncFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = MutateFunction<TData, TError, TVariables, TContext>\n\nexport type UseBaseMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = Override<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  { mutate: UseMutateFunction<TData, TError, TVariables, TContext> }\n> & { mutateAsync: UseMutateAsyncFunction<TData, TError, TVariables, TContext> }\n\nexport type UseMutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> = UseBaseMutationResult<TData, TError, TVariables, TContext>\n\n\n### Dependency File: useBaseQuery.ts\n'use client'\nimport * as React from 'react'\n\nimport { isServer, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport { noop } from './utils'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`,\n      )\n    }\n  }\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions)\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n      suspense: defaultedOptions.suspense,\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:05:47"}, {"role": "assistant", "content": "```ts\nimport { describe, expect, it, vi } from 'vitest'\nimport { fireEvent, waitFor } from '@testing-library/react'\nimport * as React from 'react'\nimport { ErrorBoundary } from 'react-error-boundary'\nimport {\n  QueryCache,\n  QueryErrorResetBoundary,\n  skipToken,\n  useQueryErrorResetBoundary,\n  useSuspenseInfiniteQuery,\n  useSuspenseQuery,\n} from '..'\nimport { createQueryClient, queryKey, renderWithClient, sleep } from './utils'\nimport type {\n  InfiniteData,\n  UseSuspenseInfiniteQueryResult,\n  UseSuspenseQueryResult,\n} from '..'\n\ndescribe('useSuspenseQuery', () => {\n  const queryCache = new QueryCache()\n  const queryClient = createQueryClient({ queryCache })\n\n  it('should render the correct amount of times in Suspense mode', async () => {\n    const key = queryKey()\n    const states: Array<UseSuspenseQueryResult<number>> = []\n\n    let count = 0\n    let renders = 0\n\n    function Page() {\n      renders++\n\n      const [stateKey, setStateKey] = React.useState(key)\n\n      const state = useSuspenseQuery({\n        queryKey: stateKey,\n        queryFn: async () => {\n          count++\n          await sleep(10)\n          return count\n        },\n      })\n\n      states.push(state)\n\n      return (\n        <div>\n          <button aria-label=\"toggle\" onClick={() => setStateKey(queryKey())} />\n          data: {String(state.data)}\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <React.Suspense fallback=\"loading\">\n        <Page />\n      </React.Suspense>,\n    )\n\n    await waitFor(() => rendered.getByText('data: 1'))\n    fireEvent.click(rendered.getByLabelText('toggle'))\n\n    await waitFor(() => rendered.getByText('data: 2'))\n\n    expect(renders).toBe(6)\n    expect(states.length).toBe(2)\n    expect(states[0]).toMatchObject({ data: 1, status: 'success' })\n    expect(states[1]).toMatchObject({ data: 2, status: 'success' })\n  })\n\n  it('should return the correct states for a successful infinite query', async () => {\n    const key = queryKey()\n    const states: Array<UseSuspenseInfiniteQueryResult<InfiniteData<number>>> =\n      []\n\n    function Page() {\n      const [multiplier, setMultiplier] = React.useState(1)\n      const state = useSuspenseInfiniteQuery({\n        queryKey: [`${key}_${multiplier}`],\n        queryFn: async ({ pageParam }) => {\n          await sleep(10)\n          return Number(pageParam * multiplier)\n        },\n        initialPageParam: 1,\n        getNextPageParam: (lastPage) => lastPage + 1,\n      })\n      states.push(state)\n      return (\n        <div>\n          <button onClick={() => setMultiplier(2)}>next</button>\n          data: {state.data?.pages.join(',')}\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <React.Suspense fallback=\"loading\">\n        <Page />\n      </React.Suspense>,\n    )\n\n    await waitFor(() => rendered.getByText('data: 1'))\n\n    expect(states.length).toBe(1)\n    expect(states[0]).toMatchObject({\n      data: { pages: [1], pageParams: [1] },\n      status: 'success',\n    })\n\n    fireEvent.click(rendered.getByText('next'))\n    await waitFor(() => rendered.getByText('data: 2'))\n\n    expect(states.length).toBe(2)\n    expect(states[1]).toMatchObject({\n      data: { pages: [2], pageParams: [1] },\n      status: 'success',\n    })\n  })\n\n  it('should not call the queryFn twice when used in Suspense mode', async () => {\n    const key = queryKey()\n\n    const queryFn = vi.fn<(...args: Array<unknown>) => string>()\n    queryFn.mockImplementation(() => {\n      sleep(10)\n      return 'data'\n    })\n\n    function Page() {\n      useSuspenseQuery({ queryKey: [key], queryFn })\n\n      return <>rendered</>\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <React.Suspense fallback=\"loading\">\n        <Page />\n      </React.Suspense>,\n    )\n\n    await waitFor(() => rendered.getByText('rendered'))\n\n    expect(queryFn).toHaveBeenCalledTimes(1)\n  })\n\n  it('should remove query instance when component unmounted', async () => {\n    const key = queryKey()\n\n    function Page() {\n      useSuspenseQuery({\n        queryKey: key,\n        queryFn: () => {\n          sleep(10)\n          return 'data'\n        },\n      })\n\n      return <>rendered</>\n    }\n\n    function App() {\n      const [show, setShow] = React.useState(false)\n\n      return (\n        <>\n          <React.Suspense fallback=\"loading\">{show && <Page />}</React.Suspense>\n          <button\n            aria-label=\"toggle\"\n            onClick={() => setShow((prev) => !prev)}\n          />\n        </>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    expect(rendered.queryByText('rendered')).toBeNull()\n    expect(queryCache.find({ queryKey: key })).toBeFalsy()\n\n    fireEvent.click(rendered.getByLabelText('toggle'))\n    await waitFor(() => rendered.getByText('rendered'))\n\n    expect(queryCache.find({ queryKey: key })?.getObserversCount()).toBe(1)\n\n    fireEvent.click(rendered.getByLabelText('toggle'))\n\n    expect(rendered.queryByText('rendered')).toBeNull()\n    expect(queryCache.find({ queryKey: key })?.getObserversCount()).toBe(0)\n  })\n\n  // https://github.com/tannerlinsley/react-query/issues/468\n  it('should reset error state if new component instances are mounted', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    const key = queryKey()\n\n    let succeed = false\n\n    function Page() {\n      useSuspenseQuery({\n        queryKey: key,\n        queryFn: async () => {\n          await sleep(10)\n\n          if (!succeed) {\n            throw new Error('Suspense Error Bingo')\n          } else {\n            return 'data'\n          }\n        },\n        retryDelay: 10,\n      })\n\n      return <div>rendered</div>\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <QueryErrorResetBoundary>\n        {({ reset }) => (\n          <ErrorBoundary\n            onReset={reset}\n            fallbackRender={({ resetErrorBoundary }) => (\n              <div>\n                <div>error boundary</div>\n                <button\n                  onClick={() => {\n                    succeed = true\n                    resetErrorBoundary()\n                  }}\n                >\n                  retry\n                </button>\n              </div>\n            )}\n          >\n            <React.Suspense fallback={'Loading...'}>\n              <Page />\n            </React.Suspense>\n          </ErrorBoundary>\n        )}\n      </QueryErrorResetBoundary>,\n    )\n\n    await waitFor(() => rendered.getByText('Loading...'))\n\n    await waitFor(() => rendered.getByText('error boundary'))\n\n    await waitFor(() => rendered.getByText('retry'))\n\n    fireEvent.click(rendered.getByText('retry'))\n\n    await waitFor(() => rendered.getByText('rendered'))\n\n    expect(consoleMock.mock.calls[0]?.[1]).toStrictEqual(\n      new Error('Suspense Error Bingo'),\n    )\n\n    consoleMock.mockRestore()\n  })\n\n  it('should retry fetch if the reset error boundary has been reset', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    const key = queryKey()\n\n    let succeed = false\n\n    function Page() {\n      useSuspenseQuery({\n        queryKey: key,\n        queryFn: async () => {\n          await sleep(10)\n          if (!succeed) {\n            throw new Error('Suspense Error Bingo')\n          } else {\n            return 'data'\n          }\n        },\n        retry: false,\n      })\n      return <div>rendered</div>\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <QueryErrorResetBoundary>\n        {({ reset }) => (\n          <ErrorBoundary\n            onReset={reset}\n            fallbackRender={({ resetErrorBoundary }) => (\n              <div>\n                <div>error boundary</div>\n                <button\n                  onClick={() => {\n                    resetErrorBoundary()\n                  }}\n                >\n                  retry\n                </button>\n              </div>\n            )}\n          >\n            <React.Suspense fallback=\"Loading...\">\n              <Page />\n            </React.Suspense>\n          </ErrorBoundary>\n        )}\n      </QueryErrorResetBoundary>,\n    )\n\n    await waitFor(() => rendered.getByText('Loading...'))\n    await waitFor(() => rendered.getByText('error boundary'))\n    await waitFor(() => rendered.getByText('retry'))\n    fireEvent.click(rendered.getByText('retry'))\n    await waitFor(() => rendered.getByText('error boundary'))\n    await waitFor(() => rendered.getByText('retry'))\n    succeed = true\n    fireEvent.click(rendered.getByText('retry'))\n    await waitFor(() => rendered.getByText('rendered'))\n    consoleMock.mockRestore()\n  })\n\n  it('should set staleTime when having passed a function', async () => {\n    const key = queryKey()\n    let count = 0\n\n    function Component() {\n      const result = useSuspenseQuery({\n        queryKey: key,\n        queryFn: async () => {\n          await sleep(5)\n          count++\n          return count\n        },\n        staleTime: () => 60 * 1000,\n      })\n      return (\n        <div>\n          <span>data: {result.data}</span>\n        </div>\n      )\n    }\n\n    function Page() {\n      return (\n        <React.Suspense fallback=\"Loading...\">\n          <Component />\n        </React.Suspense>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <Page />)\n\n    await waitFor(() => rendered.getByText('Loading...'))\n    await waitFor(() => rendered.getByText('data: 1'))\n\n    expect(\n      typeof queryClient.getQueryCache().find({ queryKey: key })?.observers[0]\n        ?.options.staleTime,\n    ).toBe('function')\n  })\n\n  it('should suspend when switching to a new query', async () => {\n    const key1 = queryKey()\n    const key2 = queryKey()\n\n    function Component(props: { queryKey: Array<string> }) {\n      const result = useSuspenseQuery({\n        queryKey: props.queryKey,\n        queryFn: async () => {\n          await sleep(100)\n          return props.queryKey\n        },\n\n        retry: false,\n      })\n      return <div>data: {result.data}</div>\n    }\n\n    function Page() {\n      const [key, setKey] = React.useState(key1)\n      return (\n        <div>\n          <button\n            onClick={() => {\n              setKey(key2)\n            }}\n          >\n            switch\n          </button>\n          <React.Suspense fallback=\"Loading...\">\n            <Component queryKey={key} />\n          </React.Suspense>\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <Page />)\n\n    await waitFor(() => rendered.getByText('Loading...'))\n    await waitFor(() => rendered.getByText(`data: ${key1}`))\n    fireEvent.click(rendered.getByText('switch'))\n    await waitFor(() => rendered.getByText('Loading...'))\n    await waitFor(() => rendered.getByText(`data: ${key2}`))\n  })\n\n  it('should retry fetch if the reset error boundary has been reset with global hook', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    const key = queryKey()\n\n    let succeed = false\n\n    function Page() {\n      useSuspenseQuery({\n        queryKey: key,\n        queryFn: async () => {\n          await sleep(10)\n          if (!succeed) {\n            throw new Error('Suspense Error Bingo')\n          } else {\n            return 'data'\n          }\n        },\n        retry: false,\n      })\n      return <div>rendered</div>\n    }\n\n    function App() {\n      const { reset } = useQueryErrorResetBoundary()\n      return (\n        <ErrorBoundary\n          onReset={reset}\n          fallbackRender={({ resetErrorBoundary }) => (\n            <div>\n              <div>error boundary</div>\n              <button\n                onClick={() => {\n                  resetErrorBoundary()\n                }}\n              >\n                retry\n              </button>\n            </div>\n          )}\n        >\n          <React.Suspense fallback=\"Loading...\">\n            <Page />\n          </React.Suspense>\n        </ErrorBoundary>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    await waitFor(() => rendered.getByText('Loading...'))\n    await waitFor(() => rendered.getByText('error boundary'))\n    await waitFor(() => rendered.getByText('retry'))\n    fireEvent.click(rendered.getByText('retry'))\n    await waitFor(() => rendered.getByText('error boundary'))\n    await waitFor(() => rendered.getByText('retry'))\n    succeed = true\n    fireEvent.click(rendered.getByText('retry'))\n    await waitFor(() => rendered.getByText('rendered'))\n    consoleMock.mockRestore()\n  })\n\n  it('should throw errors to the error boundary by default', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    const key = queryKey()\n\n    function Page() {\n      useSuspenseQuery({\n        queryKey: key,\n        queryFn: async (): Promise<unknown> => {\n          await sleep(10)\n          throw new Error('Suspense Error a1x')\n        },\n        retry: false,\n      })\n      return <div>rendered</div>\n    }\n\n    function App() {\n      return (\n        <ErrorBoundary\n          fallbackRender={() => (\n            <div>\n              <div>error boundary</div>\n            </div>\n          )}\n        >\n          <React.Suspense fallback=\"Loading...\">\n            <Page />\n          </React.Suspense>\n        </ErrorBoundary>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    await waitFor(() => rendered.getByText('Loading...'))\n    await waitFor(() => rendered.getByText('error boundary'))\n    consoleMock.mockRestore()\n  })\n\n  it('should throw select errors to the error boundary by default', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    const key = queryKey()\n\n    function Page() {\n      useSuspenseQuery({\n        queryKey: key,\n        queryFn: () => {\n          const data = { a: { b: 'c' } }\n          return Promise.resolve(data)\n        },\n        select: () => {\n          throw new Error('foo')\n        },\n      })\n      return <div>rendered</div>\n    }\n\n    function App() {\n      return (\n        <ErrorBoundary\n          fallbackRender={() => (\n            <div>\n              <div>error boundary</div>\n            </div>\n          )}\n        >\n          <React.Suspense fallback=\"Loading...\">\n            <Page />\n          </React.Suspense>\n        </ErrorBoundary>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    await waitFor(() => rendered.getByText('Loading...'))\n    await waitFor(() => rendered.getByText('error boundary'))\n    consoleMock.mockRestore()\n  })\n\n  it('should error caught in error boundary without infinite loop', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    const key = queryKey()\n\n    let succeed = true\n\n    function Page() {\n      const [nonce] = React.useState(0)\n      const queryKeys = [`${key}-${succeed}`]\n      const result = useSuspenseQuery({\n        queryKey: queryKeys,\n        queryFn: async () => {\n          await sleep(10)\n          if (!succeed) {\n            throw new Error('Suspense Error Bingo')\n          } else {\n            return nonce\n          }\n        },\n        retry: false,\n      })\n      return (\n        <div>\n          <span>rendered</span> <span>{result.data}</span>\n          <button\n            aria-label=\"fail\"\n            onClick={async () => {\n              await queryClient.resetQueries()\n            }}\n          >\n            fail\n          </button>\n        </div>\n      )\n    }\n\n    function App() {\n      const { reset } = useQueryErrorResetBoundary()\n      return (\n        <ErrorBoundary\n          onReset={reset}\n          fallbackRender={() => <div>error boundary</div>}\n        >\n          <React.Suspense fallback=\"Loading...\">\n            <Page />\n          </React.Suspense>\n        </ErrorBoundary>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    // render suspense fallback (Loading...)\n    await waitFor(() => rendered.getByText('Loading...'))\n    // resolve promise -> render Page (rendered)\n    await waitFor(() => rendered.getByText('rendered'))\n\n    // change query key\n    succeed = false\n    // reset query -> and throw error\n    fireEvent.click(rendered.getByLabelText('fail'))\n    // render error boundary fallback (error boundary)\n    await waitFor(() => rendered.getByText('error boundary'))\n    expect(consoleMock.mock.calls[0]?.[1]).toStrictEqual(\n      new Error('Suspense Error Bingo'),\n    )\n\n    consoleMock.mockRestore()\n  })\n\n  it('should error caught in error boundary without infinite loop when query keys changed', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    let succeed = true\n\n    function Page() {\n      const [key, rerender] = React.useReducer((x) => x + 1, 0)\n      const queryKeys = [key, succeed]\n\n      const result = useSuspenseQuery({\n        queryKey: queryKeys,\n        queryFn: async () => {\n          await sleep(10)\n          if (!succeed) {\n            throw new Error('Suspense Error Bingo')\n          } else {\n            return 'data'\n          }\n        },\n        retry: false,\n      })\n\n      if (result.error) {\n        throw result.error\n      }\n\n      return (\n        <div>\n          <span>rendered</span> <span>{result.data}</span>\n          <button aria-label=\"fail\" onClick={rerender}>\n            fail\n          </button>\n        </div>\n      )\n    }\n\n    function App() {\n      const { reset } = useQueryErrorResetBoundary()\n      return (\n        <ErrorBoundary\n          onReset={reset}\n          fallbackRender={() => <div>error boundary</div>}\n        >\n          <React.Suspense fallback=\"Loading...\">\n            <Page />\n          </React.Suspense>\n        </ErrorBoundary>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    // render suspense fallback (Loading...)\n    await waitFor(() => rendered.getByText('Loading...'))\n    // resolve promise -> render Page (rendered)\n    await waitFor(() => rendered.getByText('rendered'))\n\n    // change promise result to error\n    succeed = false\n    // change query key\n    fireEvent.click(rendered.getByLabelText('fail'))\n    // render error boundary fallback (error boundary)\n    await waitFor(() => rendered.getByText('error boundary'))\n    expect(consoleMock.mock.calls[0]?.[1]).toStrictEqual(\n      new Error('Suspense Error Bingo'),\n    )\n\n    consoleMock.mockRestore()\n  })\n\n  it('should render the correct amount of times in Suspense mode when gcTime is set to 0', async () => {\n    const key = queryKey()\n    let state: UseSuspenseQueryResult<number> | null = null\n\n    let count = 0\n    let renders = 0\n\n    function Page() {\n      renders++\n\n      state = useSuspenseQuery({\n        queryKey: key,\n        queryFn: async () => {\n          count++\n          await sleep(10)\n          return count\n        },\n        gcTime: 0,\n      })\n\n      return (\n        <div>\n          <span>rendered</span>\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClient,\n      <React.Suspense fallback=\"loading\">\n        <Page />\n      </React.Suspense>,\n    )\n\n    await waitFor(() =>\n      expect(state).toMatchObject({\n        data: 1,\n        status: 'success',\n      }),\n    )\n\n    expect(renders).toBe(3)\n    await waitFor(() => expect(rendered.queryByText('rendered')).not.toBeNull())\n  })\n\n  it('should not throw background errors to the error boundary', async () => {\n    const consoleMock = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => undefined)\n    let succeed = true\n    const key = queryKey()\n\n    function Page() {\n      const result = useSuspenseQuery({\n        queryKey: key,\n        queryFn: async () => {\n          await sleep(10)\n          if (!succeed) {\n            throw new Error('Suspense Error Bingo')\n          } else {\n            return 'data'\n          }\n        },\n        retry: false,\n      })\n\n      return (\n        <div>\n          <span>\n            rendered {result.data} {result.status}\n          </span>\n          <button onClick={() => result.refetch()}>refetch</button>\n        </div>\n      )\n    }\n\n    function App() {\n      const { reset } = useQueryErrorResetBoundary()\n      return (\n        <ErrorBoundary\n          onReset={reset}\n          fallbackRender={() => <div>error boundary</div>}\n        >\n          <React.Suspense fallback=\"Loading...\">\n            <Page />\n          </React.Suspense>\n        </ErrorBoundary>\n      )\n    }\n\n    const rendered = renderWithClient(queryClient, <App />)\n\n    // render suspense fallback (Loading...)\n    await waitFor(() => rendered.getByText('Loading...'))\n    // resolve promise -> render Page (rendered)\n    await waitFor(() => rendered.getByText('rendered data success'))\n\n    // change promise result to error\n    succeed = false\n    // refetch\n    fireEvent.click(rendered.getByRole('button', { name: 'refetch' }))\n    // we are now in error state but still have data to show\n    await waitFor(() => rendered.getByText('rendered data error'))\n\n    consoleMock.mockRestore()\n  })\n\n  it('should still suspense if queryClient has placeholderData config', async () => {\n    const key = queryKey()\n    const queryClientWithPlaceholder = createQueryClient({\n      defaultOptions: {\n        queries: {\n          placeholderData: (previousData: any) => previousData,\n        },\n      },\n    })\n    const states: Array<UseSuspenseQueryResult<number>> = []\n\n    let count = 0\n\n    function Page() {\n      const [stateKey, setStateKey] = React.useState(key)\n\n      const state = useSuspenseQuery({\n        queryKey: stateKey,\n        queryFn: async () => {\n          count++\n          await sleep(100)\n          return count\n        },\n      })\n\n      states.push(state)\n\n      return (\n        <div>\n          <button aria-label=\"toggle\" onClick={() => setStateKey(queryKey())} />\n          data: {String(state.data)}\n        </div>\n      )\n    }\n\n    const rendered = renderWithClient(\n      queryClientWithPlaceholder,\n      <React.Suspense fallback=\"loading\">\n        <Page />\n      </React.Suspense>,\n    )\n    await waitFor(() => rendered.getByText('loading'))\n    await waitFor(() => rendered.getByText('data: 1'))\n    fireEvent.click(rendered.getByLabelText('toggle'))\n\n    await waitFor(() => rendered.getByText('loading'))\n    await waitFor(() => rendered.getByText('data: 2'))\n  })\n\n  it('should log an error when skipToken is passed as queryFn', () => {\n    const consoleErrorSpy = vi\n      .spyOn(console, 'error')\n      .mockImplementation(() => {})\n    const key = queryKey()\n\n    function Page() {\n      useSuspenseQuery({\n        queryKey: key,\n        // @ts-expect-error\n        queryFn: Math.random() >= 0 ? skipToken : () => Promise.resolve(5),\n      })\n\n      return null\n    }\n\n    function App() {\n      return (\n        <React.Suspense fallback=\"Loading...\">\n          <Page />\n        </React.Suspense>\n      )\n    }\n\n    renderWithClient(queryClient, <App />)\n\n    expect(consoleErrorSpy).toHaveBeenCalledWith(\n      'skipToken is not allowed for useSuspenseQuery',\n    )\n    consoleErrorSpy.mockRestore()\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: radash\nTest File Path: radash\\array.test.ts\\array.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { isArray, isFunction } from './typed'\n\n/**\n * Sorts an array of items into groups. The return value is a map where the keys are\n * the group ids the given getGroupId function produced and the value is an array of\n * each item in that group.\n */\nexport const group = <T, Key extends string | number | symbol>(\n  array: readonly T[],\n  getGroupId: (item: T) => Key\n): Partial<Record<Key, T[]>> => {\n  return array.reduce((acc, item) => {\n    const groupId = getGroupId(item)\n    if (!acc[groupId]) acc[groupId] = []\n    acc[groupId].push(item)\n    return acc\n  }, {} as Record<Key, T[]>)\n}\n\n/**\n * Creates an array of grouped elements, the first of which contains the\n * first elements of the given arrays, the second of which contains the\n * second elements of the given arrays, and so on.\n *\n * Ex. const zipped = zip(['a', 'b'], [1, 2], [true, false]) // [['a', 1, true], ['b', 2, false]]\n */\nexport function zip<T1, T2, T3, T4, T5>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[],\n  array5: T5[]\n): [T1, T2, T3, T4, T5][]\nexport function zip<T1, T2, T3, T4>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[]\n): [T1, T2, T3, T4][]\nexport function zip<T1, T2, T3>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[]\n): [T1, T2, T3][]\nexport function zip<T1, T2>(array1: T1[], array2: T2[]): [T1, T2][]\nexport function zip<T>(...arrays: T[][]): T[][] {\n  if (!arrays || !arrays.length) return []\n  return new Array(Math.max(...arrays.map(({ length }) => length)))\n    .fill([])\n    .map((_, idx) => arrays.map(array => array[idx]))\n}\n\n/**\n * Creates an object mapping the specified keys to their corresponding values\n *\n * Ex. const zipped = zipToObject(['a', 'b'], [1, 2]) // { a: 1, b: 2 }\n * Ex. const zipped = zipToObject(['a', 'b'], (k, i) => k + i) // { a: 'a0', b: 'b1' }\n * Ex. const zipped = zipToObject(['a', 'b'], 1) // { a: 1, b: 1 }\n */\nexport function zipToObject<K extends string | number | symbol, V>(\n  keys: K[],\n  values: V | ((key: K, idx: number) => V) | V[]\n): Record<K, V> {\n  if (!keys || !keys.length) {\n    return {} as Record<K, V>\n  }\n\n  const getValue = isFunction(values)\n    ? values\n    : isArray(values)\n    ? (_k: K, i: number) => values[i]\n    : (_k: K, _i: number) => values\n\n  return keys.reduce((acc, key, idx) => {\n    acc[key] = getValue(key, idx)\n    return acc\n  }, {} as Record<K, V>)\n}\n\n/**\n * Go through a list of items, starting with the first item,\n * and comparing with the second. Keep the one you want then\n * compare that to the next item in the list with the same\n *\n * Ex. const greatest = () => boil(numbers, (a, b) => a > b)\n */\nexport const boil = <T>(\n  array: readonly T[],\n  compareFunc: (a: T, b: T) => T\n) => {\n  if (!array || (array.length ?? 0) === 0) return null\n  return array.reduce(compareFunc)\n}\n\n/**\n * Sum all numbers in an array. Optionally provide a function\n * to convert objects in the array to number values.\n */\nexport function sum<T extends number>(array: readonly T[]): number\nexport function sum<T extends object>(\n  array: readonly T[],\n  fn: (item: T) => number\n): number\nexport function sum<T extends object | number>(\n  array: readonly any[],\n  fn?: (item: T) => number\n): number {\n  return (array || []).reduce((acc, item) => acc + (fn ? fn(item) : item), 0)\n}\n\n/**\n * Get the first item in an array or a default value\n */\nexport const first = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[0] : defaultValue\n}\n\n/**\n * Get the last item in an array or a default value\n */\nexport const last = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[array.length - 1] : defaultValue\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value\n */\nexport const sort = <T>(\n  array: readonly T[],\n  getter: (item: T) => number,\n  desc = false\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => getter(a) - getter(b)\n  const dsc = (a: T, b: T) => getter(b) - getter(a)\n  return array.slice().sort(desc === true ? dsc : asc)\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value. Allows for a string\n * sorting value.\n */\nexport const alphabetical = <T>(\n  array: readonly T[],\n  getter: (item: T) => string,\n  dir: 'asc' | 'desc' = 'asc'\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => `${getter(a)}`.localeCompare(getter(b))\n  const dsc = (a: T, b: T) => `${getter(b)}`.localeCompare(getter(a))\n  return array.slice().sort(dir === 'desc' ? dsc : asc)\n}\n\nexport const counting = <T, TId extends string | number | symbol>(\n  list: readonly T[],\n  identity: (item: T) => TId\n): Record<TId, number> => {\n  if (!list) return {} as Record<TId, number>\n  return list.reduce((acc, item) => {\n    const id = identity(item)\n    acc[id] = (acc[id] ?? 0) + 1\n    return acc\n  }, {} as Record<TId, number>)\n}\n\n/**\n * Replace an element in an array with a new\n * item without modifying the array and return\n * the new value\n */\nexport const replace = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (item: T, idx: number) => boolean\n): T[] => {\n  if (!list) return []\n  if (newItem === undefined) return [...list]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list]\n}\n\n/**\n * Convert an array to a dictionary by mapping each item\n * into a dictionary key & value\n */\nexport const objectify = <T, Key extends string | number | symbol, Value = T>(\n  array: readonly T[],\n  getKey: (item: T) => Key,\n  getValue: (item: T) => Value = item => item as unknown as Value\n): Record<Key, Value> => {\n  return array.reduce((acc, item) => {\n    acc[getKey(item)] = getValue(item)\n    return acc\n  }, {} as Record<Key, Value>)\n}\n\n/**\n * Select performs a filter and a mapper inside of a reduce,\n * only iterating the list one time.\n *\n * @example\n * select([1, 2, 3, 4], x => x*x, x > 2) == [9, 16]\n */\nexport const select = <T, K>(\n  array: readonly T[],\n  mapper: (item: T, index: number) => K,\n  condition: (item: T, index: number) => boolean\n) => {\n  if (!array) return []\n  return array.reduce((acc, item, index) => {\n    if (!condition(item, index)) return acc\n    acc.push(mapper(item, index))\n    return acc\n  }, [] as K[])\n}\n\n/**\n * Max gets the greatest value from a list\n *\n * @example\n * max([ 2, 3, 5]) == 5\n * max([{ num: 1 }, { num: 2 }], x => x.num) == { num: 2 }\n */\nexport function max(array: readonly [number, ...number[]]): number\nexport function max(array: readonly number[]): number | null\nexport function max<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function max<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) > get(b) ? a : b))\n}\n\n/**\n * Min gets the smallest value from a list\n *\n * @example\n * min([1, 2, 3, 4]) == 1\n * min([{ num: 1 }, { num: 2 }], x => x.num) == { num: 1 }\n */\nexport function min(array: readonly [number, ...number[]]): number\nexport function min(array: readonly number[]): number | null\nexport function min<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function min<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) < get(b) ? a : b))\n}\n\n/**\n * Splits a single list into many lists of the desired size. If\n * given a list of 10 items and a size of 2, it will return 5\n * lists with 2 items each\n */\nexport const cluster = <T>(list: readonly T[], size: number = 2): T[][] => {\n  const clusterCount = Math.ceil(list.length / size)\n  return new Array(clusterCount).fill(null).map((_c: null, i: number) => {\n    return list.slice(i * size, i * size + size)\n  })\n}\n\n/**\n * Given a list of items returns a new list with only\n * unique items. Accepts an optional identity function\n * to convert each item in the list to a comparable identity\n * value\n */\nexport const unique = <T, K extends string | number | symbol>(\n  array: readonly T[],\n  toKey?: (item: T) => K\n): T[] => {\n  const valueMap = array.reduce((acc, item) => {\n    const key = toKey ? toKey(item) : (item as any as string | number | symbol)\n    if (acc[key]) return acc\n    acc[key] = item\n    return acc\n  }, {} as Record<string | number | symbol, T>)\n  return Object.values(valueMap)\n}\n\n/**\n * Creates a generator that will produce an iteration through\n * the range of number as requested.\n *\n * @example\n * range(3)                  // yields 0, 1, 2, 3\n * range(0, 3)               // yields 0, 1, 2, 3\n * range(0, 3, 'y')          // yields y, y, y, y\n * range(0, 3, () => 'y')    // yields y, y, y, y\n * range(0, 3, i => i)       // yields 0, 1, 2, 3\n * range(0, 3, i => `y${i}`) // yields y0, y1, y2, y3\n * range(0, 3, obj)          // yields obj, obj, obj, obj\n * range(0, 6, i => i, 2)    // yields 0, 2, 4, 6\n */\nexport function* range<T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper: T | ((i: number) => T) = i => i as T,\n  step: number = 1\n): Generator<T> {\n  const mapper = isFunction(valueOrMapper) ? valueOrMapper : () => valueOrMapper\n  const start = end ? startOrLength : 0\n  const final = end ?? startOrLength\n  for (let i = start; i <= final; i += step) {\n    yield mapper(i)\n    if (i + step > final) break\n  }\n}\n\n/**\n * Creates a list of given start, end, value, and\n * step parameters.\n *\n * @example\n * list(3)                  // 0, 1, 2, 3\n * list(0, 3)               // 0, 1, 2, 3\n * list(0, 3, 'y')          // y, y, y, y\n * list(0, 3, () => 'y')    // y, y, y, y\n * list(0, 3, i => i)       // 0, 1, 2, 3\n * list(0, 3, i => `y${i}`) // y0, y1, y2, y3\n * list(0, 3, obj)          // obj, obj, obj, obj\n * list(0, 6, i => i, 2)    // 0, 2, 4, 6\n */\nexport const list = <T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper?: T | ((i: number) => T),\n  step?: number\n): T[] => {\n  return Array.from(range(startOrLength, end, valueOrMapper, step))\n}\n\n/**\n * Given an array of arrays, returns a single\n * dimentional array with all items in it.\n */\nexport const flat = <T>(lists: readonly T[][]): T[] => {\n  return lists.reduce((acc, list) => {\n    acc.push(...list)\n    return acc\n  }, [])\n}\n\n/**\n * Given two arrays, returns true if any\n * elements intersect\n */\nexport const intersects = <T, K extends string | number | symbol>(\n  listA: readonly T[],\n  listB: readonly T[],\n  identity?: (t: T) => K\n): boolean => {\n  if (!listA || !listB) return false\n  const ident = identity ?? ((x: T) => x as unknown as K)\n  const dictB = listB.reduce((acc, item) => {\n    acc[ident(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return listA.some(value => dictB[ident(value)])\n}\n\n/**\n * Split an array into two array based on\n * a true/false condition function\n */\nexport const fork = <T>(\n  list: readonly T[],\n  condition: (item: T) => boolean\n): [T[], T[]] => {\n  if (!list) return [[], []]\n  return list.reduce(\n    (acc, item) => {\n      const [a, b] = acc\n      if (condition(item)) {\n        return [[...a, item], b]\n      } else {\n        return [a, [...b, item]]\n      }\n    },\n    [[], []] as [T[], T[]]\n  )\n}\n\n/**\n * Given two lists of the same type, iterate the first list\n * and replace items matched by the matcher func in the\n * first place.\n */\nexport const merge = <T>(\n  root: readonly T[],\n  others: readonly T[],\n  matcher: (item: T) => any\n) => {\n  if (!others && !root) return []\n  if (!others) return root\n  if (!root) return []\n  if (!matcher) return root\n  return root.reduce((acc, r) => {\n    const matched = others.find(o => matcher(r) === matcher(o))\n    if (matched) acc.push(matched)\n    else acc.push(r)\n    return acc\n  }, [] as T[])\n}\n\n/**\n * Replace an item in an array by a match function condition. If\n * no items match the function condition, appends the new item to\n * the end of the list.\n */\nexport const replaceOrAppend = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (a: T, idx: number) => boolean\n) => {\n  if (!list && !newItem) return []\n  if (!newItem) return [...list]\n  if (!list) return [newItem]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list, newItem]\n}\n\n/**\n * If the item matching the condition already exists\n * in the list it will be removed. If it does not it\n * will be added.\n */\nexport const toggle = <T>(\n  list: readonly T[],\n  item: T,\n  /**\n   * Converts an item of type T item into a value that\n   * can be checked for equality\n   */\n  toKey?: null | ((item: T, idx: number) => number | string | symbol),\n  options?: {\n    strategy?: 'prepend' | 'append'\n  }\n) => {\n  if (!list && !item) return []\n  if (!list) return [item]\n  if (!item) return [...list]\n  const matcher = toKey\n    ? (x: T, idx: number) => toKey(x, idx) === toKey(item, idx)\n    : (x: T) => x === item\n  const existing = list.find(matcher)\n  if (existing) return list.filter((x, idx) => !matcher(x, idx))\n  const strategy = options?.strategy ?? 'append'\n  if (strategy === 'append') return [...list, item]\n  return [item, ...list]\n}\n\ntype Falsy = null | undefined | false | '' | 0 | 0n\n\n/**\n * Given a list returns a new list with\n * only truthy values\n */\nexport const sift = <T>(list: readonly (T | Falsy)[]): T[] => {\n  return (list?.filter(x => !!x) as T[]) ?? []\n}\n\n/**\n * Like a reduce but does not require an array.\n * Only need a number and will iterate the function\n * as many times as specified.\n *\n * NOTE: This is NOT zero indexed. If you pass count=5\n * you will get 1, 2, 3, 4, 5 iteration in the callback\n * function\n */\nexport const iterate = <T>(\n  count: number,\n  func: (currentValue: T, iteration: number) => T,\n  initValue: T\n) => {\n  let value = initValue\n  for (let i = 1; i <= count; i++) {\n    value = func(value, i)\n  }\n  return value\n}\n\n/**\n * Returns all items from the first list that\n * do not exist in the second list.\n */\nexport const diff = <T>(\n  root: readonly T[],\n  other: readonly T[],\n  identity: (item: T) => string | number | symbol = (t: T) =>\n    t as unknown as string | number | symbol\n): T[] => {\n  if (!root?.length && !other?.length) return []\n  if (root?.length === undefined) return [...other]\n  if (!other?.length) return [...root]\n  const bKeys = other.reduce((acc, item) => {\n    acc[identity(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return root.filter(a => !bKeys[identity(a)])\n}\n\n/**\n * Shift array items by n steps\n * If n > 0 items will shift n steps to the right\n * If n < 0 items will shift n steps to the left\n */\nexport function shift<T>(arr: Array<T>, n: number) {\n  if (arr.length === 0) return arr\n\n  const shiftNumber = n % arr.length\n\n  if (shiftNumber === 0) return arr\n\n  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)]\n}\n\n### Source File Dependency Files Content\n### Dependency File: typed.ts\nexport const isSymbol = (value: any): value is symbol => {\n  return !!value && value.constructor === Symbol\n}\n\nexport const isArray = Array.isArray\n\nexport const isObject = (value: any): value is object => {\n  return !!value && value.constructor === Object\n}\n\n/**\n * Checks if the given value is primitive.\n *\n * Primitive Types: number , string , boolean , symbol, bigint, undefined, null\n *\n * @param {*} value value to check\n * @returns {boolean} result\n */\nexport const isPrimitive = (value: any): boolean => {\n  return (\n    value === undefined ||\n    value === null ||\n    (typeof value !== 'object' && typeof value !== 'function')\n  )\n}\n\nexport const isFunction = (value: any): value is Function => {\n  return !!(value && value.constructor && value.call && value.apply)\n}\n\nexport const isString = (value: any): value is string => {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport const isInt = (value: any): value is number => {\n  return isNumber(value) && value % 1 === 0\n}\n\nexport const isFloat = (value: any): value is number => {\n  return isNumber(value) && value % 1 !== 0\n}\n\nexport const isNumber = (value: any): value is number => {\n  try {\n    return Number(value) === value\n  } catch {\n    return false\n  }\n}\n\nexport const isDate = (value: any): value is Date => {\n  return Object.prototype.toString.call(value) === '[object Date]'\n}\n\n/**\n * This is really a _best guess_ promise checking. You\n * should probably use Promise.resolve(value) to be 100%\n * sure you're handling it correctly.\n */\nexport const isPromise = (value: any): value is Promise<any> => {\n  if (!value) return false\n  if (!value.then) return false\n  if (!isFunction(value.then)) return false\n  return true\n}\n\nexport const isEmpty = (value: any) => {\n  if (value === true || value === false) return true\n  if (value === null || value === undefined) return true\n  if (isNumber(value)) return value === 0\n  if (isDate(value)) return isNaN(value.getTime())\n  if (isFunction(value)) return false\n  if (isSymbol(value)) return false\n  const length = (value as any).length\n  if (isNumber(length)) return length === 0\n  const size = (value as any).size\n  if (isNumber(size)) return size === 0\n  const keys = Object.keys(value).length\n  return keys === 0\n}\n\nexport const isEqual = <TType>(x: TType, y: TType): boolean => {\n  if (Object.is(x, y)) return true\n  if (x instanceof Date && y instanceof Date) {\n    return x.getTime() === y.getTime()\n  }\n  if (x instanceof RegExp && y instanceof RegExp) {\n    return x.toString() === y.toString()\n  }\n  if (\n    typeof x !== 'object' ||\n    x === null ||\n    typeof y !== 'object' ||\n    y === null\n  ) {\n    return false\n  }\n  const keysX = Reflect.ownKeys(x as unknown as object) as (keyof typeof x)[]\n  const keysY = Reflect.ownKeys(y as unknown as object)\n  if (keysX.length !== keysY.length) return false\n  for (let i = 0; i < keysX.length; i++) {\n    if (!Reflect.has(y as unknown as object, keysX[i])) return false\n    if (!isEqual(x[keysX[i]], y[keysX[i]])) return false\n  }\n  return true\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:11:35"}, {"role": "assistant", "content": "```ts\nimport { assert } from 'chai'\nimport * as _ from '..'\n\nconst NULL = null as unknown as unknown[]\n\ndescribe('array module', () => {\n  describe('group function', () => {\n    test('groups by provided attribute', () => {\n      const list = [\n        { group: 'a', word: 'hello' },\n        { group: 'b', word: 'bye' },\n        { group: 'a', word: 'oh' },\n        { group: 'b', word: 'hey' },\n        { group: 'c', word: 'ok' }\n      ]\n      const groups = _.group(list, x => x.group)\n      assert.equal(groups.a?.length, 2)\n      assert.equal(groups.b?.length, 2)\n      assert.equal(groups.c?.length, 1)\n      assert.equal(groups.c?.[0].word, 'ok')\n    })\n  })\n\n  describe('boil function', () => {\n    test('compares and keeps item based on condition', () => {\n      const list = [\n        { game: 'a', score: 100 },\n        { game: 'b', score: 200 },\n        { game: 'c', score: 300 },\n        { game: 'd', score: 400 },\n        { game: 'e', score: 500 }\n      ]\n      const result = _.boil(list, (a, b) => (a.score > b.score ? a : b))\n      assert.equal(result!.game, 'e')\n      assert.equal(result!.score, 500)\n    })\n    test('does not fail when provided array is empty', () => {\n      const result = _.boil([], () => true)\n      assert.isNull(result)\n    })\n    test('does not fail when provided array is null', () => {\n      const result = _.boil(null as unknown as readonly boolean[], () => true)\n      assert.isNull(result)\n    })\n    test('does not fail when provided array is funky shaped', () => {\n      const result = _.boil({} as any, () => true)\n      assert.isNull(result)\n    })\n  })\n\n  describe('zip function', () => {\n    test('zips an array correctly', () => {\n      const result = _.zip(['a', 'b'], [1, 2], [true, false])\n      assert.deepEqual(result, [\n        ['a', 1, true],\n        ['b', 2, false]\n      ])\n    })\n\n    test('returns an empty array if nothing is passed', () => {\n      // @ts-ignore\n      const result = _.zip()\n      assert.deepEqual(result, [])\n    })\n  })\n\n  describe('zipToObject function', () => {\n    test('zips to an object correctly', () => {\n      const result = _.zipToObject(['a', 'b'], [1, 2])\n      assert.deepEqual(result, { a: 1, b: 2 })\n    })\n\n    test('zips to an object with custom map function', () => {\n      const result = _.zipToObject(['a', 'b'], (k, i) => k + i)\n      assert.deepEqual(result, { a: 'a0', b: 'b1' })\n    })\n\n    test('zips to an object with only one value', () => {\n      const result = _.zipToObject(['a', 'b'], 1)\n      assert.deepEqual(result, { a: 1, b: 1 })\n    })\n\n    test('returns an empty object if bad parameters are passed', () => {\n      // @ts-ignore\n      const result = _.zipToObject()\n      assert.deepEqual(result, {})\n    })\n  })\n\n  describe('sum function', () => {\n    test('adds list of number correctly', () => {\n      const list = [5, 5, 10, 2]\n      const result = _.sum(list)\n      assert.equal(result, 22)\n    })\n    test('adds list of objects correctly using getter fn', () => {\n      const list = [{ value: 5 }, { value: 5 }, { value: 10 }, { value: 2 }]\n      const result = _.sum(list, x => x.value)\n      assert.equal(result, 22)\n    })\n    test('gracefully handles null input list', () => {\n      const result = _.sum(null as unknown as readonly number[])\n      assert.equal(result, 0)\n    })\n  })\n\n  describe('first function', () => {\n    test('returns first item in list', () => {\n      const list = [\n        { game: 'a', score: 100 },\n        { game: 'b', score: 200 }\n      ]\n      const result = _.first(list)\n      assert.equal(result!.game, 'a')\n      assert.equal(result!.score, 100)\n    })\n    test('returns default value without error when list is empty', () => {\n      const list = [] as string[]\n      const result = _.first(list, 'yolo')\n      assert.equal(result, 'yolo')\n    })\n    test('gracefully handles null input list', () => {\n      const result = _.first(NULL)\n      assert.equal(result, null)\n    })\n  })\n\n  describe('last function', () => {\n    test('returns last item in list', () => {\n      const list = [\n        { game: 'a', score: 100 },\n        { game: 'b', score: 200 }\n      ]\n      const result = _.last(list)\n      assert.equal(result!.game, 'b')\n      assert.equal(result!.score, 200)\n    })\n    test('returns default value without error when list is empty', () => {\n      const list = [] as string[]\n      const result = _.last(list, 'yolo')\n      assert.equal(result, 'yolo')\n    })\n    test('gracefully handles null input list', () => {\n      const result = _.last(NULL)\n      assert.equal(result, null)\n    })\n  })\n\n  describe('sort function', () => {\n    test('uses getter', () => {\n      const list = [{ index: 2 }, { index: 0 }, { index: 1 }]\n      const result = _.sort(list, i => i.index)\n      assert.equal(result[0].index, 0)\n      assert.equal(result[1].index, 1)\n      assert.equal(result[2].index, 2)\n    })\n    test('uses descending order', () => {\n      const list = [{ index: 2 }, { index: 0 }, { index: 1 }]\n      const result = _.sort(list, i => i.index, true)\n      assert.equal(result[0].index, 2)\n      assert.equal(result[1].index, 1)\n      assert.equal(result[2].index, 0)\n    })\n    test('gracefully handles null input list', () => {\n      const result = _.sort(null as any as number[], x => x)\n      assert.deepEqual(result, [])\n    })\n  })\n\n  describe('replace function', () => {\n    test('returns empty list for null input list', () => {\n      const result = _.replace(\n        null as unknown as readonly string[],\n        'x',\n        () => false\n      )\n      assert.deepEqual(result, [])\n    })\n    test('returns the list for an undefined new item', () => {\n      const result = _.replace(['a'], undefined, () => true)\n      assert.deepEqual(result, ['a'])\n    })\n    test('returns replaced item when value is null', () => {\n      const result = _.replace(['a'], null, i => i === 'a')\n      assert.deepEqual(result, [null])\n    })\n    test('returns replaced item by index', () => {\n      const result = _.replace(\n        ['a', 'b', 'c', 'd'],\n        'BB',\n        (letter, idx) => idx === 1\n      )\n      assert.equal(result[1], 'BB')\n    })\n    test('returns copy of list with replaced item', () => {\n      const list = [\n        { game: 'a', score: 100 },\n        { game: 'b', score: 200 }\n      ]\n      const result = _.replace(\n        list,\n        { game: 'x', score: 800 },\n        item => item.game === 'a'\n      )\n      assert.equal(result[0].game, 'x')\n      assert.equal(list[1].game, 'b')\n    })\n    test('returns copy of list without changing', () => {\n      const list = [\n        { game: 'a', score: 100 },\n        { game: 'b', score: 200 }\n      ]\n      const result = _.replace(\n        list,\n        { game: 'x', score: 800 },\n        item => item.game === 'XX'\n      )\n      assert.equal(result[0].game, 'a')\n      assert.equal(list[1].game, 'b')\n    })\n  })\n\n  describe('objectify function', () => {\n    const list = [\n      { id: 'a', word: 'hello' },\n      { id: 'b', word: 'bye' },\n      { id: 'c', word: 'oh' },\n      { id: 'd', word: 'hey' },\n      { id: 'e', word: 'ok' }\n    ]\n    test('returns correct map of values', () => {\n      const result = _.objectify(\n        list,\n        x => x.id,\n        x => x\n      )\n      assert.equal(result.a.word, 'hello')\n      assert.equal(result.b.word, 'bye')\n    })\n    test('does not fail on empty input list', () => {\n      const result = _.objectify(\n        [],\n        (x: any) => x.id,\n        x => x\n      )\n      assert.deepEqual(result, {})\n    })\n    test('defaults value to array item', () => {\n      const result = _.objectify(list.slice(0, 1), x => x.id)\n      assert.deepEqual(result, {\n        a: { id: 'a', word: 'hello' }\n      })\n    })\n  })\n\n  describe('select function', () => {\n    test('does not fail on bad input', () => {\n      assert.deepEqual(\n        _.select(\n          null as unknown as any[],\n          x => x,\n          x => x\n        ),\n        []\n      )\n      assert.deepEqual(\n        _.select(\n          undefined as unknown as any[],\n          x => x,\n          x => x\n        ),\n        []\n      )\n    })\n    test('returns mapped and filtered values', () => {\n      const list = [\n        { group: 'a', word: 'hello' },\n        { group: 'b', word: 'bye' },\n        { group: 'a', word: 'oh' },\n        { group: 'b', word: 'hey' },\n        { group: 'c', word: 'ok' }\n      ]\n      const result = _.select(\n        list,\n        x => x.word,\n        x => x.group === 'a'\n      )\n      assert.deepEqual(result, ['hello', 'oh'])\n    })\n    test('does not fail on empty input list', () => {\n      const list: any[] = []\n      const result = _.select(\n        list,\n        (x: any) => x.word,\n        x => x.group === 'a'\n      )\n      assert.deepEqual(result, [])\n    })\n    test('works with index', () => {\n      const letters = ['a', 'b', 'c', 'd']\n      const result = _.select(\n        letters,\n        (l, idx) => `${l}${idx}`,\n        (l, idx) => idx > 1\n      )\n      assert.deepEqual(result, ['c2', 'd3'])\n    })\n  })\n\n  describe('max function', () => {\n    test('returns the max value from list of number', () => {\n      const list = [5, 5, 10, 2]\n      const result = _.max(list)\n      assert.equal(result, 10)\n    })\n    test('returns the max value from list of objects', () => {\n      const list = [\n        { game: 'a', score: 100 },\n        { game: 'b', score: 200 },\n        { game: 'c', score: 300 },\n        { game: 'd', score: 400 },\n        { game: 'e', score: 500 }\n      ]\n      const result = _.max(list, x => x.score)\n      assert.equal(result!.game, 'e')\n      assert.equal(result!.score, 500)\n    })\n  })\n\n  describe('min function', () => {\n    test('returns the min value from list of number', () => {\n      const list = [5, 5, 10, 2]\n      const result = _.min(list)\n      assert.equal(result, 2)\n    })\n    test('returns the min value from list of objects', () => {\n      const list = [\n        { game: 'a', score: 100 },\n        { game: 'b', score: 200 },\n        { game: 'c', score: 300 },\n        { game: 'd', score: 400 },\n        { game: 'e', score: 500 }\n      ]\n      const result = _.min(list, x => x.score)\n      assert.equal(result!.game, 'a')\n      assert.equal(result!.score, 100)\n    })\n  })\n\n  describe('cluster function', () => {\n    test('returns an array of arrays', () => {\n      const list = [1, 1, 1, 1, 1, 1, 1, 1]\n      const result = _.cluster(list)\n      const [a, b, c] = result\n      assert.deepEqual(a, [1, 1])\n      assert.deepEqual(b, [1, 1])\n      assert.deepEqual(c, [1, 1])\n    })\n    test('returns remainder in final cluster', () => {\n      const list = [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2]\n      const result = _.cluster(list, 3)\n      const [a, b, c, d] = result\n      assert.deepEqual(a, [1, 1, 1])\n      assert.deepEqual(b, [1, 1, 1])\n      assert.deepEqual(c, [1, 1, 1])\n      assert.deepEqual(d, [2, 2])\n    })\n  })\n\n  describe('unique function', () => {\n    test('correctly removed duplicate items', () => {\n      const list = [1, 1, 2]\n      const result = _.unique(list)\n      assert.deepEqual(result, [1, 2])\n    })\n    test('uses key fn to correctly remove duplicate items', () => {\n      const list = [\n        { id: 'a', word: 'hello' },\n        { id: 'a', word: 'hello' },\n        { id: 'b', word: 'oh' },\n        { id: 'b', word: 'oh' },\n        { id: 'c', word: 'yolo' }\n      ]\n      const result = _.unique(list, x => x.id)\n      const [a, b, c] = result\n      assert.equal(a.id, 'a')\n      assert.equal(a.word, 'hello')\n      assert.equal(b.id, 'b')\n      assert.equal(b.word, 'oh')\n      assert.equal(c.id, 'c')\n      assert.equal(c.word, 'yolo')\n    })\n  })\n\n  describe('range function', () => {\n    const obj = { name: 'radash' }\n    const toList = <T>(gen: Generator<T>): T[] => {\n      let items: T[] = []\n      for (const item of gen) items.push(item)\n      return items\n    }\n\n    test('yields expected values', () => {\n      assert.deepEqual(toList(_.range(0, 4)), [0, 1, 2, 3, 4])\n      assert.deepEqual(toList(_.range(3)), [0, 1, 2, 3])\n      assert.deepEqual(toList(_.range(0, 3)), [0, 1, 2, 3])\n      assert.deepEqual(toList(_.range(0, 3, 'y')), ['y', 'y', 'y', 'y'])\n      assert.deepEqual(toList(_.range(0, 3, () => 'y')), ['y', 'y', 'y', 'y'])\n      assert.deepEqual(toList(_.range(0, 3, i => i)), [0, 1, 2, 3])\n      assert.deepEqual(toList(_.range(0, 3, i => `y${i}`)), [\n        'y0',\n        'y1',\n        'y2',\n        'y3'\n      ])\n      assert.deepEqual(toList(_.range(0, 3, obj)), [obj, obj, obj, obj])\n      assert.deepEqual(toList(_.range(0, 6, i => i, 2)), [0, 2, 4, 6])\n    })\n  })\n\n  describe('list function', () => {\n    const obj = { name: 'radash' }\n    test('creates correct list', () => {\n      assert.deepEqual(_.list(0, 4), [0, 1, 2, 3, 4])\n      assert.deepEqual(_.list(3), [0, 1, 2, 3])\n      assert.deepEqual(_.list(0, 3), [0, 1, 2, 3])\n      assert.deepEqual(_.list(0, 3, 'y'), ['y', 'y', 'y', 'y'])\n      assert.deepEqual(\n        _.list(0, 3, () => 'y'),\n        ['y', 'y', 'y', 'y']\n      )\n      assert.deepEqual(\n        _.list(0, 3, i => i),\n        [0, 1, 2, 3]\n      )\n      assert.deepEqual(\n        _.list(0, 3, i => `y${i}`),\n        ['y0', 'y1', 'y2', 'y3']\n      )\n      assert.deepEqual(_.list(0, 3, obj), [obj, obj, obj, obj])\n      assert.deepEqual(\n        _.list(0, 6, i => i, 2),\n        [0, 2, 4, 6]\n      )\n    })\n    test('omits end if step does not land on it', () => {\n      const result = _.list(0, 5, i => i, 2)\n      assert.deepEqual(result, [0, 2, 4])\n    })\n    test('returns start only if step larger than end', () => {\n      const result = _.list(0, 5, i => i, 20)\n      assert.deepEqual(result, [0])\n    })\n  })\n\n  describe('flat function', () => {\n    test('returns all items in all arrays', () => {\n      const lists = [['a', 'b'], ['c', 'd'], ['e']]\n      const result = _.flat(lists)\n      assert.deepEqual(result, ['a', 'b', 'c', 'd', 'e'])\n      assert.equal(result[0], 'a')\n      assert.equal(result[4], 'e')\n    })\n  })\n\n  describe('intersects function', () => {\n    test('returns true if list a & b have items in common', () => {\n      const listA = ['a', 'b']\n      const listB = [1, 2, 'b', 'x']\n      const result = _.intersects(listA, listB)\n      assert.isTrue(result)\n    })\n    test('returns false if list a & b have no items in common', () => {\n      const listA = ['a', 'b', 'c']\n      const listB = ['x', 'y']\n      const result = _.intersects(listA, listB)\n      assert.isFalse(result)\n    })\n    test('returns true using custom identity', () => {\n      const listA = [{ value: 23 }, { value: 12 }]\n      const listB = [{ value: 12 }]\n      const result = _.intersects(listA, listB, x => x.value)\n      assert.isTrue(result)\n    })\n    test('returns false without failing if either list is null', () => {\n      assert.isFalse(_.intersects(null as unknown as never, []))\n      assert.isFalse(_.intersects([], null as unknown as never))\n    })\n  })\n\n  describe('fork function', () => {\n    test('returns two empty arrays for null input', () => {\n      const [a, b] = _.fork(NULL, x => !!x)\n      assert.deepEqual(a, [])\n      assert.deepEqual(b, [])\n    })\n    test('returns two empty arrays for one empty array input', () => {\n      const [a, b] = _.fork([], x => !!x)\n      assert.deepEqual(a, [])\n      assert.deepEqual(b, [])\n    })\n    test('returns correctly forked list', () => {\n      const input = [\n        { name: 'ray', group: 'X' },\n        { name: 'sara', group: 'X' },\n        { name: 'bo', group: 'Y' },\n        { name: 'mary', group: 'Y' }\n      ]\n      const [xs, ys] = _.fork(input, x => x.group === 'X')\n      assert.lengthOf(xs, 2)\n      assert.lengthOf(ys, 2)\n      const [r, s] = xs\n      assert.equal(r.name, 'ray')\n      assert.equal(s.name, 'sara')\n      const [b, m] = ys\n      assert.equal(b.name, 'bo')\n      assert.equal(m.name, 'mary')\n    })\n  })\n\n  describe('merge function', () => {\n    test('returns empty array for two null inputs', () => {\n      const result = _.merge(NULL, NULL, x => '')\n      assert.deepEqual(result, [])\n    })\n    test('returns an empty array for two empty array inputs', () => {\n      const result = _.merge([], [], x => '')\n      assert.deepEqual(result, [])\n    })\n    test('returns root for a null other input', () => {\n      const result = _.merge([], NULL, x => '')\n      assert.deepEqual(result, [])\n    })\n    test('returns empty array for a null root input', () => {\n      const result = _.merge(NULL, [], x => '')\n      assert.deepEqual(result, [])\n    })\n    test('returns root for a null matcher input', () => {\n      const result = _.merge(\n        ['a'],\n        [],\n        null as unknown as (x: string) => string\n      )\n      assert.deepEqual(result, ['a'])\n    })\n    test('returns correctly mergeped lists', () => {\n      const inputA = [\n        { name: 'ray', group: 'X' },\n        { name: 'sara', group: 'X' },\n        { name: 'bo', group: 'Y' },\n        { name: 'mary', group: 'Y' }\n      ]\n      const inputB = [\n        { name: 'ray', group: 'XXX' },\n        { name: 'mary', group: 'YYY' }\n      ]\n      const result = _.merge(inputA, inputB, x => x.name)\n      assert.equal(result[0].group, 'XXX')\n      assert.equal(result[1].group, 'X')\n      assert.equal(result[2].group, 'Y')\n      assert.equal(result[3].group, 'YYY')\n    })\n  })\n\n  describe('replaceOrAppend', () => {\n    const letters = ['a', 'b', 'c', 'd', 'e']\n    const lettersXA = ['XA', 'b', 'c', 'd', 'e']\n    const lettersXC = ['a', 'b', 'XC', 'd', 'e']\n    const lettersXE = ['a', 'b', 'c', 'd', 'XE']\n    const lettersXX = ['a', 'b', 'c', 'd', 'e', 'XX']\n    test('returns empty array for two null inputs', () => {\n      const result = _.replaceOrAppend(NULL, null, x => false)\n      assert.deepEqual(result, [])\n    })\n    test('returns array with new item for null list input', () => {\n      const result = _.replaceOrAppend(NULL, 'a', x => false)\n      assert.deepEqual(result, ['a'])\n    })\n    test('returns list for null new item input', () => {\n      const result = _.replaceOrAppend(['a'], null, x => false)\n      assert.deepEqual(result, ['a'])\n    })\n    test('returns list with item replacing match by index', () => {\n      const result = _.replaceOrAppend(\n        ['a', 'b', 'c', 'd'],\n        'BB',\n        (letter, idx) => idx === 1\n      )\n      assert.equal(result[1], 'BB')\n    })\n    test('returns list with item replacing match', () => {\n      const result = _.replaceOrAppend(letters, 'XA', x => x === 'a')\n      assert.deepEqual(result, lettersXA)\n    })\n    test('returns list with item replacing match in middle', () => {\n      const result = _.replaceOrAppend(letters, 'XC', x => x === 'c')\n      assert.deepEqual(result, lettersXC)\n    })\n    test('returns list with item replacing match at end', () => {\n      const result = _.replaceOrAppend(letters, 'XE', x => x === 'e')\n      assert.deepEqual(result, lettersXE)\n    })\n    test('returns list with item appended', () => {\n      const result = _.replaceOrAppend(letters, 'XX', x => x === 'x')\n      assert.deepEqual(result, lettersXX)\n    })\n  })\n\n  describe('sift', () => {\n    const people = [null, 'hello', undefined, false, 23]\n    test('returns empty array for null input array', () => {\n      const result = _.sift(NULL)\n      assert.deepEqual(result, [])\n    })\n    test('returns array with falsy values filtered out', () => {\n      const result = _.sift(people)\n      assert.deepEqual(result, ['hello', 23])\n    })\n  })\n\n  describe('iterate function', () => {\n    test('iterates correct number of times', () => {\n      const result = _.iterate(5, (acc, idx) => acc + idx, 0)\n      assert.equal(result, 15)\n    })\n  })\n\n  describe('diff function', () => {\n    test('handles null root', () => {\n      const result = _.diff(NULL, ['a'])\n      assert.deepEqual(result, ['a'])\n    })\n    test('handles null other', () => {\n      const result = _.diff(['a'], NULL)\n      assert.deepEqual(result, ['a'])\n    })\n    test('handles null inputs', () => {\n      const result = _.diff(NULL, NULL)\n      assert.deepEqual(result, [])\n    })\n    test('handles empty array root', () => {\n      const result = _.diff([], ['a'])\n      assert.deepEqual(result, [])\n    })\n    test('handles empty array other', () => {\n      const result = _.diff(['a'], [])\n      assert.deepEqual(result, ['a'])\n    })\n    test('returns all items from root that dont exist in other', () => {\n      const result = _.diff(['a', 'b', 'c'], ['c', 'd', 'e'])\n      assert.deepEqual(result, ['a', 'b'])\n    })\n    test('uses identity function', () => {\n      const identity = ({ letter }: { letter: string }) => letter\n      const letter = (l: string) => ({ letter: l })\n      const result = _.diff(\n        [letter('a'), letter('b'), letter('c')],\n        [letter('c'), letter('d'), letter('e')],\n        identity\n      )\n      assert.deepEqual(result, [letter('a'), letter('b')])\n    })\n  })\n\n  describe('alphabetical function', () => {\n    test('uses getter', () => {\n      const list = [{ name: 'Leo' }, { name: 'AJ' }, { name: 'Cynthia' }]\n      const result = _.alphabetical(list, i => i.name)\n      assert.equal(result[0].name, 'AJ')\n      assert.equal(result[1].name, 'Cynthia')\n      assert.equal(result[2].name, 'Leo')\n    })\n    test('uses descending order', () => {\n      const list = [{ name: 'Leo' }, { name: 'AJ' }, { name: 'Cynthia' }]\n      const result = _.alphabetical(list, i => i.name, 'desc')\n      assert.equal(result[0].name, 'Leo')\n      assert.equal(result[1].name, 'Cynthia')\n      assert.equal(result[2].name, 'AJ')\n    })\n    test('gracefully handles null input list', () => {\n      const result = _.alphabetical(null as any as string[], x => x)\n      assert.deepEqual(result, [])\n    })\n  })\n\n  describe('counting function', () => {\n    const people = [\n      { name: 'ray', group: 'X' },\n      { name: 'sara', group: 'X' },\n      { name: 'bo', group: 'Y' },\n      { name: 'mary', group: 'Y' }\n    ]\n    test('returns correctly counted items object', () => {\n      const result = _.counting(people, p => p.group)\n      assert.deepEqual(result, {\n        X: 2,\n        Y: 2\n      })\n    })\n    test('does not error on bad input', () => {\n      _.counting(null as unknown as number[], x => x)\n      _.counting(undefined as unknown as number[], x => x)\n    })\n  })\n\n  describe('shift function', () => {\n    const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    test('should shift array right 3 positions', () => {\n      const result = _.shift(arr, 3)\n      assert.deepEqual(result, [7, 8, 9, 1, 2, 3, 4, 5, 6])\n    })\n    test('should shift array left 3 positions', () => {\n      const result = _.shift(arr, -3)\n      assert.deepEqual(result, [4, 5, 6, 7, 8, 9, 1, 2, 3])\n    })\n    test('should shift array right 6 positions', () => {\n      const result = _.shift(arr, 15)\n      assert.deepEqual(result, [4, 5, 6, 7, 8, 9, 1, 2, 3])\n    })\n    test('should shift array left 6 positions', () => {\n      const result = _.shift(arr, -15)\n      assert.deepEqual(result, [7, 8, 9, 1, 2, 3, 4, 5, 6])\n    })\n    test('should keep array as is', () => {\n      const result = _.shift(arr, 0)\n      assert.deepEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n    })\n    test('should keep array as is', () => {\n      const result = _.shift(arr, 9)\n      assert.deepEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n    })\n    test('should return empty array', () => {\n      const results = _.shift([], 0)\n      assert.deepEqual(results, [])\n    })\n    test('should return empty array', () => {\n      const results = _.shift([], 10)\n      assert.deepEqual(results, [])\n    })\n  })\n\n  describe('toggle function', () => {\n    test('should handle null input list', () => {\n      const result = _.toggle(null as unknown as any[], 'a')\n      assert.deepEqual(result, ['a'])\n    })\n    test('should handle null input list and null item', () => {\n      const result = _.toggle(null as unknown as any[], null)\n      assert.deepEqual(result, [])\n    })\n    test('should handle null item', () => {\n      const result = _.toggle(['a'], null)\n      assert.deepEqual(result, ['a'])\n    })\n    test('should add item when it does not exist using default matcher', () => {\n      const result = _.toggle(['a'], 'b')\n      assert.deepEqual(result, ['a', 'b'])\n    })\n    test('should remove item when it does exist using default matcher', () => {\n      const result = _.toggle(['a', 'b'], 'b')\n      assert.deepEqual(result, ['a'])\n    })\n    test('should remove item when it does exist using custom matcher', () => {\n      const result = _.toggle(\n        [{ value: 'a' }, { value: 'b' }],\n        { value: 'b' },\n        v => v.value\n      )\n      assert.deepEqual(result, [{ value: 'a' }])\n    })\n    test('should add item when it does not exist using custom matcher', () => {\n      const result = _.toggle([{ value: 'a' }], { value: 'b' }, v => v.value)\n      assert.deepEqual(result, [{ value: 'a' }, { value: 'b' }])\n    })\n    test('should prepend item when strategy is set', () => {\n      const result = _.toggle(['a'], 'b', null, { strategy: 'prepend' })\n      assert.deepEqual(result, ['b', 'a'])\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: radash\nTest File Path: radash\\async.test.ts\\async.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { fork, list, range, sort } from './array'\nimport { isArray, isPromise } from './typed'\n\n/**\n * An async reduce function. Works like the\n * built-in Array.reduce function but handles\n * an async reducer function\n */\nexport const reduce = async <T, K>(\n  array: readonly T[],\n  asyncReducer: (acc: K, item: T, index: number) => Promise<K>,\n  initValue?: K\n): Promise<K> => {\n  const initProvided = initValue !== undefined\n  if (!initProvided && array?.length < 1) {\n    throw new Error('Cannot reduce empty array with no init value')\n  }\n  const iter = initProvided ? array : array.slice(1)\n  let value: any = initProvided ? initValue : array[0]\n  for (const [i, item] of iter.entries()) {\n    value = await asyncReducer(value, item, i)\n  }\n  return value\n}\n\n/**\n * An async map function. Works like the\n * built-in Array.map function but handles\n * an async mapper function\n */\nexport const map = async <T, K>(\n  array: readonly T[],\n  asyncMapFunc: (item: T, index: number) => Promise<K>\n): Promise<K[]> => {\n  if (!array) return []\n  let result = []\n  let index = 0\n  for (const value of array) {\n    const newValue = await asyncMapFunc(value, index++)\n    result.push(newValue)\n  }\n  return result\n}\n\n/**\n * Useful when for script like things where cleanup\n * should be done on fail or sucess no matter.\n *\n * You can call defer many times to register many\n * defered functions that will all be called when\n * the function exits in any state.\n */\nexport const defer = async <TResponse>(\n  func: (\n    register: (\n      fn: (error?: any) => any,\n      options?: { rethrow?: boolean }\n    ) => void\n  ) => Promise<TResponse>\n): Promise<TResponse> => {\n  const callbacks: {\n    fn: (error?: any) => any\n    rethrow: boolean\n  }[] = []\n  const register = (\n    fn: (error?: any) => any,\n    options?: { rethrow?: boolean }\n  ) =>\n    callbacks.push({\n      fn,\n      rethrow: options?.rethrow ?? false\n    })\n  const [err, response] = await tryit(func)(register)\n  for (const { fn, rethrow } of callbacks) {\n    const [rethrown] = await tryit(fn)(err)\n    if (rethrown && rethrow) throw rethrown\n  }\n  if (err) throw err\n  return response\n}\n\ntype WorkItemResult<K> = {\n  index: number\n  result: K\n  error: any\n}\n\n/**\n * Support for the built-in AggregateError\n * is still new. Node < 15 doesn't have it\n * so patching here.\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError#browser_compatibility\n */\nexport class AggregateError extends Error {\n  errors: Error[]\n  constructor(errors: Error[] = []) {\n    super()\n    const name = errors.find(e => e.name)?.name ?? ''\n    this.name = `AggregateError(${name}...)`\n    this.message = `AggregateError with ${errors.length} errors`\n    this.stack = errors.find(e => e.stack)?.stack ?? this.stack\n    this.errors = errors\n  }\n}\n\n/**\n * Executes many async functions in parallel. Returns the\n * results from all functions as an array. After all functions\n * have resolved, if any errors were thrown, they are rethrown\n * in an instance of AggregateError\n */\nexport const parallel = async <T, K>(\n  limit: number,\n  array: readonly T[],\n  func: (item: T) => Promise<K>\n): Promise<K[]> => {\n  const work = array.map((item, index) => ({\n    index,\n    item\n  }))\n  // Process array items\n  const processor = async (res: (value: WorkItemResult<K>[]) => void) => {\n    const results: WorkItemResult<K>[] = []\n    while (true) {\n      const next = work.pop()\n      if (!next) return res(results)\n      const [error, result] = await tryit(func)(next.item)\n      results.push({\n        error,\n        result: result as K,\n        index: next.index\n      })\n    }\n  }\n  // Create queues\n  const queues = list(1, limit).map(() => new Promise(processor))\n  // Wait for all queues to complete\n  const itemResults = (await Promise.all(queues)) as WorkItemResult<K>[][]\n  const [errors, results] = fork(\n    sort(itemResults.flat(), r => r.index),\n    x => !!x.error\n  )\n  if (errors.length > 0) {\n    throw new AggregateError(errors.map(error => error.error))\n  }\n  return results.map(r => r.result)\n}\n\ntype PromiseValues<T extends Promise<any>[]> = {\n  [K in keyof T]: T[K] extends Promise<infer U> ? U : never\n}\n\n/**\n * Functionally similar to Promise.all or Promise.allSettled. If any\n * errors are thrown, all errors are gathered and thrown in an\n * AggregateError.\n *\n * @example\n * const [user] = await all([\n *   api.users.create(...),\n *   s3.buckets.create(...),\n *   slack.customerSuccessChannel.sendMessage(...)\n * ])\n */\nexport async function all<T extends [Promise<any>, ...Promise<any>[]]>(\n  promises: T\n): Promise<PromiseValues<T>>\nexport async function all<T extends Promise<any>[]>(\n  promises: T\n): Promise<PromiseValues<T>>\n/**\n * Functionally similar to Promise.all or Promise.allSettled. If any\n * errors are thrown, all errors are gathered and thrown in an\n * AggregateError.\n *\n * @example\n * const { user } = await all({\n *   user: api.users.create(...),\n *   bucket: s3.buckets.create(...),\n *   message: slack.customerSuccessChannel.sendMessage(...)\n * })\n */\nexport async function all<T extends Record<string, Promise<any>>>(\n  promises: T\n): Promise<{ [K in keyof T]: Awaited<T[K]> }>\nexport async function all<\n  T extends Record<string, Promise<any>> | Promise<any>[]\n>(promises: T) {\n  const entries = isArray(promises)\n    ? promises.map(p => [null, p] as [null, Promise<any>])\n    : Object.entries(promises)\n\n  const results = await Promise.all(\n    entries.map(([key, value]) =>\n      value\n        .then(result => ({ result, exc: null, key }))\n        .catch(exc => ({ result: null, exc, key }))\n    )\n  )\n\n  const exceptions = results.filter(r => r.exc)\n  if (exceptions.length > 0) {\n    throw new AggregateError(exceptions.map(e => e.exc))\n  }\n\n  if (isArray(promises)) {\n    return results.map(r => r.result) as T extends Promise<any>[]\n      ? PromiseValues<T>\n      : unknown\n  }\n\n  return results.reduce(\n    (acc, item) => ({\n      ...acc,\n      [item.key!]: item.result\n    }),\n    {} as { [K in keyof T]: Awaited<T[K]> }\n  )\n}\n\n/**\n * Retries the given function the specified number\n * of times.\n */\nexport const retry = async <TResponse>(\n  options: {\n    times?: number\n    delay?: number | null\n    backoff?: (count: number) => number\n  },\n  func: (exit: (err: any) => void) => Promise<TResponse>\n): Promise<TResponse> => {\n  const times = options?.times ?? 3\n  const delay = options?.delay\n  const backoff = options?.backoff ?? null\n  for (const i of range(1, times)) {\n    const [err, result] = (await tryit(func)((err: any) => {\n      throw { _exited: err }\n    })) as [any, TResponse]\n    if (!err) return result\n    if (err._exited) throw err._exited\n    if (i === times) throw err\n    if (delay) await sleep(delay)\n    if (backoff) await sleep(backoff(i))\n  }\n  // Logically, we should never reach this\n  // code path. It makes the function meet\n  // strict mode requirements.\n  /* istanbul ignore next */\n  return undefined as unknown as TResponse\n}\n\n/**\n * Async wait\n */\nexport const sleep = (milliseconds: number) => {\n  return new Promise(res => setTimeout(res, milliseconds))\n}\n\n/**\n * A helper to try an async function without forking\n * the control flow. Returns an error first callback _like_\n * array response as [Error, result]\n */\nexport const tryit = <Args extends any[], Return>(\n  func: (...args: Args) => Return\n) => {\n  return (\n    ...args: Args\n  ): Return extends Promise<any>\n    ? Promise<[Error, undefined] | [undefined, Awaited<Return>]>\n    : [Error, undefined] | [undefined, Return] => {\n    try {\n      const result = func(...args)\n      if (isPromise(result)) {\n        return result\n          .then(value => [undefined, value])\n          .catch(err => [err, undefined]) as Return extends Promise<any>\n          ? Promise<[Error, undefined] | [undefined, Awaited<Return>]>\n          : [Error, undefined] | [undefined, Return]\n      }\n      return [undefined, result] as Return extends Promise<any>\n        ? Promise<[Error, undefined] | [undefined, Awaited<Return>]>\n        : [Error, undefined] | [undefined, Return]\n    } catch (err) {\n      return [err as any, undefined] as Return extends Promise<any>\n        ? Promise<[Error, undefined] | [undefined, Awaited<Return>]>\n        : [Error, undefined] | [undefined, Return]\n    }\n  }\n}\n\n/**\n * A helper to try an async function that returns undefined\n * if it fails.\n *\n * e.g. const result = await guard(fetchUsers)() ?? [];\n */\nexport const guard = <TFunction extends () => any>(\n  func: TFunction,\n  shouldGuard?: (err: any) => boolean\n): ReturnType<TFunction> extends Promise<any>\n  ? Promise<Awaited<ReturnType<TFunction>> | undefined>\n  : ReturnType<TFunction> | undefined => {\n  const _guard = (err: any) => {\n    if (shouldGuard && !shouldGuard(err)) throw err\n    return undefined as any\n  }\n  const isPromise = (result: any): result is Promise<any> =>\n    result instanceof Promise\n  try {\n    const result = func()\n    return isPromise(result) ? result.catch(_guard) : result\n  } catch (err) {\n    return _guard(err)\n  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: array.ts\nimport { isArray, isFunction } from './typed'\n\n/**\n * Sorts an array of items into groups. The return value is a map where the keys are\n * the group ids the given getGroupId function produced and the value is an array of\n * each item in that group.\n */\nexport const group = <T, Key extends string | number | symbol>(\n  array: readonly T[],\n  getGroupId: (item: T) => Key\n): Partial<Record<Key, T[]>> => {\n  return array.reduce((acc, item) => {\n    const groupId = getGroupId(item)\n    if (!acc[groupId]) acc[groupId] = []\n    acc[groupId].push(item)\n    return acc\n  }, {} as Record<Key, T[]>)\n}\n\n/**\n * Creates an array of grouped elements, the first of which contains the\n * first elements of the given arrays, the second of which contains the\n * second elements of the given arrays, and so on.\n *\n * Ex. const zipped = zip(['a', 'b'], [1, 2], [true, false]) // [['a', 1, true], ['b', 2, false]]\n */\nexport function zip<T1, T2, T3, T4, T5>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[],\n  array5: T5[]\n): [T1, T2, T3, T4, T5][]\nexport function zip<T1, T2, T3, T4>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[]\n): [T1, T2, T3, T4][]\nexport function zip<T1, T2, T3>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[]\n): [T1, T2, T3][]\nexport function zip<T1, T2>(array1: T1[], array2: T2[]): [T1, T2][]\nexport function zip<T>(...arrays: T[][]): T[][] {\n  if (!arrays || !arrays.length) return []\n  return new Array(Math.max(...arrays.map(({ length }) => length)))\n    .fill([])\n    .map((_, idx) => arrays.map(array => array[idx]))\n}\n\n/**\n * Creates an object mapping the specified keys to their corresponding values\n *\n * Ex. const zipped = zipToObject(['a', 'b'], [1, 2]) // { a: 1, b: 2 }\n * Ex. const zipped = zipToObject(['a', 'b'], (k, i) => k + i) // { a: 'a0', b: 'b1' }\n * Ex. const zipped = zipToObject(['a', 'b'], 1) // { a: 1, b: 1 }\n */\nexport function zipToObject<K extends string | number | symbol, V>(\n  keys: K[],\n  values: V | ((key: K, idx: number) => V) | V[]\n): Record<K, V> {\n  if (!keys || !keys.length) {\n    return {} as Record<K, V>\n  }\n\n  const getValue = isFunction(values)\n    ? values\n    : isArray(values)\n    ? (_k: K, i: number) => values[i]\n    : (_k: K, _i: number) => values\n\n  return keys.reduce((acc, key, idx) => {\n    acc[key] = getValue(key, idx)\n    return acc\n  }, {} as Record<K, V>)\n}\n\n/**\n * Go through a list of items, starting with the first item,\n * and comparing with the second. Keep the one you want then\n * compare that to the next item in the list with the same\n *\n * Ex. const greatest = () => boil(numbers, (a, b) => a > b)\n */\nexport const boil = <T>(\n  array: readonly T[],\n  compareFunc: (a: T, b: T) => T\n) => {\n  if (!array || (array.length ?? 0) === 0) return null\n  return array.reduce(compareFunc)\n}\n\n/**\n * Sum all numbers in an array. Optionally provide a function\n * to convert objects in the array to number values.\n */\nexport function sum<T extends number>(array: readonly T[]): number\nexport function sum<T extends object>(\n  array: readonly T[],\n  fn: (item: T) => number\n): number\nexport function sum<T extends object | number>(\n  array: readonly any[],\n  fn?: (item: T) => number\n): number {\n  return (array || []).reduce((acc, item) => acc + (fn ? fn(item) : item), 0)\n}\n\n/**\n * Get the first item in an array or a default value\n */\nexport const first = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[0] : defaultValue\n}\n\n/**\n * Get the last item in an array or a default value\n */\nexport const last = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[array.length - 1] : defaultValue\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value\n */\nexport const sort = <T>(\n  array: readonly T[],\n  getter: (item: T) => number,\n  desc = false\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => getter(a) - getter(b)\n  const dsc = (a: T, b: T) => getter(b) - getter(a)\n  return array.slice().sort(desc === true ? dsc : asc)\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value. Allows for a string\n * sorting value.\n */\nexport const alphabetical = <T>(\n  array: readonly T[],\n  getter: (item: T) => string,\n  dir: 'asc' | 'desc' = 'asc'\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => `${getter(a)}`.localeCompare(getter(b))\n  const dsc = (a: T, b: T) => `${getter(b)}`.localeCompare(getter(a))\n  return array.slice().sort(dir === 'desc' ? dsc : asc)\n}\n\nexport const counting = <T, TId extends string | number | symbol>(\n  list: readonly T[],\n  identity: (item: T) => TId\n): Record<TId, number> => {\n  if (!list) return {} as Record<TId, number>\n  return list.reduce((acc, item) => {\n    const id = identity(item)\n    acc[id] = (acc[id] ?? 0) + 1\n    return acc\n  }, {} as Record<TId, number>)\n}\n\n/**\n * Replace an element in an array with a new\n * item without modifying the array and return\n * the new value\n */\nexport const replace = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (item: T, idx: number) => boolean\n): T[] => {\n  if (!list) return []\n  if (newItem === undefined) return [...list]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list]\n}\n\n/**\n * Convert an array to a dictionary by mapping each item\n * into a dictionary key & value\n */\nexport const objectify = <T, Key extends string | number | symbol, Value = T>(\n  array: readonly T[],\n  getKey: (item: T) => Key,\n  getValue: (item: T) => Value = item => item as unknown as Value\n): Record<Key, Value> => {\n  return array.reduce((acc, item) => {\n    acc[getKey(item)] = getValue(item)\n    return acc\n  }, {} as Record<Key, Value>)\n}\n\n/**\n * Select performs a filter and a mapper inside of a reduce,\n * only iterating the list one time.\n *\n * @example\n * select([1, 2, 3, 4], x => x*x, x > 2) == [9, 16]\n */\nexport const select = <T, K>(\n  array: readonly T[],\n  mapper: (item: T, index: number) => K,\n  condition: (item: T, index: number) => boolean\n) => {\n  if (!array) return []\n  return array.reduce((acc, item, index) => {\n    if (!condition(item, index)) return acc\n    acc.push(mapper(item, index))\n    return acc\n  }, [] as K[])\n}\n\n/**\n * Max gets the greatest value from a list\n *\n * @example\n * max([ 2, 3, 5]) == 5\n * max([{ num: 1 }, { num: 2 }], x => x.num) == { num: 2 }\n */\nexport function max(array: readonly [number, ...number[]]): number\nexport function max(array: readonly number[]): number | null\nexport function max<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function max<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) > get(b) ? a : b))\n}\n\n/**\n * Min gets the smallest value from a list\n *\n * @example\n * min([1, 2, 3, 4]) == 1\n * min([{ num: 1 }, { num: 2 }], x => x.num) == { num: 1 }\n */\nexport function min(array: readonly [number, ...number[]]): number\nexport function min(array: readonly number[]): number | null\nexport function min<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function min<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) < get(b) ? a : b))\n}\n\n/**\n * Splits a single list into many lists of the desired size. If\n * given a list of 10 items and a size of 2, it will return 5\n * lists with 2 items each\n */\nexport const cluster = <T>(list: readonly T[], size: number = 2): T[][] => {\n  const clusterCount = Math.ceil(list.length / size)\n  return new Array(clusterCount).fill(null).map((_c: null, i: number) => {\n    return list.slice(i * size, i * size + size)\n  })\n}\n\n/**\n * Given a list of items returns a new list with only\n * unique items. Accepts an optional identity function\n * to convert each item in the list to a comparable identity\n * value\n */\nexport const unique = <T, K extends string | number | symbol>(\n  array: readonly T[],\n  toKey?: (item: T) => K\n): T[] => {\n  const valueMap = array.reduce((acc, item) => {\n    const key = toKey ? toKey(item) : (item as any as string | number | symbol)\n    if (acc[key]) return acc\n    acc[key] = item\n    return acc\n  }, {} as Record<string | number | symbol, T>)\n  return Object.values(valueMap)\n}\n\n/**\n * Creates a generator that will produce an iteration through\n * the range of number as requested.\n *\n * @example\n * range(3)                  // yields 0, 1, 2, 3\n * range(0, 3)               // yields 0, 1, 2, 3\n * range(0, 3, 'y')          // yields y, y, y, y\n * range(0, 3, () => 'y')    // yields y, y, y, y\n * range(0, 3, i => i)       // yields 0, 1, 2, 3\n * range(0, 3, i => `y${i}`) // yields y0, y1, y2, y3\n * range(0, 3, obj)          // yields obj, obj, obj, obj\n * range(0, 6, i => i, 2)    // yields 0, 2, 4, 6\n */\nexport function* range<T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper: T | ((i: number) => T) = i => i as T,\n  step: number = 1\n): Generator<T> {\n  const mapper = isFunction(valueOrMapper) ? valueOrMapper : () => valueOrMapper\n  const start = end ? startOrLength : 0\n  const final = end ?? startOrLength\n  for (let i = start; i <= final; i += step) {\n    yield mapper(i)\n    if (i + step > final) break\n  }\n}\n\n/**\n * Creates a list of given start, end, value, and\n * step parameters.\n *\n * @example\n * list(3)                  // 0, 1, 2, 3\n * list(0, 3)               // 0, 1, 2, 3\n * list(0, 3, 'y')          // y, y, y, y\n * list(0, 3, () => 'y')    // y, y, y, y\n * list(0, 3, i => i)       // 0, 1, 2, 3\n * list(0, 3, i => `y${i}`) // y0, y1, y2, y3\n * list(0, 3, obj)          // obj, obj, obj, obj\n * list(0, 6, i => i, 2)    // 0, 2, 4, 6\n */\nexport const list = <T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper?: T | ((i: number) => T),\n  step?: number\n): T[] => {\n  return Array.from(range(startOrLength, end, valueOrMapper, step))\n}\n\n/**\n * Given an array of arrays, returns a single\n * dimentional array with all items in it.\n */\nexport const flat = <T>(lists: readonly T[][]): T[] => {\n  return lists.reduce((acc, list) => {\n    acc.push(...list)\n    return acc\n  }, [])\n}\n\n/**\n * Given two arrays, returns true if any\n * elements intersect\n */\nexport const intersects = <T, K extends string | number | symbol>(\n  listA: readonly T[],\n  listB: readonly T[],\n  identity?: (t: T) => K\n): boolean => {\n  if (!listA || !listB) return false\n  const ident = identity ?? ((x: T) => x as unknown as K)\n  const dictB = listB.reduce((acc, item) => {\n    acc[ident(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return listA.some(value => dictB[ident(value)])\n}\n\n/**\n * Split an array into two array based on\n * a true/false condition function\n */\nexport const fork = <T>(\n  list: readonly T[],\n  condition: (item: T) => boolean\n): [T[], T[]] => {\n  if (!list) return [[], []]\n  return list.reduce(\n    (acc, item) => {\n      const [a, b] = acc\n      if (condition(item)) {\n        return [[...a, item], b]\n      } else {\n        return [a, [...b, item]]\n      }\n    },\n    [[], []] as [T[], T[]]\n  )\n}\n\n/**\n * Given two lists of the same type, iterate the first list\n * and replace items matched by the matcher func in the\n * first place.\n */\nexport const merge = <T>(\n  root: readonly T[],\n  others: readonly T[],\n  matcher: (item: T) => any\n) => {\n  if (!others && !root) return []\n  if (!others) return root\n  if (!root) return []\n  if (!matcher) return root\n  return root.reduce((acc, r) => {\n    const matched = others.find(o => matcher(r) === matcher(o))\n    if (matched) acc.push(matched)\n    else acc.push(r)\n    return acc\n  }, [] as T[])\n}\n\n/**\n * Replace an item in an array by a match function condition. If\n * no items match the function condition, appends the new item to\n * the end of the list.\n */\nexport const replaceOrAppend = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (a: T, idx: number) => boolean\n) => {\n  if (!list && !newItem) return []\n  if (!newItem) return [...list]\n  if (!list) return [newItem]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list, newItem]\n}\n\n/**\n * If the item matching the condition already exists\n * in the list it will be removed. If it does not it\n * will be added.\n */\nexport const toggle = <T>(\n  list: readonly T[],\n  item: T,\n  /**\n   * Converts an item of type T item into a value that\n   * can be checked for equality\n   */\n  toKey?: null | ((item: T, idx: number) => number | string | symbol),\n  options?: {\n    strategy?: 'prepend' | 'append'\n  }\n) => {\n  if (!list && !item) return []\n  if (!list) return [item]\n  if (!item) return [...list]\n  const matcher = toKey\n    ? (x: T, idx: number) => toKey(x, idx) === toKey(item, idx)\n    : (x: T) => x === item\n  const existing = list.find(matcher)\n  if (existing) return list.filter((x, idx) => !matcher(x, idx))\n  const strategy = options?.strategy ?? 'append'\n  if (strategy === 'append') return [...list, item]\n  return [item, ...list]\n}\n\ntype Falsy = null | undefined | false | '' | 0 | 0n\n\n/**\n * Given a list returns a new list with\n * only truthy values\n */\nexport const sift = <T>(list: readonly (T | Falsy)[]): T[] => {\n  return (list?.filter(x => !!x) as T[]) ?? []\n}\n\n/**\n * Like a reduce but does not require an array.\n * Only need a number and will iterate the function\n * as many times as specified.\n *\n * NOTE: This is NOT zero indexed. If you pass count=5\n * you will get 1, 2, 3, 4, 5 iteration in the callback\n * function\n */\nexport const iterate = <T>(\n  count: number,\n  func: (currentValue: T, iteration: number) => T,\n  initValue: T\n) => {\n  let value = initValue\n  for (let i = 1; i <= count; i++) {\n    value = func(value, i)\n  }\n  return value\n}\n\n/**\n * Returns all items from the first list that\n * do not exist in the second list.\n */\nexport const diff = <T>(\n  root: readonly T[],\n  other: readonly T[],\n  identity: (item: T) => string | number | symbol = (t: T) =>\n    t as unknown as string | number | symbol\n): T[] => {\n  if (!root?.length && !other?.length) return []\n  if (root?.length === undefined) return [...other]\n  if (!other?.length) return [...root]\n  const bKeys = other.reduce((acc, item) => {\n    acc[identity(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return root.filter(a => !bKeys[identity(a)])\n}\n\n/**\n * Shift array items by n steps\n * If n > 0 items will shift n steps to the right\n * If n < 0 items will shift n steps to the left\n */\nexport function shift<T>(arr: Array<T>, n: number) {\n  if (arr.length === 0) return arr\n\n  const shiftNumber = n % arr.length\n\n  if (shiftNumber === 0) return arr\n\n  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)]\n}\n\n\n### Dependency File: typed.ts\nexport const isSymbol = (value: any): value is symbol => {\n  return !!value && value.constructor === Symbol\n}\n\nexport const isArray = Array.isArray\n\nexport const isObject = (value: any): value is object => {\n  return !!value && value.constructor === Object\n}\n\n/**\n * Checks if the given value is primitive.\n *\n * Primitive Types: number , string , boolean , symbol, bigint, undefined, null\n *\n * @param {*} value value to check\n * @returns {boolean} result\n */\nexport const isPrimitive = (value: any): boolean => {\n  return (\n    value === undefined ||\n    value === null ||\n    (typeof value !== 'object' && typeof value !== 'function')\n  )\n}\n\nexport const isFunction = (value: any): value is Function => {\n  return !!(value && value.constructor && value.call && value.apply)\n}\n\nexport const isString = (value: any): value is string => {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport const isInt = (value: any): value is number => {\n  return isNumber(value) && value % 1 === 0\n}\n\nexport const isFloat = (value: any): value is number => {\n  return isNumber(value) && value % 1 !== 0\n}\n\nexport const isNumber = (value: any): value is number => {\n  try {\n    return Number(value) === value\n  } catch {\n    return false\n  }\n}\n\nexport const isDate = (value: any): value is Date => {\n  return Object.prototype.toString.call(value) === '[object Date]'\n}\n\n/**\n * This is really a _best guess_ promise checking. You\n * should probably use Promise.resolve(value) to be 100%\n * sure you're handling it correctly.\n */\nexport const isPromise = (value: any): value is Promise<any> => {\n  if (!value) return false\n  if (!value.then) return false\n  if (!isFunction(value.then)) return false\n  return true\n}\n\nexport const isEmpty = (value: any) => {\n  if (value === true || value === false) return true\n  if (value === null || value === undefined) return true\n  if (isNumber(value)) return value === 0\n  if (isDate(value)) return isNaN(value.getTime())\n  if (isFunction(value)) return false\n  if (isSymbol(value)) return false\n  const length = (value as any).length\n  if (isNumber(length)) return length === 0\n  const size = (value as any).size\n  if (isNumber(size)) return size === 0\n  const keys = Object.keys(value).length\n  return keys === 0\n}\n\nexport const isEqual = <TType>(x: TType, y: TType): boolean => {\n  if (Object.is(x, y)) return true\n  if (x instanceof Date && y instanceof Date) {\n    return x.getTime() === y.getTime()\n  }\n  if (x instanceof RegExp && y instanceof RegExp) {\n    return x.toString() === y.toString()\n  }\n  if (\n    typeof x !== 'object' ||\n    x === null ||\n    typeof y !== 'object' ||\n    y === null\n  ) {\n    return false\n  }\n  const keysX = Reflect.ownKeys(x as unknown as object) as (keyof typeof x)[]\n  const keysY = Reflect.ownKeys(y as unknown as object)\n  if (keysX.length !== keysY.length) return false\n  for (let i = 0; i < keysX.length; i++) {\n    if (!Reflect.has(y as unknown as object, keysX[i])) return false\n    if (!isEqual(x[keysX[i]], y[keysX[i]])) return false\n  }\n  return true\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:11:35"}, {"role": "assistant", "content": "```ts\nimport { assert } from 'chai'\nimport * as _ from '..'\nimport { AggregateError } from '../async'\n\ndescribe('async module', () => {\n  beforeEach(() => jest.useFakeTimers({ advanceTimers: true }))\n\n  describe('asyncReduce function', () => {\n    test('returns result of reducer', async () => {\n      const numbers = [\n        0,\n        1,\n        2,\n        3,\n        4 // => 10\n      ]\n      const asyncSum = async (a: number, b: number): Promise<number> => {\n        return new Promise(res => res(a + b))\n      }\n      const result = await _.reduce<number, number>(numbers, asyncSum, 0)\n      assert.equal(result, 10)\n    })\n    test('passes correct indexes', async () => {\n      const array = ['a', 'b', 'c', 'd', 'e']\n      const asyncSumIndex = async (\n        a: number[],\n        b: string,\n        i: number\n      ): Promise<number[]> => {\n        return new Promise(res => {\n          a.push(i)\n          res(a)\n        })\n      }\n      const result = await _.reduce<string, number[]>(array, asyncSumIndex, [])\n      assert.deepEqual(result, [0, 1, 2, 3, 4])\n    })\n  })\n\n  describe('asyncMap function', () => {\n    test('returns result of mapper', async () => {\n      const numbers = [1, 2, 3, 4]\n      const asyncSquare = async (a: number): Promise<number> => {\n        return new Promise(res => res(a * a))\n      }\n      const result = await _.map<number, number>(numbers, asyncSquare)\n      assert.deepEqual(result, [1, 4, 9, 16])\n    })\n\n    test('handles null input', async () => {\n      const result = await _.map(null as unknown as unknown[], async () => '')\n      assert.deepEqual(result, [])\n    })\n\n    test('passes correct indexes', async () => {\n      const array = ['a', 'b', 'c', 'd']\n      const mapper = async (l: string, index: number) => `${l}${index}`\n      const result = await _.map(array, mapper)\n      assert.deepEqual(result, ['a0', 'b1', 'c2', 'd3'])\n    })\n  })\n\n  describe('reduce/asyncReduceV2 function', () => {\n    const numbers = [0, 1, 2, 3, 4]\n    const reducer = async (a: number, b: number): Promise<number> => {\n      return new Promise(res => res(a + b))\n    }\n\n    test('calls asyncReduce', async () => {\n      const result = await _.reduce<number, number>(numbers, reducer, 0)\n      assert.equal(result, 10)\n    })\n    test('uses first item in array when no init provided', async () => {\n      const result = await _.reduce(numbers, reducer)\n      assert.equal(result, 10)\n    })\n    test('throws on no init value and an empty array', async () => {\n      try {\n        await _.reduce([], reducer)\n      } catch (err) {\n        assert.isNotNull(err)\n        return\n      }\n      assert.fail('Expected error to be thrown')\n    })\n    test('throws on no init value and a null array input', async () => {\n      try {\n        await _.reduce(null as unknown as number[], reducer)\n      } catch (err) {\n        assert.isNotNull(err)\n        return\n      }\n      assert.fail('Expected error to be thrown')\n    })\n  })\n\n  describe('defer function', () => {\n    test('calls registered defer function', async () => {\n      let val = 0\n      await _.defer(async defer => {\n        defer(() => {\n          val = 1\n        })\n      })\n      assert.equal(val, 1)\n    })\n    test('returns the resulting value of the given function', async () => {\n      let val = 0\n      const result = await _.defer(async defer => {\n        defer(() => {\n          val = 1\n        })\n        return 'x'\n      })\n      assert.equal(val, 1)\n      assert.equal(result, 'x')\n    })\n    test('calls all registered defer functions', async () => {\n      let one = 0\n      let two = 0\n      let three = 0\n      const result = await _.defer(async defer => {\n        defer(async () => {\n          one = 1\n        })\n        defer(async () => {\n          two = 2\n        })\n        defer(async () => {\n          three = 3\n        })\n        return 'x'\n      })\n      assert.equal(one, 1)\n      assert.equal(two, 2)\n      assert.equal(three, 3)\n      assert.equal(result, 'x')\n    })\n    test('calls all registered defer functions when error is thrown', async () => {\n      let one = 0\n      let two = 0\n      let three = 0\n      try {\n        await _.defer(async defer => {\n          defer(async () => {\n            one = 1\n          })\n          defer(async () => {\n            two = 2\n          })\n          defer(async () => {\n            three = 3\n          })\n          if (!!true) throw new Error('soooo broken')\n          return 'x'\n        })\n      } catch {}\n      assert.equal(one, 1)\n      assert.equal(two, 2)\n      assert.equal(three, 3)\n    })\n    test('throws the error', async () => {\n      let error: Error | null = null\n      try {\n        await _.defer(async () => {\n          throw new Error('soooo broken')\n        })\n      } catch (err: any) {\n        error = err\n      }\n      assert.isNotNull(error)\n      assert.equal(error?.message, 'soooo broken')\n    })\n    test('rethrows the rethrown error when rethrow is true', async () => {\n      let error: Error | null = null\n      try {\n        await _.defer(async register => {\n          register(\n            async () => {\n              throw new Error('soooo broken')\n            },\n            { rethrow: true }\n          )\n        })\n      } catch (err: any) {\n        error = err\n      }\n      assert.isNotNull(error)\n      assert.equal(error?.message, 'soooo broken')\n    })\n    test('does not rethrow the rethrown error when rethrow is false', async () => {\n      let error: Error | null = null\n      try {\n        await _.defer(async register => {\n          register(\n            async () => {\n              throw new Error('soooo broken')\n            },\n            { rethrow: false }\n          )\n        })\n      } catch (err: any) {\n        error = err\n      }\n      assert.isNull(error)\n    })\n    test('does not rethrow the rethrown error by default', async () => {\n      let error: Error | null = null\n      try {\n        await _.defer(async register => {\n          register(async () => {\n            throw new Error('soooo broken')\n          })\n        })\n      } catch (err: any) {\n        error = err\n      }\n      assert.isNull(error)\n    })\n    test('returns awaited async results', async () => {\n      const result = await _.defer(() => {\n        return new Promise<string>(res => res('x'))\n      })\n      assert.equal(result, 'x')\n    })\n  })\n\n  describe('_.try function', () => {\n    test('returns error when error is thrown', async () => {\n      const fn = _.try(async () => {\n        throw new Error('not good enough')\n      })\n      const [err, result] = await fn()\n      assert.isUndefined(result)\n      assert.isNotNull(err)\n      assert.equal(err!.message, 'not good enough')\n    })\n    test('returns result when no error is thrown', async () => {\n      const [err, result] = await _.try(async () => {\n        return 'hello'\n      })()\n      assert.isUndefined(err)\n      assert.isNotNull(result)\n      assert.equal(result, 'hello')\n    })\n    test('handles non-async function results', async () => {\n      const [err, result] = _.try(() => {\n        return 'hello'\n      })()\n      assert.isUndefined(err)\n      assert.isNotNull(result)\n      assert.equal(result, 'hello')\n    })\n    test('handles non-async function errors', async () => {\n      const [err, result] = _.try(() => {\n        if (1 < 0) return ''\n        throw new Error('unknown')\n      })()\n      assert.isUndefined(result)\n      assert.isNotNull(err)\n      assert.equal(err!.message, 'unknown')\n    })\n    test('alias exists', () => {\n      assert.isNotNull(_.tryit)\n    })\n  })\n\n  describe('_.sleep function', () => {\n    test('suspends a thread for a specified number of milliseconds', async () => {\n      const ONE_SECOND = 1000\n      const before = Date.now()\n      await _.sleep(ONE_SECOND)\n      const after = Date.now()\n      assert.isAtLeast(after, before + ONE_SECOND)\n    })\n  })\n\n  describe('AggregateError error', () => {\n    const fakeWork = (name?: string) => {\n      const fakeJob = () => {\n        const fakeTask = () => {\n          const fakeMicrotask = () => {\n            const err = new Error()\n            err.name = name ?? 'MicrotaskError'\n            throw err\n          }\n          return fakeMicrotask()\n        }\n        return fakeTask()\n      }\n      return fakeJob()\n    }\n    test('uses stack from the first given error', () => {\n      const errors: Error[] = []\n      try {\n        fakeWork()\n      } catch (e) {\n        errors.push(e as Error)\n      }\n      const aggregate = new AggregateError(errors)\n      assert.include(aggregate.stack, 'at fakeMicrotask')\n      assert.include(aggregate.message, 'with 1')\n    })\n    test('uses stack from first error with a stack', () => {\n      const errors: Error[] = [{} as Error]\n      try {\n        fakeWork()\n      } catch (e) {\n        errors.push(e as Error)\n      }\n      const aggregate = new AggregateError(errors)\n      assert.equal(aggregate.name, 'AggregateError(MicrotaskError...)')\n      assert.include(aggregate.stack, 'at fakeMicrotask')\n      assert.include(aggregate.message, 'with 2')\n    })\n    test('does not fail if no errors given', () => {\n      new AggregateError([])\n      new AggregateError(undefined as unknown as Error[])\n    })\n  })\n\n  describe('_.parallel function', () => {\n    test('returns all results from all functions', async () => {\n      const [errors, results] = await _.try(async () => {\n        return _.parallel(1, _.list(1, 3), async num => {\n          await _.sleep(1000)\n          return `hi_${num}`\n        })\n      })()\n      assert.isUndefined(errors)\n      assert.deepEqual(results, ['hi_1', 'hi_2', 'hi_3'])\n    })\n    test('throws erros as array of all errors', async () => {\n      const [error, results] = await _.try(async () => {\n        return _.parallel(1, _.list(1, 3), async num => {\n          await _.sleep(1000)\n          if (num === 2) throw new Error('number is 2')\n          return `hi_${num}`\n        })\n      })()\n      const err = error as AggregateError\n      assert.isUndefined(results)\n      assert.equal(err.errors.length, 1)\n      assert.equal(err.errors[0].message, 'number is 2')\n    })\n    test('does not run more than the limit at once', async () => {\n      let numInProgress = 0\n      const tracking: number[] = []\n      await _.parallel(3, _.list(1, 14), async () => {\n        numInProgress++\n        tracking.push(numInProgress)\n        await _.sleep(300)\n        numInProgress--\n      })\n      assert.deepEqual(Math.max(...tracking), 3)\n    })\n  })\n\n  describe('_.retry', () => {\n    type Options = {\n      times?: number\n      delay?: number | null\n      backoff?: (count: number) => number\n    }\n\n    const NULL = null as unknown as Options\n\n    test('returns result of given function', async () => {\n      const result = await _.retry(NULL, async bail => {\n        return 'hello'\n      })\n      assert.equal(result, 'hello')\n    })\n    test('simple + quick + happy path', async () => {\n      const result = await _.retry(NULL, async () => {\n        return 'hello'\n      })\n      assert.equal(result, 'hello')\n    })\n    test('retries on failure', async () => {\n      let failedOnce = false\n      const result = await _.retry(NULL, async bail => {\n        if (!failedOnce) {\n          failedOnce = true\n          throw 'Failing for test'\n        }\n        return 'hello'\n      })\n      assert.equal(result, 'hello')\n    })\n    test('quits on bail', async () => {\n      try {\n        await _.retry({}, async bail => {\n          bail('iquit')\n        })\n      } catch (err) {\n        assert.equal(err, 'iquit')\n        return\n      }\n      assert.fail('error should have been thrown')\n    })\n    test('quits after max retries', async () => {\n      try {\n        await _.retry({}, async () => {\n          throw 'quitagain'\n        })\n      } catch (err) {\n        assert.equal(err, 'quitagain')\n        return\n      }\n      assert.fail('error should have been thrown')\n    })\n    test('quits after max retries without delay', async () => {\n      try {\n        const func = async () => {\n          throw 'quitagain'\n        }\n        await _.retry({ times: 3 }, func)\n      } catch (err) {\n        assert.equal(err, 'quitagain')\n        return\n      }\n      assert.fail('error should have been thrown')\n    })\n    test('quits after max retries with delay', async () => {\n      try {\n        const func = async () => {\n          throw 'quitagain'\n        }\n        await _.retry({ delay: 100 }, func)\n      } catch (err) {\n        assert.equal(err, 'quitagain')\n        return\n      }\n      assert.fail('error should have been thrown')\n    })\n    test('uses backoff between retries', async () => {\n      let count = 0\n      let backoffs: number = 0\n      const start = Date.now()\n      await _.retry(\n        {\n          times: 3,\n          backoff: i => {\n            backoffs += i ** 10\n            return i ** 10\n          }\n        },\n        async () => {\n          count++\n          if (count < 3) throw 'error'\n        }\n      )\n      const diff = Date.now() - start\n      assert.equal(count, 3)\n      // Time taken should at least be the\n      // total ms backed off. Using exponential\n      // backoff (above) 3 times (passing on\n      // the third try) that is:\n      //   - 10**1 + 10**2 = 1025\n      // The performance typically comes in 1\n      // or 2 milliseconds after.\n      assert.isAtLeast(diff, backoffs)\n    })\n  })\n\n  describe('_.guard', () => {\n    it('returns result of given async function', async () => {\n      const result = await _.guard(async () => {\n        return 'hello'\n      })\n      assert.equal(result, 'hello')\n    })\n    it('returns result of given sync function', async () => {\n      const result = _.guard(() => {\n        return 'hello'\n      })\n      assert.equal(result, 'hello')\n    })\n    it('returns error if given async function throws', async () => {\n      const result =\n        (await _.guard(async () => {\n          throw new Error('error')\n        })) ?? 'good-bye'\n      assert.equal(result, 'good-bye')\n    })\n    it('returns error if given sync function throws', async () => {\n      const alwaysThrow = () => {\n        if (1 > 0) throw new Error('error')\n        return undefined\n      }\n      const result = _.guard(alwaysThrow) ?? 'good-bye'\n      assert.equal(result, 'good-bye')\n    })\n    it('throws error if shouldGuard returns false', async () => {\n      const makeFetchUser = (id: number) => {\n        return async () => {\n          if (id === 1) return 'user1'\n          if (id === 2) throw new Error('user not found')\n          throw new Error('unknown error')\n        }\n      }\n      const isUserNotFoundErr = (err: any) => err.message === 'user not found'\n      const fetchUser = async (id: number) =>\n        (await _.guard(makeFetchUser(id), isUserNotFoundErr)) ?? 'default-user'\n\n      const user1 = await fetchUser(1)\n      assert.equal(user1, 'user1')\n\n      const user2 = await fetchUser(2)\n      assert.equal(user2, 'default-user')\n\n      try {\n        await fetchUser(3)\n        assert.fail()\n      } catch (err: any) {\n        assert.equal(err.message, 'unknown error')\n      }\n    })\n  })\n\n  describe('_.all', () => {\n    const promise = {\n      resolve: <T>(value: T) => new Promise<T>(res => res(value)),\n      reject: (err: any) => new Promise((res, rej) => rej(err))\n    }\n    it('returns array with values in correct order when given array', async () => {\n      const result = await _.all([\n        promise.resolve(22),\n        promise.resolve('hello'),\n        promise.resolve({ name: 'ray' })\n      ])\n      assert.deepEqual(result, [22, 'hello', { name: 'ray' }])\n    })\n    it('returns object with values in correct keys when given object', async () => {\n      const result = await _.all({\n        num: promise.resolve(22),\n        str: promise.resolve('hello'),\n        obj: promise.resolve({ name: 'ray' })\n      })\n      assert.deepEqual(result, {\n        num: 22,\n        str: 'hello',\n        obj: { name: 'ray' }\n      })\n    })\n    it('throws aggregate error when a single promise fails (in object mode)', async () => {\n      try {\n        await _.all({\n          num: promise.resolve(22),\n          str: promise.resolve('hello'),\n          err: promise.reject(new Error('broken'))\n        })\n      } catch (e: any) {\n        const err = e as AggregateError\n        assert.equal(err.errors.length, 1)\n        assert.equal(err.errors[0].message, 'broken')\n        return\n      }\n      assert.fail('Expected error to be thrown but it was not')\n    })\n    it('throws aggregate error when a single promise fails (in array mode)', async () => {\n      try {\n        await _.all([\n          promise.resolve(22),\n          promise.resolve('hello'),\n          promise.reject(new Error('broken'))\n        ])\n      } catch (e: any) {\n        const err = e as AggregateError\n        assert.equal(err.errors.length, 1)\n        assert.equal(err.errors[0].message, 'broken')\n        return\n      }\n      assert.fail('Expected error to be thrown but it was not')\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: radash\nTest File Path: radash\\curry.test.ts\\curry.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nexport function chain<T1 extends any[], T2, T3>(\n  f1: (...arg: T1) => T2,\n  f2: (arg: T2) => T3\n): (...arg: T1) => T3\nexport function chain<T1 extends any[], T2, T3, T4>(\n  f1: (...arg: T1) => T2,\n  f2: (arg: T2) => T3,\n  f3: (arg: T3) => T4\n): (...arg: T1) => T4\nexport function chain<T1 extends any[], T2, T3, T4, T5>(\n  f1: (...arg: T1) => T2,\n  f2: (arg: T2) => T3,\n  f3: (arg: T3) => T4,\n  f4: (arg: T3) => T5\n): (...arg: T1) => T5\nexport function chain<T1 extends any[], T2, T3, T4, T5, T6>(\n  f1: (...arg: T1) => T2,\n  f2: (arg: T2) => T3,\n  f3: (arg: T3) => T4,\n  f4: (arg: T3) => T5,\n  f5: (arg: T3) => T6\n): (...arg: T1) => T6\nexport function chain<T1 extends any[], T2, T3, T4, T5, T6, T7>(\n  f1: (...arg: T1) => T2,\n  f2: (arg: T2) => T3,\n  f3: (arg: T3) => T4,\n  f4: (arg: T3) => T5,\n  f5: (arg: T3) => T6,\n  f6: (arg: T3) => T7\n): (...arg: T1) => T7\nexport function chain<T1 extends any[], T2, T3, T4, T5, T6, T7, T8>(\n  f1: (...arg: T1) => T2,\n  f2: (arg: T2) => T3,\n  f3: (arg: T3) => T4,\n  f4: (arg: T3) => T5,\n  f5: (arg: T3) => T6,\n  f6: (arg: T3) => T7,\n  f7: (arg: T3) => T8\n): (...arg: T1) => T8\nexport function chain<T1 extends any[], T2, T3, T4, T5, T6, T7, T8, T9>(\n  f1: (...arg: T1) => T2,\n  f2: (arg: T2) => T3,\n  f3: (arg: T3) => T4,\n  f4: (arg: T3) => T5,\n  f5: (arg: T3) => T6,\n  f6: (arg: T3) => T7,\n  f7: (arg: T3) => T8,\n  f8: (arg: T3) => T9\n): (...arg: T1) => T9\nexport function chain<T1 extends any[], T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n  f1: (...arg: T1) => T2,\n  f2: (arg: T2) => T3,\n  f3: (arg: T3) => T4,\n  f4: (arg: T3) => T5,\n  f5: (arg: T3) => T6,\n  f6: (arg: T3) => T7,\n  f7: (arg: T3) => T8,\n  f8: (arg: T3) => T9,\n  f9: (arg: T3) => T10\n): (...arg: T1) => T10\nexport function chain<\n  T1 extends any[],\n  T2,\n  T3,\n  T4,\n  T5,\n  T6,\n  T7,\n  T8,\n  T9,\n  T10,\n  T11\n>(\n  f1: (...arg: T1) => T2,\n  f2: (arg: T2) => T3,\n  f3: (arg: T3) => T4,\n  f4: (arg: T3) => T5,\n  f5: (arg: T3) => T6,\n  f6: (arg: T3) => T7,\n  f7: (arg: T3) => T8,\n  f8: (arg: T3) => T9,\n  f9: (arg: T3) => T10,\n  f10: (arg: T3) => T11\n): (...arg: T1) => T11\nexport function chain(...funcs: ((...args: any[]) => any)[]) {\n  return (...args: any[]) => {\n    return funcs.slice(1).reduce((acc, fn) => fn(acc), funcs[0](...args))\n  }\n}\n\nexport function compose<\n  F1Result,\n  F1Args extends any[],\n  F1NextArgs extends any[],\n  LastResult\n>(\n  f1: (\n    next: (...args: F1NextArgs) => LastResult\n  ) => (...args: F1Args) => F1Result,\n  last: (...args: F1NextArgs) => LastResult\n): (...args: F1Args) => F1Result\n\nexport function compose<\n  F1Result,\n  F1Args extends any[],\n  F1NextArgs extends any[],\n  F2Result,\n  F2NextArgs extends any[],\n  LastResult\n>(\n  f1: (\n    next: (...args: F1NextArgs) => F2Result\n  ) => (...args: F1Args) => F1Result,\n  f2: (\n    next: (...args: F2NextArgs) => LastResult\n  ) => (...args: F1NextArgs) => F2Result,\n  last: (...args: F2NextArgs) => LastResult\n): (...args: F1Args) => F1Result\n\nexport function compose<\n  F1Result,\n  F1Args extends any[],\n  F1NextArgs extends any[],\n  F2NextArgs extends any[],\n  F2Result,\n  F3NextArgs extends any[],\n  F3Result,\n  LastResult\n>(\n  f1: (\n    next: (...args: F1NextArgs) => F2Result\n  ) => (...args: F1Args) => F1Result,\n  f2: (\n    next: (...args: F2NextArgs) => F3Result\n  ) => (...args: F1NextArgs) => F2Result,\n  f3: (\n    next: (...args: F3NextArgs) => LastResult\n  ) => (...args: F2NextArgs) => F3Result,\n  last: (...args: F3NextArgs) => LastResult\n): (...args: F1Args) => F1Result\n\nexport function compose<\n  F1Result,\n  F1Args extends any[],\n  F1NextArgs extends any[],\n  F2NextArgs extends any[],\n  F2Result,\n  F3NextArgs extends any[],\n  F3Result,\n  F4NextArgs extends any[],\n  F4Result,\n  LastResult\n>(\n  f1: (\n    next: (...args: F1NextArgs) => F2Result\n  ) => (...args: F1Args) => F1Result,\n  f2: (\n    next: (...args: F2NextArgs) => F3Result\n  ) => (...args: F1NextArgs) => F2Result,\n  f3: (\n    next: (...args: F3NextArgs) => F4Result\n  ) => (...args: F2NextArgs) => F3Result,\n  f4: (\n    next: (...args: F4NextArgs) => LastResult\n  ) => (...args: F3NextArgs) => F4Result,\n  last: (...args: F4NextArgs) => LastResult\n): (...args: F1Args) => F1Result\n\nexport function compose<\n  F1Result,\n  F1Args extends any[],\n  F1NextArgs extends any[],\n  F2NextArgs extends any[],\n  F2Result,\n  F3NextArgs extends any[],\n  F3Result,\n  F4NextArgs extends any[],\n  F4Result,\n  F5NextArgs extends any[],\n  F5Result,\n  LastResult\n>(\n  f1: (\n    next: (...args: F1NextArgs) => F2Result\n  ) => (...args: F1Args) => F1Result,\n  f2: (\n    next: (...args: F2NextArgs) => F3Result\n  ) => (...args: F1NextArgs) => F2Result,\n  f3: (\n    next: (...args: F3NextArgs) => F4Result\n  ) => (...args: F2NextArgs) => F3Result,\n  f4: (\n    next: (...args: F4NextArgs) => F5Result\n  ) => (...args: F3NextArgs) => F4Result,\n  f5: (\n    next: (...args: F5NextArgs) => LastResult\n  ) => (...args: F4NextArgs) => F5Result,\n  last: (...args: F5NextArgs) => LastResult\n): (...args: F1Args) => F1Result\n\nexport function compose<\n  F1Result,\n  F1Args extends any[],\n  F1NextArgs extends any[],\n  F2NextArgs extends any[],\n  F2Result,\n  F3NextArgs extends any[],\n  F3Result,\n  F4NextArgs extends any[],\n  F4Result,\n  F5NextArgs extends any[],\n  F5Result,\n  F6NextArgs extends any[],\n  F6Result,\n  LastResult\n>(\n  f1: (\n    next: (...args: F1NextArgs) => F2Result\n  ) => (...args: F1Args) => F1Result,\n  f2: (\n    next: (...args: F2NextArgs) => F3Result\n  ) => (...args: F1NextArgs) => F2Result,\n  f3: (\n    next: (...args: F3NextArgs) => F4Result\n  ) => (...args: F2NextArgs) => F3Result,\n  f4: (\n    next: (...args: F4NextArgs) => F5Result\n  ) => (...args: F3NextArgs) => F4Result,\n  f5: (\n    next: (...args: F5NextArgs) => F6Result\n  ) => (...args: F4NextArgs) => F5Result,\n  f6: (\n    next: (...args: F6NextArgs) => LastResult\n  ) => (...args: F5NextArgs) => F6Result,\n  last: (...args: F6NextArgs) => LastResult\n): (...args: F1Args) => F1Result\n\nexport function compose<\n  F1Result,\n  F1Args extends any[],\n  F1NextArgs extends any[],\n  F2NextArgs extends any[],\n  F2Result,\n  F3NextArgs extends any[],\n  F3Result,\n  F4NextArgs extends any[],\n  F4Result,\n  F5NextArgs extends any[],\n  F5Result,\n  F6NextArgs extends any[],\n  F6Result,\n  F7NextArgs extends any[],\n  F7Result,\n  LastResult\n>(\n  f1: (\n    next: (...args: F1NextArgs) => F2Result\n  ) => (...args: F1Args) => F1Result,\n  f2: (\n    next: (...args: F2NextArgs) => F3Result\n  ) => (...args: F1NextArgs) => F2Result,\n  f3: (\n    next: (...args: F3NextArgs) => F4Result\n  ) => (...args: F2NextArgs) => F3Result,\n  f4: (\n    next: (...args: F4NextArgs) => F5Result\n  ) => (...args: F3NextArgs) => F4Result,\n  f5: (\n    next: (...args: F5NextArgs) => F6Result\n  ) => (...args: F4NextArgs) => F5Result,\n  f6: (\n    next: (...args: F6NextArgs) => F7Result\n  ) => (...args: F5NextArgs) => F6Result,\n  f7: (\n    next: (...args: F7NextArgs) => LastResult\n  ) => (...args: F6NextArgs) => F7Result,\n  last: (...args: F7NextArgs) => LastResult\n): (...args: F1Args) => F1Result\n\nexport function compose<\n  F1Result,\n  F1Args extends any[],\n  F1NextArgs extends any[],\n  F2NextArgs extends any[],\n  F2Result,\n  F3NextArgs extends any[],\n  F3Result,\n  F4NextArgs extends any[],\n  F4Result,\n  F5NextArgs extends any[],\n  F5Result,\n  F6NextArgs extends any[],\n  F6Result,\n  F7NextArgs extends any[],\n  F7Result,\n  F8NextArgs extends any[],\n  F8Result,\n  LastResult\n>(\n  f1: (\n    next: (...args: F1NextArgs) => F2Result\n  ) => (...args: F1Args) => F1Result,\n  f2: (\n    next: (...args: F2NextArgs) => F3Result\n  ) => (...args: F1NextArgs) => F2Result,\n  f3: (\n    next: (...args: F3NextArgs) => F4Result\n  ) => (...args: F2NextArgs) => F3Result,\n  f4: (\n    next: (...args: F4NextArgs) => F5Result\n  ) => (...args: F3NextArgs) => F4Result,\n  f5: (\n    next: (...args: F5NextArgs) => F6Result\n  ) => (...args: F4NextArgs) => F5Result,\n  f6: (\n    next: (...args: F6NextArgs) => F7Result\n  ) => (...args: F5NextArgs) => F6Result,\n  f7: (\n    next: (...args: F7NextArgs) => LastResult\n  ) => (...args: F6NextArgs) => F7Result,\n  f8: (\n    next: (...args: F8NextArgs) => LastResult\n  ) => (...args: F7NextArgs) => F8Result,\n  last: (...args: F8NextArgs) => LastResult\n): (...args: F1Args) => F1Result\n\nexport function compose<\n  F1Result,\n  F1Args extends any[],\n  F1NextArgs extends any[],\n  F2NextArgs extends any[],\n  F2Result,\n  F3NextArgs extends any[],\n  F3Result,\n  F4NextArgs extends any[],\n  F4Result,\n  F5NextArgs extends any[],\n  F5Result,\n  F6NextArgs extends any[],\n  F6Result,\n  F7NextArgs extends any[],\n  F7Result,\n  F8NextArgs extends any[],\n  F8Result,\n  F9NextArgs extends any[],\n  F9Result,\n  LastResult\n>(\n  f1: (\n    next: (...args: F1NextArgs) => F2Result\n  ) => (...args: F1Args) => F1Result,\n  f2: (\n    next: (...args: F2NextArgs) => F3Result\n  ) => (...args: F1NextArgs) => F2Result,\n  f3: (\n    next: (...args: F3NextArgs) => F4Result\n  ) => (...args: F2NextArgs) => F3Result,\n  f4: (\n    next: (...args: F4NextArgs) => F5Result\n  ) => (...args: F3NextArgs) => F4Result,\n  f5: (\n    next: (...args: F5NextArgs) => F6Result\n  ) => (...args: F4NextArgs) => F5Result,\n  f6: (\n    next: (...args: F6NextArgs) => F7Result\n  ) => (...args: F5NextArgs) => F6Result,\n  f7: (\n    next: (...args: F7NextArgs) => LastResult\n  ) => (...args: F6NextArgs) => F7Result,\n  f8: (\n    next: (...args: F8NextArgs) => LastResult\n  ) => (...args: F7NextArgs) => F8Result,\n  f9: (\n    next: (...args: F9NextArgs) => LastResult\n  ) => (...args: F8NextArgs) => F9Result,\n  last: (...args: F9NextArgs) => LastResult\n): (...args: F1Args) => F1Result\n\nexport function compose(...funcs: ((...args: any[]) => any)[]) {\n  return funcs.reverse().reduce((acc, fn) => fn(acc))\n}\n\n/**\n * This type produces the type array of TItems with all the type items\n * in TItemsToRemove removed from the start of the array type.\n *\n * @example\n * ```\n * RemoveItemsInFront<[number, number], [number]> = [number]\n * RemoveItemsInFront<[File, number, string], [File, number]> = [string]\n * ```\n */\ntype RemoveItemsInFront<\n  TItems extends any[],\n  TItemsToRemove extends any[]\n> = TItems extends [...TItemsToRemove, ...infer TRest] ? TRest : TItems\n\nexport const partial = <T extends any[], TA extends Partial<T>, R>(\n  fn: (...args: T) => R,\n  ...args: TA\n) => {\n  return (...rest: RemoveItemsInFront<T, TA>) =>\n    fn(...([...args, ...rest] as T))\n}\n/**\n * Like partial but for unary functions that accept\n * a single object argument\n */\nexport const partob = <T, K, PartialArgs extends Partial<T>>(\n  fn: (args: T) => K,\n  argobj: PartialArgs\n) => {\n  return (restobj: Omit<T, keyof PartialArgs>): K =>\n    fn({\n      ...(argobj as Partial<T>),\n      ...(restobj as Partial<T>)\n    } as T)\n}\n\n/**\n * Creates a Proxy object that will dynamically\n * call the handler argument when attributes are\n * accessed\n */\nexport const proxied = <T, K>(\n  handler: (propertyName: T) => K\n): Record<string, K> => {\n  return new Proxy(\n    {},\n    {\n      get: (target, propertyName: any) => handler(propertyName)\n    }\n  )\n}\n\ntype Cache<T> = Record<string, { exp: number | null; value: T }>\n\nconst memoize = <TArgs extends any[], TResult>(\n  cache: Cache<TResult>,\n  func: (...args: TArgs) => TResult,\n  keyFunc: ((...args: TArgs) => string) | null,\n  ttl: number | null\n) => {\n  return function callWithMemo(...args: any): TResult {\n    const key = keyFunc ? keyFunc(...args) : JSON.stringify({ args })\n    const existing = cache[key]\n    if (existing !== undefined) {\n      if (!existing.exp) return existing.value\n      if (existing.exp > new Date().getTime()) {\n        return existing.value\n      }\n    }\n    const result = func(...args)\n    cache[key] = {\n      exp: ttl ? new Date().getTime() + ttl : null,\n      value: result\n    }\n    return result\n  }\n}\n\n/**\n * Creates a memoized function. The returned function\n * will only execute the source function when no value\n * has previously been computed. If a ttl (milliseconds)\n * is given previously computed values will be checked\n * for expiration before being returned.\n */\nexport const memo = <TArgs extends any[], TResult>(\n  func: (...args: TArgs) => TResult,\n  options: {\n    key?: (...args: TArgs) => string\n    ttl?: number\n  } = {}\n) => {\n  return memoize({}, func, options.key ?? null, options.ttl ?? null) as (\n    ...args: TArgs\n  ) => TResult\n}\n\nexport type DebounceFunction<TArgs extends any[]> = {\n  (...args: TArgs): void\n  /**\n   * Cancels the debounced function\n   */\n  cancel(): void\n  /**\n   * Checks if there is any invocation debounced\n   */\n  isPending(): boolean\n  /**\n   * Runs the debounced function immediately\n   */\n  flush(...args: TArgs): void\n}\n\nexport type ThrottledFunction<TArgs extends any[]> = {\n  (...args: TArgs): void\n  /**\n   * Checks if there is any invocation throttled\n   */\n  isThrottled(): boolean\n}\n\n/**\n * Given a delay and a function returns a new function\n * that will only call the source function after delay\n * milliseconds have passed without any invocations.\n *\n * The debounce function comes with a `cancel` method\n * to cancel delayed `func` invocations and a `flush`\n * method to invoke them immediately\n */\nexport const debounce = <TArgs extends any[]>(\n  { delay }: { delay: number },\n  func: (...args: TArgs) => any\n) => {\n  let timer: NodeJS.Timeout | undefined = undefined\n  let active = true\n\n  const debounced: DebounceFunction<TArgs> = (...args: TArgs) => {\n    if (active) {\n      clearTimeout(timer)\n      timer = setTimeout(() => {\n        active && func(...args)\n        timer = undefined\n      }, delay)\n    } else {\n      func(...args)\n    }\n  }\n  debounced.isPending = () => {\n    return timer !== undefined\n  }\n  debounced.cancel = () => {\n    active = false\n  }\n  debounced.flush = (...args: TArgs) => func(...args)\n\n  return debounced\n}\n\n/**\n * Given an interval and a function returns a new function\n * that will only call the source function if interval milliseconds\n * have passed since the last invocation\n */\nexport const throttle = <TArgs extends any[]>(\n  { interval }: { interval: number },\n  func: (...args: TArgs) => any\n) => {\n  let ready = true\n  let timer: NodeJS.Timeout | undefined = undefined\n\n  const throttled: ThrottledFunction<TArgs> = (...args: TArgs) => {\n    if (!ready) return\n    func(...args)\n    ready = false\n    timer = setTimeout(() => {\n      ready = true\n      timer = undefined\n    }, interval)\n  }\n  throttled.isThrottled = () => {\n    return timer !== undefined\n  }\n  return throttled\n}\n\n/**\n * Make an object callable. Given an object and a function\n * the returned object will be a function with all the\n * objects properties.\n *\n * @example\n * ```typescript\n * const car = callable({\n *   wheels: 2\n * }, self => () => {\n *   return 'driving'\n * })\n *\n * car.wheels // => 2\n * car() // => 'driving'\n * ```\n */\nexport const callable = <\n  TValue,\n  TObj extends Record<string | number | symbol, TValue>,\n  TFunc extends (...args: any) => any\n>(\n  obj: TObj,\n  fn: (self: TObj) => TFunc\n): TObj & TFunc => {\n  /* istanbul ignore next */\n  const FUNC = () => {}\n  return new Proxy(Object.assign(FUNC, obj), {\n    get: (target, key: string) => target[key],\n    set: (target, key: string, value: any) => {\n      ;(target as any)[key] = value\n      return true\n    },\n    apply: (target, self, args) => fn(Object.assign({}, target))(...args)\n  }) as unknown as TObj & TFunc\n}\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:11:35"}, {"role": "assistant", "content": "```ts\nimport { assert } from 'chai'\nimport * as _ from '..'\nimport type { DebounceFunction } from '../curry'\n\ndescribe('curry module', () => {\n  describe('compose function', () => {\n    test('composes functions', () => {\n      const useZero = (fn: (num: number) => number) => () => fn(0)\n      const objectize =\n        (fn: (obj: { num: number }) => number) => (num: number) =>\n          fn({ num })\n      const increment =\n        (fn: (arg: { num: number }) => number) =>\n        ({ num }: { num: number }) =>\n          fn({ num: num + 1 })\n      const returnArg = (arg: 'num') => (args: { num: number }) => args[arg]\n\n      const composed = _.compose(\n        useZero,\n        objectize,\n        increment,\n        increment,\n        returnArg('num')\n      )\n\n      const decomposed = useZero(\n        objectize(increment(increment(returnArg('num'))))\n      )\n\n      const expected = decomposed()\n      const result = composed()\n\n      assert.equal(result, expected)\n      assert.equal(result, 2)\n    })\n    test('composes async function', async () => {\n      const useZero = (fn: (num: number) => Promise<number>) => async () =>\n        fn(0)\n      const objectize =\n        (fn: (obj: { num: number }) => Promise<number>) =>\n        async (num: number) =>\n          fn({ num })\n      const increment =\n        (fn: (arg: { num: number }) => Promise<number>) =>\n        async ({ num }: { num: number }) =>\n          fn({ num: num + 1 })\n      const returnArg = (arg: 'num') => async (args: { num: number }) =>\n        args[arg]\n\n      const composed = _.compose(\n        useZero,\n        objectize,\n        increment,\n        increment,\n        returnArg('num')\n      )\n\n      const decomposed = useZero(\n        objectize(increment(increment(returnArg('num'))))\n      )\n\n      const expected = await decomposed()\n      const result = await composed()\n\n      assert.equal(result, expected)\n    })\n    test('composes function type overloads', () => {\n      const useZero = (fn: (num: number) => number) => () => fn(0)\n      const objectize =\n        (fn: (obj: { num: number }) => number) => (num: number) =>\n          fn({ num })\n      const increment =\n        (fn: (arg: { num: number }) => number) =>\n        ({ num }: { num: number }) =>\n          fn({ num: num + 1 })\n      const returnArg = (arg: 'num') => (args: { num: number }) => args[arg]\n      const returnNum = () => (num: number) => num\n\n      assert.equal(_.compose(useZero, returnNum())(), 0)\n\n      assert.equal(_.compose(useZero, objectize, returnArg('num'))(), 0)\n\n      assert.equal(\n        _.compose(useZero, objectize, increment, returnArg('num'))(),\n        1\n      )\n\n      assert.equal(\n        _.compose(useZero, objectize, increment, increment, returnArg('num'))(),\n        2\n      )\n\n      assert.equal(\n        _.compose(\n          useZero,\n          objectize,\n          increment,\n          increment,\n          increment,\n          returnArg('num')\n        )(),\n        3\n      )\n\n      assert.equal(\n        _.compose(\n          useZero,\n          objectize,\n          increment,\n          increment,\n          increment,\n          increment,\n          returnArg('num')\n        )(),\n        4\n      )\n\n      assert.equal(\n        _.compose(\n          useZero,\n          objectize,\n          increment,\n          increment,\n          increment,\n          increment,\n          increment,\n          returnArg('num')\n        )(),\n        5\n      )\n\n      assert.equal(\n        _.compose(\n          useZero,\n          objectize,\n          increment,\n          increment,\n          increment,\n          increment,\n          increment,\n          increment,\n          returnArg('num')\n        )(),\n        6\n      )\n\n      assert.equal(\n        _.compose(\n          useZero,\n          objectize,\n          increment,\n          increment,\n          increment,\n          increment,\n          increment,\n          increment,\n          increment,\n          returnArg('num')\n        )(),\n        7\n      )\n    })\n  })\n\n  describe('partial function', () => {\n    test('passes single args', () => {\n      const add = (a: number, b: number) => a + b\n      const expected = 20\n      const partialed = _.partial(add, 10)\n      const result = partialed(10)\n      assert.equal(result, expected)\n    })\n    test('passes many args', () => {\n      const add = (...nums: number[]) => nums.reduce((a, b) => a + b, 0)\n      const expected = 10\n      const result = _.partial(add, 2, 2, 2)(2, 2)\n      assert.equal(result, expected)\n    })\n  })\n\n  describe('partob function', () => {\n    test('partob passes single args', () => {\n      const add = ({ a, b }: { a: number; b: number }) => a + b\n      const expected = 20\n      const result = _.partob(add, { a: 10 })({ b: 10 })\n      assert.equal(result, expected)\n    })\n    test('partob overrides inital with later', () => {\n      const add = ({ a, b }: { a: number; b: number }) => a + b\n      const expected = 15\n      const result = _.partob(add, { a: 10 })({ a: 5, b: 10 } as any)\n      assert.equal(result, expected)\n    })\n  })\n\n  describe('chain function', () => {\n    test('calls all given functions', () => {\n      const genesis = (num: number, name: string) => 0\n      const addFive = (num: number) => num + 5\n      const twoX = (num: number) => num * 2\n      const func = _.chain(genesis, addFive, twoX)\n      const result = func(0, '')\n      assert.equal(result, 10)\n    })\n\n    test('calls add(1), then addFive, then twoX functions by 1', () => {\n      const add = (y: number) => (x: number) => x + y\n      const addFive = add(5)\n      const twoX = (num: number) => num * 2\n      const func = _.chain(add(1), addFive, twoX)\n      const result = func(1)\n      assert.equal(result, 14)\n    })\n\n    test('calls add(2), then addFive, then twoX, then repeatX functions by 1', () => {\n      const add = (y: number) => (x: number) => x + y\n      const addFive = add(5)\n      const twoX = (num: number) => num * 2\n      const repeatX = (num: number) => 'X'.repeat(num)\n      const func = _.chain(add(2), addFive, twoX, repeatX)\n      const result = func(1)\n      assert.equal(result, 'XXXXXXXXXXXXXXXX')\n    })\n\n    test('calls addFive, then add(2), then twoX, then repeatX functions by 1', () => {\n      const add = (y: number) => (x: number) => x + y\n      const addFive = add(5)\n      const twoX = (num: number) => num * 2\n      const repeatX = (num: number) => 'X'.repeat(num)\n      const func = _.chain(addFive, add(2), twoX, repeatX)\n      const result = func(1)\n      assert.equal(result, 'XXXXXXXXXXXXXXXX')\n    })\n\n    test('calls getName, then upperCase functions as a mapper for User[]', () => {\n      type User = { id: number; name: string }\n      const users: User[] = [\n        { id: 1, name: 'John Doe' },\n        { id: 2, name: 'John Smith' },\n        { id: 3, name: 'John Wick' }\n      ]\n      const getName = <T extends { name: string }>(item: T) => item.name\n      const upperCase: (x: string) => Uppercase<string> = (text: string) =>\n        text.toUpperCase() as Uppercase<string>\n\n      const getUpperName = _.chain(getName, upperCase)\n      const result = users.map(getUpperName)\n      assert.deepEqual(result, ['JOHN DOE', 'JOHN SMITH', 'JOHN WICK'])\n    })\n  })\n\n  describe('proxied function', () => {\n    test('returns proxy that calls callback function', () => {\n      const handler = (propertyName: string) => {\n        if (propertyName === 'x') return 2\n        if (propertyName === 'getName') return () => 'radash'\n        return undefined\n      }\n      const proxy = _.proxied(handler) as any\n      assert.equal(proxy.x, 2)\n      assert.equal(proxy.getName(), 'radash')\n      assert.isUndefined(proxy.nil)\n    })\n  })\n\n  describe('memo function', () => {\n    test('only executes function once', () => {\n      const func = _.memo(() => new Date().getTime())\n      const resultA = func()\n      const resultB = func()\n      assert.equal(resultA, resultB)\n    })\n    test('uses key to identify unique calls', () => {\n      const func = _.memo(\n        (arg: { user: { id: string } }) => {\n          const ts = new Date().getTime()\n          return `${ts}::${arg.user.id}`\n        },\n        {\n          key: arg => arg.user.id\n        }\n      )\n      const resultA = func({ user: { id: 'alpha' } })\n      const resultB = func({ user: { id: 'beta' } })\n      const resultA2 = func({ user: { id: 'alpha' } })\n      assert.equal(resultA, resultA2)\n      assert.notEqual(resultB, resultA)\n    })\n    test('calls function again when first value expires', async () => {\n      const func = _.memo(() => new Date().getTime(), {\n        ttl: 1\n      })\n      const resultA = func()\n      await new Promise(res => setTimeout(res, 100))\n      const resultB = func()\n      assert.notEqual(resultA, resultB)\n    })\n    test('does not call function again when first value has not expired', async () => {\n      const func = _.memo(() => new Date().getTime(), {\n        ttl: 1000\n      })\n      const resultA = func()\n      await new Promise(res => setTimeout(res, 100))\n      const resultB = func()\n      assert.equal(resultA, resultB)\n    })\n  })\n\n  describe('debounce function', () => {\n    let func: DebounceFunction<any>\n    const mockFunc = jest.fn()\n    const runFunc3Times = () => {\n      func()\n      func()\n      func()\n    }\n\n    beforeEach(() => {\n      func = _.debounce({ delay: 600 }, mockFunc)\n    })\n\n    afterEach(() => {\n      jest.clearAllMocks()\n    })\n\n    test('only executes once when called rapidly', async () => {\n      runFunc3Times()\n      expect(mockFunc).toHaveBeenCalledTimes(0)\n      await _.sleep(610)\n      expect(mockFunc).toHaveBeenCalledTimes(1)\n    })\n\n    test('does not debounce after cancel is called', () => {\n      runFunc3Times()\n      expect(mockFunc).toHaveBeenCalledTimes(0)\n      func.cancel()\n      runFunc3Times()\n      expect(mockFunc).toHaveBeenCalledTimes(3)\n      runFunc3Times()\n      expect(mockFunc).toHaveBeenCalledTimes(6)\n    })\n\n    test('executes the function immediately when the flush method is called', () => {\n      func.flush()\n      expect(mockFunc).toHaveBeenCalledTimes(1)\n    })\n\n    test('continues to debounce after flush is called', async () => {\n      runFunc3Times()\n      expect(mockFunc).toHaveBeenCalledTimes(0)\n      func.flush()\n      expect(mockFunc).toHaveBeenCalledTimes(1)\n      func()\n      expect(mockFunc).toHaveBeenCalledTimes(1)\n      await _.sleep(610)\n      expect(mockFunc).toHaveBeenCalledTimes(2)\n      func.flush()\n      expect(mockFunc).toHaveBeenCalledTimes(3)\n    })\n\n    test('cancels all pending invocations when the cancel method is called', async () => {\n      const results: boolean[] = []\n      func()\n      results.push(func.isPending())\n      results.push(func.isPending())\n      await _.sleep(610)\n      results.push(func.isPending())\n      func()\n      results.push(func.isPending())\n      await _.sleep(610)\n      results.push(func.isPending())\n      assert.deepEqual(results, [true, true, false, true, false])\n    })\n\n    test('returns if there is any pending invocation when the pending method is called', async () => {\n      func()\n      func.cancel()\n      await _.sleep(610)\n      expect(mockFunc).toHaveBeenCalledTimes(0)\n    })\n  })\n\n  describe('throttle function', () => {\n    test('throttles!', async () => {\n      let calls = 0\n      const func = _.throttle({ interval: 600 }, () => calls++)\n      func()\n      func()\n      func()\n      assert.equal(calls, 1)\n      await _.sleep(610)\n      func()\n      func()\n      func()\n      assert.equal(calls, 2)\n    })\n\n    test('returns if the throttle is active', async () => {\n      const results = []\n      const func = _.throttle({ interval: 600 }, () => {})\n      results.push(func.isThrottled())\n      func()\n      results.push(func.isThrottled())\n      func()\n      results.push(func.isThrottled())\n      func()\n      results.push(func.isThrottled())\n      await _.sleep(610)\n      results.push(func.isThrottled())\n      assert.deepEqual(results, [false, true, true, true, false])\n    })\n  })\n})\n\ndescribe('callable function', () => {\n  test('makes object callable', async () => {\n    const request = {\n      source: 'client',\n      body: 'ford',\n      doors: 2\n    }\n\n    const call = _.callable(request, self => (id: string) => ({ ...self, id }))\n\n    expect(call.source).toBe('client')\n    expect(call.body).toBe('ford')\n    expect(call.doors).toBe(2)\n    const s = call('23')\n    expect(s.doors).toBe(2)\n    expect(s.id).toBe('23')\n\n    call.doors = 4\n    expect(call.doors).toBe(4)\n    const x = call('9')\n    expect(x.doors).toBe(4)\n    expect(x.id).toBe('9')\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: radash\nTest File Path: radash\\number.test.ts\\number.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\n/**\n * Checks if the given number is between zero (0) and the ending number. 0 is inclusive.\n *\n * * Numbers can be negative or positive.\n * * Ending number is exclusive.\n *\n * @param {number} number The number to check.\n * @param {number} end The end of the range. Exclusive.\n * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n */\nexport function inRange(number: number, end: number): boolean\n\n/**\n * Checks if the given number is between two numbers.\n *\n * * Numbers can be negative or positive.\n * * Starting number is inclusive.\n * * Ending number is exclusive.\n * * The start and the end of the range can be ascending OR descending order.\n *\n * @param {number} number The number to check.\n * @param {number} start The start of the range. Inclusive.\n * @param {number} end The end of the range. Exclusive.\n * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n */\nexport function inRange(number: number, start: number, end: number): boolean\nexport function inRange(number: number, start: number, end?: number): boolean {\n  const isTypeSafe =\n    typeof number === 'number' &&\n    typeof start === 'number' &&\n    (typeof end === 'undefined' || typeof end === 'number')\n\n  if (!isTypeSafe) {\n    return false\n  }\n\n  if (typeof end === 'undefined') {\n    end = start\n    start = 0\n  }\n\n  return number >= Math.min(start, end) && number < Math.max(start, end)\n}\n\nexport const toFloat = <T extends number | null = number>(\n  value: any,\n  defaultValue?: T\n): number | T => {\n  const def = defaultValue === undefined ? 0.0 : defaultValue\n  if (value === null || value === undefined) {\n    return def\n  }\n  const result = parseFloat(value)\n  return isNaN(result) ? def : result\n}\n\nexport const toInt = <T extends number | null = number>(\n  value: any,\n  defaultValue?: T\n): number | T => {\n  const def = defaultValue === undefined ? 0 : defaultValue\n  if (value === null || value === undefined) {\n    return def\n  }\n  const result = parseInt(value)\n  return isNaN(result) ? def : result\n}\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:11:35"}, {"role": "assistant", "content": "```ts\nimport { assert } from 'chai'\nimport * as _ from '..'\n\ndescribe('number module', () => {\n  describe('inRange function', () => {\n    test('handles nullish values', () => {\n      assert.strictEqual(_.inRange(0, 1, null as any), false)\n      assert.strictEqual(_.inRange(0, null as any, 1), false)\n      assert.strictEqual(_.inRange(null as any, 0, 1), false)\n      assert.strictEqual(_.inRange(0, undefined as any, 1), false)\n      assert.strictEqual(_.inRange(undefined as any, 0, 1), false)\n\n      assert.strictEqual(_.inRange(0, 1, undefined as any), true)\n    })\n    test('handles bad input', () => {\n      const result = _.inRange(0, 1, {} as any)\n      assert.strictEqual(result, false)\n    })\n    test('computes correctly', () => {\n      assert.strictEqual(_.inRange(10, 0, 5), false)\n      assert.strictEqual(_.inRange(10, 0, 20), true)\n      assert.strictEqual(_.inRange(-10, 0, -20), true)\n      assert.strictEqual(_.inRange(9.99, 0, 10), true)\n      assert.strictEqual(_.inRange(Math.PI, 0, 3.15), true)\n    })\n    test('handles the different syntax of number type', () => {\n      assert.strictEqual(_.inRange(0, -1, 1), true)\n      assert.strictEqual(_.inRange(Number(0), -1, 1), true)\n      assert.strictEqual(_.inRange(+'0', -1, 1), true)\n    })\n    test('handles two params', () => {\n      assert.strictEqual(_.inRange(1, 2), true)\n      assert.strictEqual(_.inRange(1.2, 2), true)\n      assert.strictEqual(_.inRange(2, 1), false)\n      assert.strictEqual(_.inRange(2, 2), false)\n      assert.strictEqual(_.inRange(3.2, 2), false)\n      assert.strictEqual(_.inRange(-1, 1), false)\n      assert.strictEqual(_.inRange(-1, -10), true)\n    })\n    test('handles the exclusive end of the range', () => {\n      assert.strictEqual(_.inRange(1, 0, 1), false)\n      assert.strictEqual(_.inRange(10.0, 0, 10), false)\n    })\n    test('handles the inclusive start of the range', () => {\n      assert.strictEqual(_.inRange(0, 0, 1), true)\n      assert.strictEqual(_.inRange(10.0, 10, 20), true)\n    })\n  })\n\n  describe('toFloat function', () => {\n    test('handles null', () => {\n      const result = _.toFloat(null)\n      assert.strictEqual(result, 0.0)\n    })\n    test('handles undefined', () => {\n      const result = _.toFloat(undefined)\n      assert.strictEqual(result, 0.0)\n    })\n    test('uses null default', () => {\n      const result = _.toFloat('x', null)\n      assert.strictEqual(result, null)\n    })\n    test('handles bad input', () => {\n      const result = _.toFloat({})\n      assert.strictEqual(result, 0.0)\n    })\n    test('converts 20.00 correctly', () => {\n      const result = _.toFloat('20.00')\n      assert.strictEqual(result, 20.0)\n    })\n  })\n\n  describe('toInt function', () => {\n    test('handles null', () => {\n      const result = _.toInt(null)\n      assert.strictEqual(result, 0)\n    })\n    test('uses null default', () => {\n      const result = _.toInt('x', null)\n      assert.strictEqual(result, null)\n    })\n    test('handles undefined', () => {\n      const result = _.toInt(undefined)\n      assert.strictEqual(result, 0)\n    })\n    test('handles bad input', () => {\n      const result = _.toInt({})\n      assert.strictEqual(result, 0)\n    })\n    test('converts 20 correctly', () => {\n      const result = _.toInt('20')\n      assert.strictEqual(result, 20)\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: radash\nTest File Path: radash\\object.test.ts\\object.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { objectify } from './array'\nimport { toInt } from './number'\nimport { isArray, isObject, isPrimitive } from './typed'\n\ntype LowercasedKeys<T extends Record<string, any>> = {\n  [P in keyof T & string as Lowercase<P>]: T[P]\n}\n\ntype UppercasedKeys<T extends Record<string, any>> = {\n  [P in keyof T & string as Uppercase<P>]: T[P]\n}\n\n/**\n * Removes (shakes out) undefined entries from an\n * object. Optional second argument shakes out values\n * by custom evaluation.\n */\nexport const shake = <RemovedKeys extends string, T>(\n  obj: T,\n  filter: (value: any) => boolean = x => x === undefined\n): Omit<T, RemovedKeys> => {\n  if (!obj) return {} as T\n  const keys = Object.keys(obj) as (keyof T)[]\n  return keys.reduce((acc, key) => {\n    if (filter(obj[key])) {\n      return acc\n    } else {\n      acc[key] = obj[key]\n      return acc\n    }\n  }, {} as T)\n}\n\n/**\n * Map over all the keys of an object to return\n * a new object\n */\nexport const mapKeys = <\n  TValue,\n  TKey extends string | number | symbol,\n  TNewKey extends string | number | symbol\n>(\n  obj: Record<TKey, TValue>,\n  mapFunc: (key: TKey, value: TValue) => TNewKey\n): Record<TNewKey, TValue> => {\n  const keys = Object.keys(obj) as TKey[]\n  return keys.reduce((acc, key) => {\n    acc[mapFunc(key as TKey, obj[key])] = obj[key]\n    return acc\n  }, {} as Record<TNewKey, TValue>)\n}\n\n/**\n * Map over all the keys to create a new object\n */\nexport const mapValues = <\n  TValue,\n  TKey extends string | number | symbol,\n  TNewValue\n>(\n  obj: Record<TKey, TValue>,\n  mapFunc: (value: TValue, key: TKey) => TNewValue\n): Record<TKey, TNewValue> => {\n  const keys = Object.keys(obj) as TKey[]\n  return keys.reduce((acc, key) => {\n    acc[key] = mapFunc(obj[key], key)\n    return acc\n  }, {} as Record<TKey, TNewValue>)\n}\n\n/**\n * Map over all the keys to create a new object\n */\nexport const mapEntries = <\n  TKey extends string | number | symbol,\n  TValue,\n  TNewKey extends string | number | symbol,\n  TNewValue\n>(\n  obj: Record<TKey, TValue>,\n  toEntry: (key: TKey, value: TValue) => [TNewKey, TNewValue]\n): Record<TNewKey, TNewValue> => {\n  if (!obj) return {} as Record<TNewKey, TNewValue>\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    const [newKey, newValue] = toEntry(key as TKey, value as TValue)\n    acc[newKey] = newValue\n    return acc\n  }, {} as Record<TNewKey, TNewValue>)\n}\n\n/**\n * Returns an object with { [keys]: value }\n * inverted as { [value]: key }\n */\nexport const invert = <\n  TKey extends string | number | symbol,\n  TValue extends string | number | symbol\n>(\n  obj: Record<TKey, TValue>\n): Record<TValue, TKey> => {\n  if (!obj) return {} as Record<TValue, TKey>\n  const keys = Object.keys(obj) as TKey[]\n  return keys.reduce((acc, key) => {\n    acc[obj[key]] = key\n    return acc\n  }, {} as Record<TValue, TKey>)\n}\n\n/**\n * Convert all keys in an object to lower case\n */\nexport const lowerize = <T extends Record<string, any>>(obj: T) =>\n  mapKeys(obj, k => k.toLowerCase()) as LowercasedKeys<T>\n\n/**\n * Convert all keys in an object to upper case\n */\nexport const upperize = <T extends Record<string, any>>(obj: T) =>\n  mapKeys(obj, k => k.toUpperCase()) as UppercasedKeys<T>\n\n/**\n * Creates a shallow copy of the given obejct/value.\n * @param {*} obj value to clone\n * @returns {*} shallow clone of the given value\n */\nexport const clone = <T>(obj: T): T => {\n  // Primitive values do not need cloning.\n  if (isPrimitive(obj)) {\n    return obj\n  }\n\n  // Binding a function to an empty object creates a\n  // copy function.\n  if (typeof obj === 'function') {\n    return obj.bind({})\n  }\n\n  // Access the constructor and create a new object.\n  // This method can create an array as well.\n  const newObj = new ((obj as object).constructor as { new (): T })()\n\n  // Assign the props.\n  Object.getOwnPropertyNames(obj).forEach(prop => {\n    // Bypass type checking since the primitive cases\n    // are already checked in the beginning\n    ;(newObj as any)[prop] = (obj as any)[prop]\n  })\n\n  return newObj\n}\n\n/**\n * Convert an object to a list, mapping each entry\n * into a list item\n */\nexport const listify = <TValue, TKey extends string | number | symbol, KResult>(\n  obj: Record<TKey, TValue>,\n  toItem: (key: TKey, value: TValue) => KResult\n) => {\n  if (!obj) return []\n  const entries = Object.entries(obj)\n  if (entries.length === 0) return []\n  return entries.reduce((acc, entry) => {\n    acc.push(toItem(entry[0] as TKey, entry[1] as TValue))\n    return acc\n  }, [] as KResult[])\n}\n\n/**\n * Pick a list of properties from an object\n * into a new object\n */\nexport const pick = <T extends object, TKeys extends keyof T>(\n  obj: T,\n  keys: TKeys[]\n): Pick<T, TKeys> => {\n  if (!obj) return {} as Pick<T, TKeys>\n  return keys.reduce((acc, key) => {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) acc[key] = obj[key]\n    return acc\n  }, {} as Pick<T, TKeys>)\n}\n\n/**\n * Omit a list of properties from an object\n * returning a new object with the properties\n * that remain\n */\nexport const omit = <T, TKeys extends keyof T>(\n  obj: T,\n  keys: TKeys[]\n): Omit<T, TKeys> => {\n  if (!obj) return {} as Omit<T, TKeys>\n  if (!keys || keys.length === 0) return obj as Omit<T, TKeys>\n  return keys.reduce(\n    (acc, key) => {\n      // Gross, I know, it's mutating the object, but we\n      // are allowing it in this very limited scope due\n      // to the performance implications of an omit func.\n      // Not a pattern or practice to use elsewhere.\n      delete acc[key]\n      return acc\n    },\n    { ...obj }\n  )\n}\n\n/**\n * Dynamically get a nested value from an array or\n * object with a string.\n *\n * @example get(person, 'friends[0].name')\n */\nexport const get = <TDefault = unknown>(\n  value: any,\n  path: string,\n  defaultValue?: TDefault\n): TDefault => {\n  const segments = path.split(/[\\.\\[\\]]/g)\n  let current: any = value\n  for (const key of segments) {\n    if (current === null) return defaultValue as TDefault\n    if (current === undefined) return defaultValue as TDefault\n    const dequoted = key.replace(/['\"]/g, '')\n    if (dequoted.trim() === '') continue\n    current = current[dequoted]\n  }\n  if (current === undefined) return defaultValue as TDefault\n  return current\n}\n\n/**\n * Opposite of get, dynamically set a nested value into\n * an object using a key path. Does not modify the given\n * initial object.\n *\n * @example\n * set({}, 'name', 'ra') // => { name: 'ra' }\n * set({}, 'cards[0].value', 2) // => { cards: [{ value: 2 }] }\n */\nexport const set = <T extends object, K>(\n  initial: T,\n  path: string,\n  value: K\n): T => {\n  if (!initial) return {} as T\n  if (!path || value === undefined) return initial\n  const segments = path.split(/[\\.\\[\\]]/g).filter(x => !!x.trim())\n  const _set = (node: any) => {\n    if (segments.length > 1) {\n      const key = segments.shift() as string\n      const nextIsNum = toInt(segments[0], null) === null ? false : true\n      node[key] = node[key] === undefined ? (nextIsNum ? [] : {}) : node[key]\n      _set(node[key])\n    } else {\n      node[segments[0]] = value\n    }\n  }\n  // NOTE: One day, when structuredClone has more\n  // compatability use it to clone the value\n  // https://developer.mozilla.org/en-US/docs/Web/API/structuredClone\n  const cloned = clone(initial)\n  _set(cloned)\n  return cloned\n}\n\n/**\n * Merges two objects together recursivly into a new\n * object applying values from right to left.\n * Recursion only applies to child object properties.\n */\nexport const assign = <X extends Record<string | symbol | number, any>>(\n  initial: X,\n  override: X\n): X => {\n  if (!initial || !override) return initial ?? override ?? {}\n\n  return Object.entries({ ...initial, ...override }).reduce(\n    (acc, [key, value]) => {\n      return {\n        ...acc,\n        [key]: (() => {\n          if (isObject(initial[key])) return assign(initial[key], value)\n          // if (isArray(value)) return value.map(x => assign)\n          return value\n        })()\n      }\n    },\n    {} as X\n  )\n}\n\n/**\n * Get a string list of all key names that exist in\n * an object (deep).\n *\n * @example\n * keys({ name: 'ra' }) // ['name']\n * keys({ name: 'ra', children: [{ name: 'hathor' }] }) // ['name', 'children.0.name']\n */\nexport const keys = <TValue extends object>(value: TValue): string[] => {\n  if (!value) return []\n  const getKeys = (nested: any, paths: string[]): string[] => {\n    if (isObject(nested)) {\n      return Object.entries(nested).flatMap(([k, v]) =>\n        getKeys(v, [...paths, k])\n      )\n    }\n    if (isArray(nested)) {\n      return nested.flatMap((item, i) => getKeys(item, [...paths, `${i}`]))\n    }\n    return [paths.join('.')]\n  }\n  return getKeys(value, [])\n}\n\n/**\n * Flattens a deep object to a single demension, converting\n * the keys to dot notation.\n *\n * @example\n * crush({ name: 'ra', children: [{ name: 'hathor' }] })\n * // { name: 'ra', 'children.0.name': 'hathor' }\n */\nexport const crush = <TValue extends object>(value: TValue): object => {\n  if (!value) return {}\n  return objectify(\n    keys(value),\n    k => k,\n    k => get(value, k)\n  )\n}\n\n/**\n * The opposite of crush, given an object that was\n * crushed into key paths and values will return\n * the original object reconstructed.\n *\n * @example\n * construct({ name: 'ra', 'children.0.name': 'hathor' })\n * // { name: 'ra', children: [{ name: 'hathor' }] }\n */\nexport const construct = <TObject extends object>(obj: TObject): object => {\n  if (!obj) return {}\n  return Object.keys(obj).reduce((acc, path) => {\n    return set(acc, path, (obj as any)[path])\n  }, {})\n}\n\n### Source File Dependency Files Content\n### Dependency File: array.ts\nimport { isArray, isFunction } from './typed'\n\n/**\n * Sorts an array of items into groups. The return value is a map where the keys are\n * the group ids the given getGroupId function produced and the value is an array of\n * each item in that group.\n */\nexport const group = <T, Key extends string | number | symbol>(\n  array: readonly T[],\n  getGroupId: (item: T) => Key\n): Partial<Record<Key, T[]>> => {\n  return array.reduce((acc, item) => {\n    const groupId = getGroupId(item)\n    if (!acc[groupId]) acc[groupId] = []\n    acc[groupId].push(item)\n    return acc\n  }, {} as Record<Key, T[]>)\n}\n\n/**\n * Creates an array of grouped elements, the first of which contains the\n * first elements of the given arrays, the second of which contains the\n * second elements of the given arrays, and so on.\n *\n * Ex. const zipped = zip(['a', 'b'], [1, 2], [true, false]) // [['a', 1, true], ['b', 2, false]]\n */\nexport function zip<T1, T2, T3, T4, T5>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[],\n  array5: T5[]\n): [T1, T2, T3, T4, T5][]\nexport function zip<T1, T2, T3, T4>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[]\n): [T1, T2, T3, T4][]\nexport function zip<T1, T2, T3>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[]\n): [T1, T2, T3][]\nexport function zip<T1, T2>(array1: T1[], array2: T2[]): [T1, T2][]\nexport function zip<T>(...arrays: T[][]): T[][] {\n  if (!arrays || !arrays.length) return []\n  return new Array(Math.max(...arrays.map(({ length }) => length)))\n    .fill([])\n    .map((_, idx) => arrays.map(array => array[idx]))\n}\n\n/**\n * Creates an object mapping the specified keys to their corresponding values\n *\n * Ex. const zipped = zipToObject(['a', 'b'], [1, 2]) // { a: 1, b: 2 }\n * Ex. const zipped = zipToObject(['a', 'b'], (k, i) => k + i) // { a: 'a0', b: 'b1' }\n * Ex. const zipped = zipToObject(['a', 'b'], 1) // { a: 1, b: 1 }\n */\nexport function zipToObject<K extends string | number | symbol, V>(\n  keys: K[],\n  values: V | ((key: K, idx: number) => V) | V[]\n): Record<K, V> {\n  if (!keys || !keys.length) {\n    return {} as Record<K, V>\n  }\n\n  const getValue = isFunction(values)\n    ? values\n    : isArray(values)\n    ? (_k: K, i: number) => values[i]\n    : (_k: K, _i: number) => values\n\n  return keys.reduce((acc, key, idx) => {\n    acc[key] = getValue(key, idx)\n    return acc\n  }, {} as Record<K, V>)\n}\n\n/**\n * Go through a list of items, starting with the first item,\n * and comparing with the second. Keep the one you want then\n * compare that to the next item in the list with the same\n *\n * Ex. const greatest = () => boil(numbers, (a, b) => a > b)\n */\nexport const boil = <T>(\n  array: readonly T[],\n  compareFunc: (a: T, b: T) => T\n) => {\n  if (!array || (array.length ?? 0) === 0) return null\n  return array.reduce(compareFunc)\n}\n\n/**\n * Sum all numbers in an array. Optionally provide a function\n * to convert objects in the array to number values.\n */\nexport function sum<T extends number>(array: readonly T[]): number\nexport function sum<T extends object>(\n  array: readonly T[],\n  fn: (item: T) => number\n): number\nexport function sum<T extends object | number>(\n  array: readonly any[],\n  fn?: (item: T) => number\n): number {\n  return (array || []).reduce((acc, item) => acc + (fn ? fn(item) : item), 0)\n}\n\n/**\n * Get the first item in an array or a default value\n */\nexport const first = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[0] : defaultValue\n}\n\n/**\n * Get the last item in an array or a default value\n */\nexport const last = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[array.length - 1] : defaultValue\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value\n */\nexport const sort = <T>(\n  array: readonly T[],\n  getter: (item: T) => number,\n  desc = false\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => getter(a) - getter(b)\n  const dsc = (a: T, b: T) => getter(b) - getter(a)\n  return array.slice().sort(desc === true ? dsc : asc)\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value. Allows for a string\n * sorting value.\n */\nexport const alphabetical = <T>(\n  array: readonly T[],\n  getter: (item: T) => string,\n  dir: 'asc' | 'desc' = 'asc'\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => `${getter(a)}`.localeCompare(getter(b))\n  const dsc = (a: T, b: T) => `${getter(b)}`.localeCompare(getter(a))\n  return array.slice().sort(dir === 'desc' ? dsc : asc)\n}\n\nexport const counting = <T, TId extends string | number | symbol>(\n  list: readonly T[],\n  identity: (item: T) => TId\n): Record<TId, number> => {\n  if (!list) return {} as Record<TId, number>\n  return list.reduce((acc, item) => {\n    const id = identity(item)\n    acc[id] = (acc[id] ?? 0) + 1\n    return acc\n  }, {} as Record<TId, number>)\n}\n\n/**\n * Replace an element in an array with a new\n * item without modifying the array and return\n * the new value\n */\nexport const replace = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (item: T, idx: number) => boolean\n): T[] => {\n  if (!list) return []\n  if (newItem === undefined) return [...list]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list]\n}\n\n/**\n * Convert an array to a dictionary by mapping each item\n * into a dictionary key & value\n */\nexport const objectify = <T, Key extends string | number | symbol, Value = T>(\n  array: readonly T[],\n  getKey: (item: T) => Key,\n  getValue: (item: T) => Value = item => item as unknown as Value\n): Record<Key, Value> => {\n  return array.reduce((acc, item) => {\n    acc[getKey(item)] = getValue(item)\n    return acc\n  }, {} as Record<Key, Value>)\n}\n\n/**\n * Select performs a filter and a mapper inside of a reduce,\n * only iterating the list one time.\n *\n * @example\n * select([1, 2, 3, 4], x => x*x, x > 2) == [9, 16]\n */\nexport const select = <T, K>(\n  array: readonly T[],\n  mapper: (item: T, index: number) => K,\n  condition: (item: T, index: number) => boolean\n) => {\n  if (!array) return []\n  return array.reduce((acc, item, index) => {\n    if (!condition(item, index)) return acc\n    acc.push(mapper(item, index))\n    return acc\n  }, [] as K[])\n}\n\n/**\n * Max gets the greatest value from a list\n *\n * @example\n * max([ 2, 3, 5]) == 5\n * max([{ num: 1 }, { num: 2 }], x => x.num) == { num: 2 }\n */\nexport function max(array: readonly [number, ...number[]]): number\nexport function max(array: readonly number[]): number | null\nexport function max<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function max<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) > get(b) ? a : b))\n}\n\n/**\n * Min gets the smallest value from a list\n *\n * @example\n * min([1, 2, 3, 4]) == 1\n * min([{ num: 1 }, { num: 2 }], x => x.num) == { num: 1 }\n */\nexport function min(array: readonly [number, ...number[]]): number\nexport function min(array: readonly number[]): number | null\nexport function min<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function min<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) < get(b) ? a : b))\n}\n\n/**\n * Splits a single list into many lists of the desired size. If\n * given a list of 10 items and a size of 2, it will return 5\n * lists with 2 items each\n */\nexport const cluster = <T>(list: readonly T[], size: number = 2): T[][] => {\n  const clusterCount = Math.ceil(list.length / size)\n  return new Array(clusterCount).fill(null).map((_c: null, i: number) => {\n    return list.slice(i * size, i * size + size)\n  })\n}\n\n/**\n * Given a list of items returns a new list with only\n * unique items. Accepts an optional identity function\n * to convert each item in the list to a comparable identity\n * value\n */\nexport const unique = <T, K extends string | number | symbol>(\n  array: readonly T[],\n  toKey?: (item: T) => K\n): T[] => {\n  const valueMap = array.reduce((acc, item) => {\n    const key = toKey ? toKey(item) : (item as any as string | number | symbol)\n    if (acc[key]) return acc\n    acc[key] = item\n    return acc\n  }, {} as Record<string | number | symbol, T>)\n  return Object.values(valueMap)\n}\n\n/**\n * Creates a generator that will produce an iteration through\n * the range of number as requested.\n *\n * @example\n * range(3)                  // yields 0, 1, 2, 3\n * range(0, 3)               // yields 0, 1, 2, 3\n * range(0, 3, 'y')          // yields y, y, y, y\n * range(0, 3, () => 'y')    // yields y, y, y, y\n * range(0, 3, i => i)       // yields 0, 1, 2, 3\n * range(0, 3, i => `y${i}`) // yields y0, y1, y2, y3\n * range(0, 3, obj)          // yields obj, obj, obj, obj\n * range(0, 6, i => i, 2)    // yields 0, 2, 4, 6\n */\nexport function* range<T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper: T | ((i: number) => T) = i => i as T,\n  step: number = 1\n): Generator<T> {\n  const mapper = isFunction(valueOrMapper) ? valueOrMapper : () => valueOrMapper\n  const start = end ? startOrLength : 0\n  const final = end ?? startOrLength\n  for (let i = start; i <= final; i += step) {\n    yield mapper(i)\n    if (i + step > final) break\n  }\n}\n\n/**\n * Creates a list of given start, end, value, and\n * step parameters.\n *\n * @example\n * list(3)                  // 0, 1, 2, 3\n * list(0, 3)               // 0, 1, 2, 3\n * list(0, 3, 'y')          // y, y, y, y\n * list(0, 3, () => 'y')    // y, y, y, y\n * list(0, 3, i => i)       // 0, 1, 2, 3\n * list(0, 3, i => `y${i}`) // y0, y1, y2, y3\n * list(0, 3, obj)          // obj, obj, obj, obj\n * list(0, 6, i => i, 2)    // 0, 2, 4, 6\n */\nexport const list = <T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper?: T | ((i: number) => T),\n  step?: number\n): T[] => {\n  return Array.from(range(startOrLength, end, valueOrMapper, step))\n}\n\n/**\n * Given an array of arrays, returns a single\n * dimentional array with all items in it.\n */\nexport const flat = <T>(lists: readonly T[][]): T[] => {\n  return lists.reduce((acc, list) => {\n    acc.push(...list)\n    return acc\n  }, [])\n}\n\n/**\n * Given two arrays, returns true if any\n * elements intersect\n */\nexport const intersects = <T, K extends string | number | symbol>(\n  listA: readonly T[],\n  listB: readonly T[],\n  identity?: (t: T) => K\n): boolean => {\n  if (!listA || !listB) return false\n  const ident = identity ?? ((x: T) => x as unknown as K)\n  const dictB = listB.reduce((acc, item) => {\n    acc[ident(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return listA.some(value => dictB[ident(value)])\n}\n\n/**\n * Split an array into two array based on\n * a true/false condition function\n */\nexport const fork = <T>(\n  list: readonly T[],\n  condition: (item: T) => boolean\n): [T[], T[]] => {\n  if (!list) return [[], []]\n  return list.reduce(\n    (acc, item) => {\n      const [a, b] = acc\n      if (condition(item)) {\n        return [[...a, item], b]\n      } else {\n        return [a, [...b, item]]\n      }\n    },\n    [[], []] as [T[], T[]]\n  )\n}\n\n/**\n * Given two lists of the same type, iterate the first list\n * and replace items matched by the matcher func in the\n * first place.\n */\nexport const merge = <T>(\n  root: readonly T[],\n  others: readonly T[],\n  matcher: (item: T) => any\n) => {\n  if (!others && !root) return []\n  if (!others) return root\n  if (!root) return []\n  if (!matcher) return root\n  return root.reduce((acc, r) => {\n    const matched = others.find(o => matcher(r) === matcher(o))\n    if (matched) acc.push(matched)\n    else acc.push(r)\n    return acc\n  }, [] as T[])\n}\n\n/**\n * Replace an item in an array by a match function condition. If\n * no items match the function condition, appends the new item to\n * the end of the list.\n */\nexport const replaceOrAppend = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (a: T, idx: number) => boolean\n) => {\n  if (!list && !newItem) return []\n  if (!newItem) return [...list]\n  if (!list) return [newItem]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list, newItem]\n}\n\n/**\n * If the item matching the condition already exists\n * in the list it will be removed. If it does not it\n * will be added.\n */\nexport const toggle = <T>(\n  list: readonly T[],\n  item: T,\n  /**\n   * Converts an item of type T item into a value that\n   * can be checked for equality\n   */\n  toKey?: null | ((item: T, idx: number) => number | string | symbol),\n  options?: {\n    strategy?: 'prepend' | 'append'\n  }\n) => {\n  if (!list && !item) return []\n  if (!list) return [item]\n  if (!item) return [...list]\n  const matcher = toKey\n    ? (x: T, idx: number) => toKey(x, idx) === toKey(item, idx)\n    : (x: T) => x === item\n  const existing = list.find(matcher)\n  if (existing) return list.filter((x, idx) => !matcher(x, idx))\n  const strategy = options?.strategy ?? 'append'\n  if (strategy === 'append') return [...list, item]\n  return [item, ...list]\n}\n\ntype Falsy = null | undefined | false | '' | 0 | 0n\n\n/**\n * Given a list returns a new list with\n * only truthy values\n */\nexport const sift = <T>(list: readonly (T | Falsy)[]): T[] => {\n  return (list?.filter(x => !!x) as T[]) ?? []\n}\n\n/**\n * Like a reduce but does not require an array.\n * Only need a number and will iterate the function\n * as many times as specified.\n *\n * NOTE: This is NOT zero indexed. If you pass count=5\n * you will get 1, 2, 3, 4, 5 iteration in the callback\n * function\n */\nexport const iterate = <T>(\n  count: number,\n  func: (currentValue: T, iteration: number) => T,\n  initValue: T\n) => {\n  let value = initValue\n  for (let i = 1; i <= count; i++) {\n    value = func(value, i)\n  }\n  return value\n}\n\n/**\n * Returns all items from the first list that\n * do not exist in the second list.\n */\nexport const diff = <T>(\n  root: readonly T[],\n  other: readonly T[],\n  identity: (item: T) => string | number | symbol = (t: T) =>\n    t as unknown as string | number | symbol\n): T[] => {\n  if (!root?.length && !other?.length) return []\n  if (root?.length === undefined) return [...other]\n  if (!other?.length) return [...root]\n  const bKeys = other.reduce((acc, item) => {\n    acc[identity(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return root.filter(a => !bKeys[identity(a)])\n}\n\n/**\n * Shift array items by n steps\n * If n > 0 items will shift n steps to the right\n * If n < 0 items will shift n steps to the left\n */\nexport function shift<T>(arr: Array<T>, n: number) {\n  if (arr.length === 0) return arr\n\n  const shiftNumber = n % arr.length\n\n  if (shiftNumber === 0) return arr\n\n  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)]\n}\n\n\n### Dependency File: number.ts\n/**\n * Checks if the given number is between zero (0) and the ending number. 0 is inclusive.\n *\n * * Numbers can be negative or positive.\n * * Ending number is exclusive.\n *\n * @param {number} number The number to check.\n * @param {number} end The end of the range. Exclusive.\n * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n */\nexport function inRange(number: number, end: number): boolean\n\n/**\n * Checks if the given number is between two numbers.\n *\n * * Numbers can be negative or positive.\n * * Starting number is inclusive.\n * * Ending number is exclusive.\n * * The start and the end of the range can be ascending OR descending order.\n *\n * @param {number} number The number to check.\n * @param {number} start The start of the range. Inclusive.\n * @param {number} end The end of the range. Exclusive.\n * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n */\nexport function inRange(number: number, start: number, end: number): boolean\nexport function inRange(number: number, start: number, end?: number): boolean {\n  const isTypeSafe =\n    typeof number === 'number' &&\n    typeof start === 'number' &&\n    (typeof end === 'undefined' || typeof end === 'number')\n\n  if (!isTypeSafe) {\n    return false\n  }\n\n  if (typeof end === 'undefined') {\n    end = start\n    start = 0\n  }\n\n  return number >= Math.min(start, end) && number < Math.max(start, end)\n}\n\nexport const toFloat = <T extends number | null = number>(\n  value: any,\n  defaultValue?: T\n): number | T => {\n  const def = defaultValue === undefined ? 0.0 : defaultValue\n  if (value === null || value === undefined) {\n    return def\n  }\n  const result = parseFloat(value)\n  return isNaN(result) ? def : result\n}\n\nexport const toInt = <T extends number | null = number>(\n  value: any,\n  defaultValue?: T\n): number | T => {\n  const def = defaultValue === undefined ? 0 : defaultValue\n  if (value === null || value === undefined) {\n    return def\n  }\n  const result = parseInt(value)\n  return isNaN(result) ? def : result\n}\n\n\n### Dependency File: typed.ts\nexport const isSymbol = (value: any): value is symbol => {\n  return !!value && value.constructor === Symbol\n}\n\nexport const isArray = Array.isArray\n\nexport const isObject = (value: any): value is object => {\n  return !!value && value.constructor === Object\n}\n\n/**\n * Checks if the given value is primitive.\n *\n * Primitive Types: number , string , boolean , symbol, bigint, undefined, null\n *\n * @param {*} value value to check\n * @returns {boolean} result\n */\nexport const isPrimitive = (value: any): boolean => {\n  return (\n    value === undefined ||\n    value === null ||\n    (typeof value !== 'object' && typeof value !== 'function')\n  )\n}\n\nexport const isFunction = (value: any): value is Function => {\n  return !!(value && value.constructor && value.call && value.apply)\n}\n\nexport const isString = (value: any): value is string => {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport const isInt = (value: any): value is number => {\n  return isNumber(value) && value % 1 === 0\n}\n\nexport const isFloat = (value: any): value is number => {\n  return isNumber(value) && value % 1 !== 0\n}\n\nexport const isNumber = (value: any): value is number => {\n  try {\n    return Number(value) === value\n  } catch {\n    return false\n  }\n}\n\nexport const isDate = (value: any): value is Date => {\n  return Object.prototype.toString.call(value) === '[object Date]'\n}\n\n/**\n * This is really a _best guess_ promise checking. You\n * should probably use Promise.resolve(value) to be 100%\n * sure you're handling it correctly.\n */\nexport const isPromise = (value: any): value is Promise<any> => {\n  if (!value) return false\n  if (!value.then) return false\n  if (!isFunction(value.then)) return false\n  return true\n}\n\nexport const isEmpty = (value: any) => {\n  if (value === true || value === false) return true\n  if (value === null || value === undefined) return true\n  if (isNumber(value)) return value === 0\n  if (isDate(value)) return isNaN(value.getTime())\n  if (isFunction(value)) return false\n  if (isSymbol(value)) return false\n  const length = (value as any).length\n  if (isNumber(length)) return length === 0\n  const size = (value as any).size\n  if (isNumber(size)) return size === 0\n  const keys = Object.keys(value).length\n  return keys === 0\n}\n\nexport const isEqual = <TType>(x: TType, y: TType): boolean => {\n  if (Object.is(x, y)) return true\n  if (x instanceof Date && y instanceof Date) {\n    return x.getTime() === y.getTime()\n  }\n  if (x instanceof RegExp && y instanceof RegExp) {\n    return x.toString() === y.toString()\n  }\n  if (\n    typeof x !== 'object' ||\n    x === null ||\n    typeof y !== 'object' ||\n    y === null\n  ) {\n    return false\n  }\n  const keysX = Reflect.ownKeys(x as unknown as object) as (keyof typeof x)[]\n  const keysY = Reflect.ownKeys(y as unknown as object)\n  if (keysX.length !== keysY.length) return false\n  for (let i = 0; i < keysX.length; i++) {\n    if (!Reflect.has(y as unknown as object, keysX[i])) return false\n    if (!isEqual(x[keysX[i]], y[keysX[i]])) return false\n  }\n  return true\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:11:35"}, {"role": "assistant", "content": "```ts\nimport { assert } from 'chai'\nimport * as _ from '..'\n\nconst NULL = null as unknown as {}\n\ndescribe('object module', () => {\n  describe('shake function', () => {\n    test('removes all undefined values', () => {\n      const result = _.shake({\n        x: 2,\n        y: null,\n        z: undefined,\n        o: false,\n        r: 'x'\n      })\n      assert.deepEqual(result, {\n        x: 2,\n        y: null,\n        o: false,\n        r: 'x'\n      })\n    })\n    test('removes values based on filter function input', () => {\n      const result = _.shake(\n        {\n          x: 2,\n          y: null,\n          z: undefined,\n          o: false,\n          r: 'x'\n        },\n        val => val !== 'x'\n      )\n      assert.deepEqual(result, {\n        r: 'x'\n      })\n    })\n    test('handles undefined input', () => {\n      const result = _.shake(undefined)\n      assert.deepEqual(result, {})\n    })\n  })\n\n  describe('mapKeys function', () => {\n    test('runs all keys against mapper function', () => {\n      const prefixWith = (prefix: string) => (str: string) => `${prefix}${str}`\n      const result = _.mapKeys(\n        {\n          x: 22,\n          y: 8\n        },\n        prefixWith('x')\n      )\n      assert.deepEqual(result, {\n        xx: 22,\n        xy: 8\n      })\n    })\n  })\n\n  describe('mapValues function', () => {\n    test('runs all values against mapper function', () => {\n      const prefixWith = (prefix: string) => (str: string) => `${prefix}${str}`\n      const result = _.mapValues(\n        {\n          x: 'hi',\n          y: 'bye'\n        },\n        prefixWith('x')\n      )\n      assert.deepEqual(result, {\n        x: 'xhi',\n        y: 'xbye'\n      })\n    })\n  })\n\n  describe('lowerize function', () => {\n    test('changes all keys to lower case', () => {\n      const result = _.lowerize({\n        'X-Api-Key': 'value',\n        Bearer: 'value'\n      })\n      assert.deepEqual(result, {\n        'x-api-key': 'value',\n        bearer: 'value'\n      })\n    })\n  })\n\n  describe('upperize function', () => {\n    test('changes all keys to upper case', () => {\n      const result = _.upperize({\n        'x-api-key': 'value',\n        bearer: 'value'\n      })\n      assert.deepEqual(result, {\n        'X-API-KEY': 'value',\n        BEARER: 'value'\n      })\n    })\n  })\n\n  describe('clone function', () => {\n    test('copies the primitives', () => {\n      const arr = [\n        1.1,\n        'How you doin?',\n        false,\n        Symbol('key'),\n        BigInt('1'),\n        undefined,\n        null\n      ]\n      for (const elm of arr) {\n        const newElm = _.clone(elm)\n        assert.equal(elm, newElm)\n      }\n    })\n    test('copies arrays', () => {\n      const arr = [{ a: 0 }, 1, 2, 3]\n      const result = _.clone(arr)\n\n      assert.notEqual(arr, result)\n      for (const i in result) {\n        assert.equal(arr[i], result[i])\n      }\n    })\n    test('copies functions', () => {\n      const fa = () => 0\n      const fb = _.clone(fa)\n\n      assert.notEqual(fa, fb)\n      assert.equal(fa(), fb())\n    })\n    test('copies objects (class instances) without losing the class type', () => {\n      class Data {\n        val = 0\n      }\n\n      const obj = new Data()\n      obj.val = 1\n      const result = _.clone(obj)\n\n      assert.notEqual(obj, result)\n      assert.equal(obj.constructor.name, result.constructor.name)\n      assert.equal(obj.val, result.val)\n    })\n    test('copies all attributes from object', () => {\n      const obj = {\n        x: 22,\n        add: (a: number, b: number) => a + b,\n        child: {\n          key: 'yolo'\n        }\n      }\n      const result = _.clone(obj)\n      assert.equal(result.x, obj.x)\n      assert.equal(result.add(2, 2), obj.add(2, 2))\n      assert.equal(result.child.key, obj.child.key)\n    })\n    test('copies all attributes from class instance', () => {\n      class Data {\n        public x: number = 22\n        public add(a: number, b: number) {\n          return a + b\n        }\n        public child: any = {\n          key: 'yolo'\n        }\n      }\n      const result = _.clone(new Data())\n      assert.equal(result.x, 22)\n      // @warning will not copy functions from class instance\n      // assert.equal(result.add(2, 2), 4)\n      assert.equal(result.child.key, 'yolo')\n    })\n  })\n\n  describe('listify function', () => {\n    test('handles null input', () => {\n      const result = _.listify(null as any as Record<string, string>, () => 1)\n      assert.deepEqual(result, [])\n    })\n    test('handles empty object', () => {\n      const result = _.listify({} as Record<string, string>, () => 1)\n      assert.deepEqual(result, [])\n    })\n    test('calls toItem to convert to list', () => {\n      type Index = 'one' | 'two'\n      const obj: Record<Index, any> = {\n        one: { name: 'ray' },\n        two: { name: 'ash' }\n      }\n      const result = _.listify(obj, (key, value) => ({\n        index: key,\n        name: value.name\n      }))\n      assert.deepEqual(result, [\n        { index: 'one', name: 'ray' },\n        { index: 'two', name: 'ash' }\n      ])\n    })\n  })\n\n  describe('pick function', () => {\n    test('handles null input', () => {\n      const result = _.pick(null as unknown as Record<string, unknown>, [])\n      assert.deepEqual(result, {})\n    })\n    test('handles empty keys', () => {\n      const result = _.pick({ a: 2 }, [])\n      assert.deepEqual(result, {})\n    })\n    test('handle key not in object', () => {\n      const result = _.pick({ a: 2, b: 3 }, ['c'] as any)\n      assert.deepEqual(result, {} as any)\n    })\n    test('handle one key not in object', () => {\n      const result = _.pick({ a: 2, b: 3 }, ['a', 'c'] as any)\n      assert.deepEqual(result, { a: 2 } as any)\n    })\n    test('does not ignore undefined values', () => {\n      const result = _.pick({ a: 2, b: undefined }, ['b'])\n      assert.deepEqual(result, { b: undefined })\n    })\n    test('returns picked properties only', () => {\n      const result = _.pick({ a: 2, b: 4 }, ['a'])\n      assert.deepEqual(result, {\n        a: 2\n      })\n    })\n    test('type: accepts an interface', () => {\n      interface SomeDeclaredType {\n        a: string\n        b: Error\n        c: number[]\n      }\n      const x: SomeDeclaredType = {\n        a: 'alpha',\n        b: new Error('beta'),\n        c: [3]\n      }\n      const result = _.pick(x, ['a'])\n      assert.deepEqual(result, {\n        a: 'alpha'\n      })\n    })\n    test('works with proxified objects', () => {\n      const target = {\n        a: 'hello',\n        b: 'everyone'\n      }\n      const handler1 = {\n        get() {\n          return 'world'\n        }\n      }\n      const proxified = new Proxy(target, handler1)\n      const result = _.pick(proxified, ['a'])\n      assert.deepEqual(result, {\n        a: 'world'\n      })\n    })\n    test('works with objects created without the prototype chain of Object e.g. by `Object.create(null)`', () => {\n      const obj = Object.create(null)\n      obj.a = 2\n      obj.b = 4\n      const result = _.pick(obj, ['a'])\n      assert.deepEqual(result, {\n        a: 2\n      })\n    })\n    test('works with objects that have `hasOwnProperty` overwritten', () => {\n      const obj = { a: 2, b: 4 }\n      // @ts-ignore\n      obj.hasOwnProperty = 'OVERWRITTEN'\n      const result = _.pick(obj, ['a'])\n      assert.deepEqual(result, {\n        a: 2\n      })\n    })\n  })\n\n  describe('omit function', () => {\n    const person = {\n      name: 'jay',\n      age: 20,\n      active: true\n    }\n    test('handles null input', () => {\n      const result = _.omit(null, [])\n      assert.deepEqual(result, {})\n    })\n    test('handles empty keys', () => {\n      const result = _.omit(person, [])\n      assert.deepEqual(result, person)\n    })\n    test('handles null keys', () => {\n      const result = _.omit(person, null as unknown as [])\n      assert.deepEqual(result, person)\n    })\n    test('returns object without omitted properties', () => {\n      const result = _.omit(person, ['name'])\n      assert.deepEqual(result, {\n        age: 20,\n        active: true\n      })\n    })\n  })\n\n  describe('get function', () => {\n    type Person = {\n      name: string\n      age: number\n      friends?: Person[]\n    }\n    const jay: Person = {\n      name: 'jay',\n      age: 17,\n      friends: [\n        {\n          name: 'carl',\n          age: 17,\n          friends: [\n            {\n              name: 'sara',\n              age: 17\n            }\n          ]\n        }\n      ]\n    }\n    test('handles null and undefined input', () => {\n      assert.equal(_.get(null, 'name'), null)\n      assert.equal(_.get(undefined, 'name'), null)\n    })\n    test('respects undefined as default value', () => {\n      assert.equal(_.get({}, 'a.b.c', undefined), undefined)\n    })\n    test('returns specified value or default using path', () => {\n      assert.equal(_.get({ age: undefined }, 'age', 22), 22)\n      assert.equal(_.get(jay, 'friends[0].age'), 17)\n      assert.equal(_.get(jay, 'friends[\"0\"].age'), 17)\n      assert.equal(_.get(jay, 'friends.0.age'), 17)\n      assert.equal(_.get(jay, 'friends.1.age'), null)\n      assert.equal(_.get(jay, 'friends.0.friends[0].name'), 'sara')\n      assert.equal(_.get(jay, 'name'), 'jay')\n      assert.equal(_.get(jay, '[name]'), 'jay')\n      assert.equal(_.get(jay, '[\"name\"]'), 'jay')\n      assert.equal(_.get(jay, 'friends[0][name]'), 'carl')\n      assert.equal(_.get(jay, 'friends[0].friends[0].friends[0].age', 22), 22)\n    })\n  })\n\n  describe('mapEntries function', () => {\n    const peopleByRole = {\n      admin: 'jay',\n      user: 'fey',\n      guest: 'bray'\n    }\n    test('handles null input', () => {\n      const result = _.mapEntries(\n        NULL,\n        null as unknown as (\n          key: never,\n          value: never\n        ) => [string | number | symbol, unknown]\n      )\n      assert.deepEqual(result, {})\n    })\n    test('correctly maps keys and values', () => {\n      const result = _.mapEntries(peopleByRole, (key, value) => [\n        value,\n        key.toUpperCase()\n      ])\n      assert.equal(result.jay, 'ADMIN')\n      assert.equal(result.fey, 'USER')\n      assert.equal(result.bray, 'GUEST')\n    })\n  })\n\n  describe('invert function', () => {\n    const peopleByRole = {\n      admin: 'jay',\n      user: 'fey',\n      guest: 'bray'\n    }\n    test('handles null input', () => {\n      const result = _.invert(NULL)\n      assert.deepEqual(result, {})\n    })\n    test('correctly maps keys and values', () => {\n      const result = _.invert(peopleByRole)\n      assert.equal(result.jay, 'admin')\n      assert.equal(result.fey, 'user')\n      assert.equal(result.bray, 'guest')\n    })\n  })\n\n  describe('assign function', () => {\n    const initial = {\n      name: 'jay',\n      cards: ['ac'],\n      location: {\n        street: '23 main',\n        state: {\n          abbrv: 'FL',\n          name: 'Florida'\n        }\n      }\n    }\n    const override = {\n      name: 'charles',\n      cards: ['4c'],\n      location: {\n        street: '8114 capo',\n        state: {\n          abbrv: 'TX',\n          name: 'Texas'\n        }\n      }\n    }\n    test('handles both null input', () => {\n      const result = _.assign(NULL, NULL)\n      assert.deepEqual(result, {})\n    })\n    test('handles null first input', () => {\n      const result = _.assign({ a: 'y' }, NULL)\n      assert.deepEqual(result, { a: 'y' })\n    })\n    test('handles null last input', () => {\n      const result = _.assign(NULL, { a: 'y' })\n      assert.deepEqual(result, { a: 'y' })\n    })\n    test('correctly assign a with values from b', () => {\n      const result = _.assign(initial, override)\n      assert.deepEqual(result, override)\n    })\n    test('handles initial have unique value', () => {\n      const result = _.assign({ a: 'x' }, {})\n      assert.deepEqual(result, { a: 'x' })\n    })\n    test('handles override have unique value', () => {\n      const result = _.assign({}, { b: 'y' })\n      assert.deepEqual(result, { b: 'y' })\n    })\n  })\n\n  describe('keys function', () => {\n    test('handles bad input', () => {\n      assert.deepEqual(_.keys({}), [])\n      assert.deepEqual(_.keys(null as any), [])\n      assert.deepEqual(_.keys(undefined as any), [])\n    })\n    test('returns correct list of keys', () => {\n      const ra = {\n        name: 'ra',\n        power: 100,\n        friend: {\n          name: 'loki',\n          power: 80\n        },\n        enemies: [\n          {\n            name: 'hathor',\n            power: 12\n          }\n        ]\n      }\n      assert.deepEqual(_.keys(ra), [\n        'name',\n        'power',\n        'friend.name',\n        'friend.power',\n        'enemies.0.name',\n        'enemies.0.power'\n      ])\n    })\n  })\n\n  describe('set function', () => {\n    test('handles bad input', () => {\n      assert.deepEqual(_.set({}, '', {}), {})\n      assert.deepEqual(_.set({}, null as any, {}), {})\n      assert.deepEqual(_.set({}, '', null as any), {})\n      assert.deepEqual(_.set(null as any, '', {}), {})\n      assert.deepEqual(_.set(null as any, null as any, null as any), {})\n      assert.deepEqual(_.set({ foo: true }, 'foo', false), { foo: false })\n      assert.deepEqual(_.set({}, 'foo', 0), { foo: 0 })\n    })\n    test('sets deep values correctly', () => {\n      assert.deepEqual(_.set({}, 'cards.value', 2), {\n        cards: { value: 2 }\n      })\n      assert.deepEqual(_.set({}, 'cards.0.value', 2), {\n        cards: [{ value: 2 }]\n      })\n      assert.deepEqual(_.set({}, 'cards.0.0.value', 2), {\n        cards: [[{ value: 2 }]]\n      })\n      assert.deepEqual(_.set({}, 'cards.[0].[0].value', 2), {\n        cards: [[{ value: 2 }]]\n      })\n      assert.deepEqual(_.set({}, 'cards.[1].[1].value', 2), {\n        cards: [, [, { value: 2 }]]\n      })\n    })\n  })\n\n  describe('crush function', () => {\n    test('handles bad input', () => {\n      assert.deepEqual(_.crush({}), {})\n      assert.deepEqual(_.crush(null as any), {})\n      assert.deepEqual(_.crush(undefined as any), {})\n    })\n    test('returns correctly crushed object', () => {\n      const now = new Date()\n      const ra = {\n        name: 'ra',\n        power: 100,\n        friend: {\n          name: 'loki',\n          power: 80\n        },\n        enemies: [\n          {\n            name: 'hathor',\n            power: 12\n          }\n        ],\n        timestamp: now\n      }\n      assert.deepEqual(_.crush(ra), {\n        name: 'ra',\n        power: 100,\n        'friend.name': 'loki',\n        'friend.power': 80,\n        'enemies.0.name': 'hathor',\n        'enemies.0.power': 12,\n        timestamp: now\n      })\n    })\n  })\n\n  describe('construct function', () => {\n    test('handles bad input', () => {\n      assert.deepEqual(_.construct({}), {})\n      assert.deepEqual(_.construct(null as any), {})\n      assert.deepEqual(_.construct(undefined as any), {})\n    })\n    test('returns correctly constructed object', () => {\n      const now = new Date()\n      const ra = {\n        name: 'ra',\n        power: 100,\n        friend: {\n          name: 'loki',\n          power: 80\n        },\n        enemies: [\n          {\n            name: 'hathor',\n            power: 12\n          },\n          {\n            name: 'vishnu',\n            power: 58\n          }\n        ],\n        timestamp: now\n      }\n      assert.deepEqual(\n        _.construct({\n          name: 'ra',\n          power: 100,\n          'friend.name': 'loki',\n          'friend.power': 80,\n          'enemies.0.name': 'hathor',\n          'enemies.0.power': 12,\n          'enemies.1.name': 'vishnu',\n          'enemies.1.power': 58,\n          timestamp: now\n        }),\n        ra\n      )\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: radash\nTest File Path: radash\\random.test.ts\\random.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { iterate } from './array'\n\n/**\n * Generates a random number between min and max\n */\nexport const random = (min: number, max: number) => {\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\n/**\n * Draw a random item from a list. Returns\n * null if the list is empty\n */\nexport const draw = <T>(array: readonly T[]): T | null => {\n  const max = array.length\n  if (max === 0) {\n    return null\n  }\n  const index = random(0, max - 1)\n  return array[index]\n}\n\nexport const shuffle = <T>(array: readonly T[]): T[] => {\n  return array\n    .map(a => ({ rand: Math.random(), value: a }))\n    .sort((a, b) => a.rand - b.rand)\n    .map(a => a.value)\n}\n\nexport const uid = (length: number, specials: string = '') => {\n  const characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' + specials\n  return iterate(\n    length,\n    acc => {\n      return acc + characters.charAt(random(0, characters.length - 1))\n    },\n    ''\n  )\n}\n\n### Source File Dependency Files Content\n### Dependency File: array.ts\nimport { isArray, isFunction } from './typed'\n\n/**\n * Sorts an array of items into groups. The return value is a map where the keys are\n * the group ids the given getGroupId function produced and the value is an array of\n * each item in that group.\n */\nexport const group = <T, Key extends string | number | symbol>(\n  array: readonly T[],\n  getGroupId: (item: T) => Key\n): Partial<Record<Key, T[]>> => {\n  return array.reduce((acc, item) => {\n    const groupId = getGroupId(item)\n    if (!acc[groupId]) acc[groupId] = []\n    acc[groupId].push(item)\n    return acc\n  }, {} as Record<Key, T[]>)\n}\n\n/**\n * Creates an array of grouped elements, the first of which contains the\n * first elements of the given arrays, the second of which contains the\n * second elements of the given arrays, and so on.\n *\n * Ex. const zipped = zip(['a', 'b'], [1, 2], [true, false]) // [['a', 1, true], ['b', 2, false]]\n */\nexport function zip<T1, T2, T3, T4, T5>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[],\n  array5: T5[]\n): [T1, T2, T3, T4, T5][]\nexport function zip<T1, T2, T3, T4>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[]\n): [T1, T2, T3, T4][]\nexport function zip<T1, T2, T3>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[]\n): [T1, T2, T3][]\nexport function zip<T1, T2>(array1: T1[], array2: T2[]): [T1, T2][]\nexport function zip<T>(...arrays: T[][]): T[][] {\n  if (!arrays || !arrays.length) return []\n  return new Array(Math.max(...arrays.map(({ length }) => length)))\n    .fill([])\n    .map((_, idx) => arrays.map(array => array[idx]))\n}\n\n/**\n * Creates an object mapping the specified keys to their corresponding values\n *\n * Ex. const zipped = zipToObject(['a', 'b'], [1, 2]) // { a: 1, b: 2 }\n * Ex. const zipped = zipToObject(['a', 'b'], (k, i) => k + i) // { a: 'a0', b: 'b1' }\n * Ex. const zipped = zipToObject(['a', 'b'], 1) // { a: 1, b: 1 }\n */\nexport function zipToObject<K extends string | number | symbol, V>(\n  keys: K[],\n  values: V | ((key: K, idx: number) => V) | V[]\n): Record<K, V> {\n  if (!keys || !keys.length) {\n    return {} as Record<K, V>\n  }\n\n  const getValue = isFunction(values)\n    ? values\n    : isArray(values)\n    ? (_k: K, i: number) => values[i]\n    : (_k: K, _i: number) => values\n\n  return keys.reduce((acc, key, idx) => {\n    acc[key] = getValue(key, idx)\n    return acc\n  }, {} as Record<K, V>)\n}\n\n/**\n * Go through a list of items, starting with the first item,\n * and comparing with the second. Keep the one you want then\n * compare that to the next item in the list with the same\n *\n * Ex. const greatest = () => boil(numbers, (a, b) => a > b)\n */\nexport const boil = <T>(\n  array: readonly T[],\n  compareFunc: (a: T, b: T) => T\n) => {\n  if (!array || (array.length ?? 0) === 0) return null\n  return array.reduce(compareFunc)\n}\n\n/**\n * Sum all numbers in an array. Optionally provide a function\n * to convert objects in the array to number values.\n */\nexport function sum<T extends number>(array: readonly T[]): number\nexport function sum<T extends object>(\n  array: readonly T[],\n  fn: (item: T) => number\n): number\nexport function sum<T extends object | number>(\n  array: readonly any[],\n  fn?: (item: T) => number\n): number {\n  return (array || []).reduce((acc, item) => acc + (fn ? fn(item) : item), 0)\n}\n\n/**\n * Get the first item in an array or a default value\n */\nexport const first = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[0] : defaultValue\n}\n\n/**\n * Get the last item in an array or a default value\n */\nexport const last = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[array.length - 1] : defaultValue\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value\n */\nexport const sort = <T>(\n  array: readonly T[],\n  getter: (item: T) => number,\n  desc = false\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => getter(a) - getter(b)\n  const dsc = (a: T, b: T) => getter(b) - getter(a)\n  return array.slice().sort(desc === true ? dsc : asc)\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value. Allows for a string\n * sorting value.\n */\nexport const alphabetical = <T>(\n  array: readonly T[],\n  getter: (item: T) => string,\n  dir: 'asc' | 'desc' = 'asc'\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => `${getter(a)}`.localeCompare(getter(b))\n  const dsc = (a: T, b: T) => `${getter(b)}`.localeCompare(getter(a))\n  return array.slice().sort(dir === 'desc' ? dsc : asc)\n}\n\nexport const counting = <T, TId extends string | number | symbol>(\n  list: readonly T[],\n  identity: (item: T) => TId\n): Record<TId, number> => {\n  if (!list) return {} as Record<TId, number>\n  return list.reduce((acc, item) => {\n    const id = identity(item)\n    acc[id] = (acc[id] ?? 0) + 1\n    return acc\n  }, {} as Record<TId, number>)\n}\n\n/**\n * Replace an element in an array with a new\n * item without modifying the array and return\n * the new value\n */\nexport const replace = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (item: T, idx: number) => boolean\n): T[] => {\n  if (!list) return []\n  if (newItem === undefined) return [...list]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list]\n}\n\n/**\n * Convert an array to a dictionary by mapping each item\n * into a dictionary key & value\n */\nexport const objectify = <T, Key extends string | number | symbol, Value = T>(\n  array: readonly T[],\n  getKey: (item: T) => Key,\n  getValue: (item: T) => Value = item => item as unknown as Value\n): Record<Key, Value> => {\n  return array.reduce((acc, item) => {\n    acc[getKey(item)] = getValue(item)\n    return acc\n  }, {} as Record<Key, Value>)\n}\n\n/**\n * Select performs a filter and a mapper inside of a reduce,\n * only iterating the list one time.\n *\n * @example\n * select([1, 2, 3, 4], x => x*x, x > 2) == [9, 16]\n */\nexport const select = <T, K>(\n  array: readonly T[],\n  mapper: (item: T, index: number) => K,\n  condition: (item: T, index: number) => boolean\n) => {\n  if (!array) return []\n  return array.reduce((acc, item, index) => {\n    if (!condition(item, index)) return acc\n    acc.push(mapper(item, index))\n    return acc\n  }, [] as K[])\n}\n\n/**\n * Max gets the greatest value from a list\n *\n * @example\n * max([ 2, 3, 5]) == 5\n * max([{ num: 1 }, { num: 2 }], x => x.num) == { num: 2 }\n */\nexport function max(array: readonly [number, ...number[]]): number\nexport function max(array: readonly number[]): number | null\nexport function max<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function max<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) > get(b) ? a : b))\n}\n\n/**\n * Min gets the smallest value from a list\n *\n * @example\n * min([1, 2, 3, 4]) == 1\n * min([{ num: 1 }, { num: 2 }], x => x.num) == { num: 1 }\n */\nexport function min(array: readonly [number, ...number[]]): number\nexport function min(array: readonly number[]): number | null\nexport function min<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function min<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) < get(b) ? a : b))\n}\n\n/**\n * Splits a single list into many lists of the desired size. If\n * given a list of 10 items and a size of 2, it will return 5\n * lists with 2 items each\n */\nexport const cluster = <T>(list: readonly T[], size: number = 2): T[][] => {\n  const clusterCount = Math.ceil(list.length / size)\n  return new Array(clusterCount).fill(null).map((_c: null, i: number) => {\n    return list.slice(i * size, i * size + size)\n  })\n}\n\n/**\n * Given a list of items returns a new list with only\n * unique items. Accepts an optional identity function\n * to convert each item in the list to a comparable identity\n * value\n */\nexport const unique = <T, K extends string | number | symbol>(\n  array: readonly T[],\n  toKey?: (item: T) => K\n): T[] => {\n  const valueMap = array.reduce((acc, item) => {\n    const key = toKey ? toKey(item) : (item as any as string | number | symbol)\n    if (acc[key]) return acc\n    acc[key] = item\n    return acc\n  }, {} as Record<string | number | symbol, T>)\n  return Object.values(valueMap)\n}\n\n/**\n * Creates a generator that will produce an iteration through\n * the range of number as requested.\n *\n * @example\n * range(3)                  // yields 0, 1, 2, 3\n * range(0, 3)               // yields 0, 1, 2, 3\n * range(0, 3, 'y')          // yields y, y, y, y\n * range(0, 3, () => 'y')    // yields y, y, y, y\n * range(0, 3, i => i)       // yields 0, 1, 2, 3\n * range(0, 3, i => `y${i}`) // yields y0, y1, y2, y3\n * range(0, 3, obj)          // yields obj, obj, obj, obj\n * range(0, 6, i => i, 2)    // yields 0, 2, 4, 6\n */\nexport function* range<T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper: T | ((i: number) => T) = i => i as T,\n  step: number = 1\n): Generator<T> {\n  const mapper = isFunction(valueOrMapper) ? valueOrMapper : () => valueOrMapper\n  const start = end ? startOrLength : 0\n  const final = end ?? startOrLength\n  for (let i = start; i <= final; i += step) {\n    yield mapper(i)\n    if (i + step > final) break\n  }\n}\n\n/**\n * Creates a list of given start, end, value, and\n * step parameters.\n *\n * @example\n * list(3)                  // 0, 1, 2, 3\n * list(0, 3)               // 0, 1, 2, 3\n * list(0, 3, 'y')          // y, y, y, y\n * list(0, 3, () => 'y')    // y, y, y, y\n * list(0, 3, i => i)       // 0, 1, 2, 3\n * list(0, 3, i => `y${i}`) // y0, y1, y2, y3\n * list(0, 3, obj)          // obj, obj, obj, obj\n * list(0, 6, i => i, 2)    // 0, 2, 4, 6\n */\nexport const list = <T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper?: T | ((i: number) => T),\n  step?: number\n): T[] => {\n  return Array.from(range(startOrLength, end, valueOrMapper, step))\n}\n\n/**\n * Given an array of arrays, returns a single\n * dimentional array with all items in it.\n */\nexport const flat = <T>(lists: readonly T[][]): T[] => {\n  return lists.reduce((acc, list) => {\n    acc.push(...list)\n    return acc\n  }, [])\n}\n\n/**\n * Given two arrays, returns true if any\n * elements intersect\n */\nexport const intersects = <T, K extends string | number | symbol>(\n  listA: readonly T[],\n  listB: readonly T[],\n  identity?: (t: T) => K\n): boolean => {\n  if (!listA || !listB) return false\n  const ident = identity ?? ((x: T) => x as unknown as K)\n  const dictB = listB.reduce((acc, item) => {\n    acc[ident(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return listA.some(value => dictB[ident(value)])\n}\n\n/**\n * Split an array into two array based on\n * a true/false condition function\n */\nexport const fork = <T>(\n  list: readonly T[],\n  condition: (item: T) => boolean\n): [T[], T[]] => {\n  if (!list) return [[], []]\n  return list.reduce(\n    (acc, item) => {\n      const [a, b] = acc\n      if (condition(item)) {\n        return [[...a, item], b]\n      } else {\n        return [a, [...b, item]]\n      }\n    },\n    [[], []] as [T[], T[]]\n  )\n}\n\n/**\n * Given two lists of the same type, iterate the first list\n * and replace items matched by the matcher func in the\n * first place.\n */\nexport const merge = <T>(\n  root: readonly T[],\n  others: readonly T[],\n  matcher: (item: T) => any\n) => {\n  if (!others && !root) return []\n  if (!others) return root\n  if (!root) return []\n  if (!matcher) return root\n  return root.reduce((acc, r) => {\n    const matched = others.find(o => matcher(r) === matcher(o))\n    if (matched) acc.push(matched)\n    else acc.push(r)\n    return acc\n  }, [] as T[])\n}\n\n/**\n * Replace an item in an array by a match function condition. If\n * no items match the function condition, appends the new item to\n * the end of the list.\n */\nexport const replaceOrAppend = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (a: T, idx: number) => boolean\n) => {\n  if (!list && !newItem) return []\n  if (!newItem) return [...list]\n  if (!list) return [newItem]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list, newItem]\n}\n\n/**\n * If the item matching the condition already exists\n * in the list it will be removed. If it does not it\n * will be added.\n */\nexport const toggle = <T>(\n  list: readonly T[],\n  item: T,\n  /**\n   * Converts an item of type T item into a value that\n   * can be checked for equality\n   */\n  toKey?: null | ((item: T, idx: number) => number | string | symbol),\n  options?: {\n    strategy?: 'prepend' | 'append'\n  }\n) => {\n  if (!list && !item) return []\n  if (!list) return [item]\n  if (!item) return [...list]\n  const matcher = toKey\n    ? (x: T, idx: number) => toKey(x, idx) === toKey(item, idx)\n    : (x: T) => x === item\n  const existing = list.find(matcher)\n  if (existing) return list.filter((x, idx) => !matcher(x, idx))\n  const strategy = options?.strategy ?? 'append'\n  if (strategy === 'append') return [...list, item]\n  return [item, ...list]\n}\n\ntype Falsy = null | undefined | false | '' | 0 | 0n\n\n/**\n * Given a list returns a new list with\n * only truthy values\n */\nexport const sift = <T>(list: readonly (T | Falsy)[]): T[] => {\n  return (list?.filter(x => !!x) as T[]) ?? []\n}\n\n/**\n * Like a reduce but does not require an array.\n * Only need a number and will iterate the function\n * as many times as specified.\n *\n * NOTE: This is NOT zero indexed. If you pass count=5\n * you will get 1, 2, 3, 4, 5 iteration in the callback\n * function\n */\nexport const iterate = <T>(\n  count: number,\n  func: (currentValue: T, iteration: number) => T,\n  initValue: T\n) => {\n  let value = initValue\n  for (let i = 1; i <= count; i++) {\n    value = func(value, i)\n  }\n  return value\n}\n\n/**\n * Returns all items from the first list that\n * do not exist in the second list.\n */\nexport const diff = <T>(\n  root: readonly T[],\n  other: readonly T[],\n  identity: (item: T) => string | number | symbol = (t: T) =>\n    t as unknown as string | number | symbol\n): T[] => {\n  if (!root?.length && !other?.length) return []\n  if (root?.length === undefined) return [...other]\n  if (!other?.length) return [...root]\n  const bKeys = other.reduce((acc, item) => {\n    acc[identity(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return root.filter(a => !bKeys[identity(a)])\n}\n\n/**\n * Shift array items by n steps\n * If n > 0 items will shift n steps to the right\n * If n < 0 items will shift n steps to the left\n */\nexport function shift<T>(arr: Array<T>, n: number) {\n  if (arr.length === 0) return arr\n\n  const shiftNumber = n % arr.length\n\n  if (shiftNumber === 0) return arr\n\n  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)]\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:11:35"}, {"role": "assistant", "content": "```ts\nimport { assert } from 'chai'\nimport * as _ from '..'\n\ndescribe('random module', () => {\n  describe('random function', () => {\n    test('returns a number', () => {\n      const result = _.random(0, 100)\n      assert.isAtLeast(result, 0)\n      assert.isAtMost(result, 100)\n    })\n  })\n\n  describe('uid function', () => {\n    test('generates the correct length string', () => {\n      const result = _.uid(10)\n      assert.equal(result.length, 10)\n    })\n    /**\n     * @warning This is potentially a flaky test.\n     * We're trying to assert that given additional\n     * special chars our function will include them\n     * in the random selection process to generate the\n     * uid. However, there is always a small chance that\n     * one is never selected. If the test is flaky, increase\n     * the size of the uid and/or the number of underscores\n     * in the special char addition.\n     */\n    test('uid generates string including special', () => {\n      const result = _.uid(\n        300,\n        '________________________________________________________________'\n      )\n      assert.include(result, '_')\n    })\n  })\n\n  describe('shuffle function', () => {\n    test('returns list with same number of items', () => {\n      const list = [1, 2, 3, 4, 5]\n      const result = _.shuffle(list)\n      assert.equal(list.length, result.length)\n    })\n    test('returns list with same value', () => {\n      const list = [1, 2, 3, 4, 5]\n      const totalBefore = _.sum(list)\n      const result = _.shuffle(list)\n      const totalAfter = _.sum(result)\n      assert.equal(totalBefore, totalAfter)\n    })\n    test('returns copy of list without mutatuing input', () => {\n      const list = [1, 2, 3, 4, 5]\n      const result = _.shuffle(list)\n      assert.notEqual(list, result)\n      assert.deepEqual(list, [1, 2, 3, 4, 5])\n    })\n  })\n\n  describe('draw function', () => {\n    test('returns a string from the list', () => {\n      const letters = 'abcde'\n      const result = _.draw(letters.split(''))\n      assert.include(letters, result!)\n    })\n    test('returns a item from the list', () => {\n      const list = [\n        { id: 'a', word: 'hello' },\n        { id: 'b', word: 'oh' },\n        { id: 'c', word: 'yolo' }\n      ]\n      const result = _.draw(list)\n      assert.include('abc', result!.id)\n    })\n    test('returns null given empty input', () => {\n      const list: unknown[] = []\n      const result = _.draw(list)\n      assert.isNull(result)\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: radash\nTest File Path: radash\\series.test.ts\\series.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { list } from './array'\n\n/**\n * Creates a series object around a list of values\n * that should be treated with order.\n */\nexport const series = <T>(\n  items: T[],\n  toKey: (item: T) => string | symbol = item => `${item}`\n) => {\n  const { indexesByKey, itemsByIndex } = items.reduce(\n    (acc, item, idx) => ({\n      indexesByKey: {\n        ...acc.indexesByKey,\n        [toKey(item)]: idx\n      },\n      itemsByIndex: {\n        ...acc.itemsByIndex,\n        [idx]: item\n      }\n    }),\n    {\n      indexesByKey: {} as Record<string | symbol, number>,\n      itemsByIndex: {} as Record<number, T>\n    }\n  )\n  /**\n   * Given two values in the series, returns the\n   * value that occurs earlier in the series\n   */\n  const min = (a: T, b: T): T => {\n    return indexesByKey[toKey(a)] < indexesByKey[toKey(b)] ? a : b\n  }\n  /**\n   * Given two values in the series, returns the\n   * value that occurs later in the series\n   */\n  const max = (a: T, b: T): T => {\n    return indexesByKey[toKey(a)] > indexesByKey[toKey(b)] ? a : b\n  }\n  /**\n   * Returns the first item from the series\n   */\n  const first = (): T => {\n    return itemsByIndex[0]\n  }\n  /**\n   * Returns the last item in the series\n   */\n  const last = (): T => {\n    return itemsByIndex[items.length - 1]\n  }\n  /**\n   * Given an item in the series returns the next item\n   * in the series or default if the given value is\n   * the last item in the series\n   */\n  const next = (current: T, defaultValue?: T): T => {\n    return (\n      itemsByIndex[indexesByKey[toKey(current)] + 1] ?? defaultValue ?? first()\n    )\n  }\n  /**\n   * Given an item in the series returns the previous item\n   * in the series or default if the given value is\n   * the first item in the series\n   */\n  const previous = (current: T, defaultValue?: T): T => {\n    return (\n      itemsByIndex[indexesByKey[toKey(current)] - 1] ?? defaultValue ?? last()\n    )\n  }\n  /**\n   * A more dynamic method than next and previous that\n   * lets you move many times in either direction.\n   * @example series(weekdays).spin('wednesday', 3) => 'monday'\n   * @example series(weekdays).spin('wednesday', -3) => 'friday'\n   */\n  const spin = (current: T, num: number): T => {\n    if (num === 0) return current\n    const abs = Math.abs(num)\n    const rel = abs > items.length ? abs % items.length : abs\n    return list(0, rel - 1).reduce(\n      acc => (num > 0 ? next(acc) : previous(acc)),\n      current\n    )\n  }\n  return {\n    min,\n    max,\n    first,\n    last,\n    next,\n    previous,\n    spin\n  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: array.ts\nimport { isArray, isFunction } from './typed'\n\n/**\n * Sorts an array of items into groups. The return value is a map where the keys are\n * the group ids the given getGroupId function produced and the value is an array of\n * each item in that group.\n */\nexport const group = <T, Key extends string | number | symbol>(\n  array: readonly T[],\n  getGroupId: (item: T) => Key\n): Partial<Record<Key, T[]>> => {\n  return array.reduce((acc, item) => {\n    const groupId = getGroupId(item)\n    if (!acc[groupId]) acc[groupId] = []\n    acc[groupId].push(item)\n    return acc\n  }, {} as Record<Key, T[]>)\n}\n\n/**\n * Creates an array of grouped elements, the first of which contains the\n * first elements of the given arrays, the second of which contains the\n * second elements of the given arrays, and so on.\n *\n * Ex. const zipped = zip(['a', 'b'], [1, 2], [true, false]) // [['a', 1, true], ['b', 2, false]]\n */\nexport function zip<T1, T2, T3, T4, T5>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[],\n  array5: T5[]\n): [T1, T2, T3, T4, T5][]\nexport function zip<T1, T2, T3, T4>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[]\n): [T1, T2, T3, T4][]\nexport function zip<T1, T2, T3>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[]\n): [T1, T2, T3][]\nexport function zip<T1, T2>(array1: T1[], array2: T2[]): [T1, T2][]\nexport function zip<T>(...arrays: T[][]): T[][] {\n  if (!arrays || !arrays.length) return []\n  return new Array(Math.max(...arrays.map(({ length }) => length)))\n    .fill([])\n    .map((_, idx) => arrays.map(array => array[idx]))\n}\n\n/**\n * Creates an object mapping the specified keys to their corresponding values\n *\n * Ex. const zipped = zipToObject(['a', 'b'], [1, 2]) // { a: 1, b: 2 }\n * Ex. const zipped = zipToObject(['a', 'b'], (k, i) => k + i) // { a: 'a0', b: 'b1' }\n * Ex. const zipped = zipToObject(['a', 'b'], 1) // { a: 1, b: 1 }\n */\nexport function zipToObject<K extends string | number | symbol, V>(\n  keys: K[],\n  values: V | ((key: K, idx: number) => V) | V[]\n): Record<K, V> {\n  if (!keys || !keys.length) {\n    return {} as Record<K, V>\n  }\n\n  const getValue = isFunction(values)\n    ? values\n    : isArray(values)\n    ? (_k: K, i: number) => values[i]\n    : (_k: K, _i: number) => values\n\n  return keys.reduce((acc, key, idx) => {\n    acc[key] = getValue(key, idx)\n    return acc\n  }, {} as Record<K, V>)\n}\n\n/**\n * Go through a list of items, starting with the first item,\n * and comparing with the second. Keep the one you want then\n * compare that to the next item in the list with the same\n *\n * Ex. const greatest = () => boil(numbers, (a, b) => a > b)\n */\nexport const boil = <T>(\n  array: readonly T[],\n  compareFunc: (a: T, b: T) => T\n) => {\n  if (!array || (array.length ?? 0) === 0) return null\n  return array.reduce(compareFunc)\n}\n\n/**\n * Sum all numbers in an array. Optionally provide a function\n * to convert objects in the array to number values.\n */\nexport function sum<T extends number>(array: readonly T[]): number\nexport function sum<T extends object>(\n  array: readonly T[],\n  fn: (item: T) => number\n): number\nexport function sum<T extends object | number>(\n  array: readonly any[],\n  fn?: (item: T) => number\n): number {\n  return (array || []).reduce((acc, item) => acc + (fn ? fn(item) : item), 0)\n}\n\n/**\n * Get the first item in an array or a default value\n */\nexport const first = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[0] : defaultValue\n}\n\n/**\n * Get the last item in an array or a default value\n */\nexport const last = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[array.length - 1] : defaultValue\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value\n */\nexport const sort = <T>(\n  array: readonly T[],\n  getter: (item: T) => number,\n  desc = false\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => getter(a) - getter(b)\n  const dsc = (a: T, b: T) => getter(b) - getter(a)\n  return array.slice().sort(desc === true ? dsc : asc)\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value. Allows for a string\n * sorting value.\n */\nexport const alphabetical = <T>(\n  array: readonly T[],\n  getter: (item: T) => string,\n  dir: 'asc' | 'desc' = 'asc'\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => `${getter(a)}`.localeCompare(getter(b))\n  const dsc = (a: T, b: T) => `${getter(b)}`.localeCompare(getter(a))\n  return array.slice().sort(dir === 'desc' ? dsc : asc)\n}\n\nexport const counting = <T, TId extends string | number | symbol>(\n  list: readonly T[],\n  identity: (item: T) => TId\n): Record<TId, number> => {\n  if (!list) return {} as Record<TId, number>\n  return list.reduce((acc, item) => {\n    const id = identity(item)\n    acc[id] = (acc[id] ?? 0) + 1\n    return acc\n  }, {} as Record<TId, number>)\n}\n\n/**\n * Replace an element in an array with a new\n * item without modifying the array and return\n * the new value\n */\nexport const replace = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (item: T, idx: number) => boolean\n): T[] => {\n  if (!list) return []\n  if (newItem === undefined) return [...list]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list]\n}\n\n/**\n * Convert an array to a dictionary by mapping each item\n * into a dictionary key & value\n */\nexport const objectify = <T, Key extends string | number | symbol, Value = T>(\n  array: readonly T[],\n  getKey: (item: T) => Key,\n  getValue: (item: T) => Value = item => item as unknown as Value\n): Record<Key, Value> => {\n  return array.reduce((acc, item) => {\n    acc[getKey(item)] = getValue(item)\n    return acc\n  }, {} as Record<Key, Value>)\n}\n\n/**\n * Select performs a filter and a mapper inside of a reduce,\n * only iterating the list one time.\n *\n * @example\n * select([1, 2, 3, 4], x => x*x, x > 2) == [9, 16]\n */\nexport const select = <T, K>(\n  array: readonly T[],\n  mapper: (item: T, index: number) => K,\n  condition: (item: T, index: number) => boolean\n) => {\n  if (!array) return []\n  return array.reduce((acc, item, index) => {\n    if (!condition(item, index)) return acc\n    acc.push(mapper(item, index))\n    return acc\n  }, [] as K[])\n}\n\n/**\n * Max gets the greatest value from a list\n *\n * @example\n * max([ 2, 3, 5]) == 5\n * max([{ num: 1 }, { num: 2 }], x => x.num) == { num: 2 }\n */\nexport function max(array: readonly [number, ...number[]]): number\nexport function max(array: readonly number[]): number | null\nexport function max<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function max<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) > get(b) ? a : b))\n}\n\n/**\n * Min gets the smallest value from a list\n *\n * @example\n * min([1, 2, 3, 4]) == 1\n * min([{ num: 1 }, { num: 2 }], x => x.num) == { num: 1 }\n */\nexport function min(array: readonly [number, ...number[]]): number\nexport function min(array: readonly number[]): number | null\nexport function min<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function min<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) < get(b) ? a : b))\n}\n\n/**\n * Splits a single list into many lists of the desired size. If\n * given a list of 10 items and a size of 2, it will return 5\n * lists with 2 items each\n */\nexport const cluster = <T>(list: readonly T[], size: number = 2): T[][] => {\n  const clusterCount = Math.ceil(list.length / size)\n  return new Array(clusterCount).fill(null).map((_c: null, i: number) => {\n    return list.slice(i * size, i * size + size)\n  })\n}\n\n/**\n * Given a list of items returns a new list with only\n * unique items. Accepts an optional identity function\n * to convert each item in the list to a comparable identity\n * value\n */\nexport const unique = <T, K extends string | number | symbol>(\n  array: readonly T[],\n  toKey?: (item: T) => K\n): T[] => {\n  const valueMap = array.reduce((acc, item) => {\n    const key = toKey ? toKey(item) : (item as any as string | number | symbol)\n    if (acc[key]) return acc\n    acc[key] = item\n    return acc\n  }, {} as Record<string | number | symbol, T>)\n  return Object.values(valueMap)\n}\n\n/**\n * Creates a generator that will produce an iteration through\n * the range of number as requested.\n *\n * @example\n * range(3)                  // yields 0, 1, 2, 3\n * range(0, 3)               // yields 0, 1, 2, 3\n * range(0, 3, 'y')          // yields y, y, y, y\n * range(0, 3, () => 'y')    // yields y, y, y, y\n * range(0, 3, i => i)       // yields 0, 1, 2, 3\n * range(0, 3, i => `y${i}`) // yields y0, y1, y2, y3\n * range(0, 3, obj)          // yields obj, obj, obj, obj\n * range(0, 6, i => i, 2)    // yields 0, 2, 4, 6\n */\nexport function* range<T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper: T | ((i: number) => T) = i => i as T,\n  step: number = 1\n): Generator<T> {\n  const mapper = isFunction(valueOrMapper) ? valueOrMapper : () => valueOrMapper\n  const start = end ? startOrLength : 0\n  const final = end ?? startOrLength\n  for (let i = start; i <= final; i += step) {\n    yield mapper(i)\n    if (i + step > final) break\n  }\n}\n\n/**\n * Creates a list of given start, end, value, and\n * step parameters.\n *\n * @example\n * list(3)                  // 0, 1, 2, 3\n * list(0, 3)               // 0, 1, 2, 3\n * list(0, 3, 'y')          // y, y, y, y\n * list(0, 3, () => 'y')    // y, y, y, y\n * list(0, 3, i => i)       // 0, 1, 2, 3\n * list(0, 3, i => `y${i}`) // y0, y1, y2, y3\n * list(0, 3, obj)          // obj, obj, obj, obj\n * list(0, 6, i => i, 2)    // 0, 2, 4, 6\n */\nexport const list = <T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper?: T | ((i: number) => T),\n  step?: number\n): T[] => {\n  return Array.from(range(startOrLength, end, valueOrMapper, step))\n}\n\n/**\n * Given an array of arrays, returns a single\n * dimentional array with all items in it.\n */\nexport const flat = <T>(lists: readonly T[][]): T[] => {\n  return lists.reduce((acc, list) => {\n    acc.push(...list)\n    return acc\n  }, [])\n}\n\n/**\n * Given two arrays, returns true if any\n * elements intersect\n */\nexport const intersects = <T, K extends string | number | symbol>(\n  listA: readonly T[],\n  listB: readonly T[],\n  identity?: (t: T) => K\n): boolean => {\n  if (!listA || !listB) return false\n  const ident = identity ?? ((x: T) => x as unknown as K)\n  const dictB = listB.reduce((acc, item) => {\n    acc[ident(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return listA.some(value => dictB[ident(value)])\n}\n\n/**\n * Split an array into two array based on\n * a true/false condition function\n */\nexport const fork = <T>(\n  list: readonly T[],\n  condition: (item: T) => boolean\n): [T[], T[]] => {\n  if (!list) return [[], []]\n  return list.reduce(\n    (acc, item) => {\n      const [a, b] = acc\n      if (condition(item)) {\n        return [[...a, item], b]\n      } else {\n        return [a, [...b, item]]\n      }\n    },\n    [[], []] as [T[], T[]]\n  )\n}\n\n/**\n * Given two lists of the same type, iterate the first list\n * and replace items matched by the matcher func in the\n * first place.\n */\nexport const merge = <T>(\n  root: readonly T[],\n  others: readonly T[],\n  matcher: (item: T) => any\n) => {\n  if (!others && !root) return []\n  if (!others) return root\n  if (!root) return []\n  if (!matcher) return root\n  return root.reduce((acc, r) => {\n    const matched = others.find(o => matcher(r) === matcher(o))\n    if (matched) acc.push(matched)\n    else acc.push(r)\n    return acc\n  }, [] as T[])\n}\n\n/**\n * Replace an item in an array by a match function condition. If\n * no items match the function condition, appends the new item to\n * the end of the list.\n */\nexport const replaceOrAppend = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (a: T, idx: number) => boolean\n) => {\n  if (!list && !newItem) return []\n  if (!newItem) return [...list]\n  if (!list) return [newItem]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list, newItem]\n}\n\n/**\n * If the item matching the condition already exists\n * in the list it will be removed. If it does not it\n * will be added.\n */\nexport const toggle = <T>(\n  list: readonly T[],\n  item: T,\n  /**\n   * Converts an item of type T item into a value that\n   * can be checked for equality\n   */\n  toKey?: null | ((item: T, idx: number) => number | string | symbol),\n  options?: {\n    strategy?: 'prepend' | 'append'\n  }\n) => {\n  if (!list && !item) return []\n  if (!list) return [item]\n  if (!item) return [...list]\n  const matcher = toKey\n    ? (x: T, idx: number) => toKey(x, idx) === toKey(item, idx)\n    : (x: T) => x === item\n  const existing = list.find(matcher)\n  if (existing) return list.filter((x, idx) => !matcher(x, idx))\n  const strategy = options?.strategy ?? 'append'\n  if (strategy === 'append') return [...list, item]\n  return [item, ...list]\n}\n\ntype Falsy = null | undefined | false | '' | 0 | 0n\n\n/**\n * Given a list returns a new list with\n * only truthy values\n */\nexport const sift = <T>(list: readonly (T | Falsy)[]): T[] => {\n  return (list?.filter(x => !!x) as T[]) ?? []\n}\n\n/**\n * Like a reduce but does not require an array.\n * Only need a number and will iterate the function\n * as many times as specified.\n *\n * NOTE: This is NOT zero indexed. If you pass count=5\n * you will get 1, 2, 3, 4, 5 iteration in the callback\n * function\n */\nexport const iterate = <T>(\n  count: number,\n  func: (currentValue: T, iteration: number) => T,\n  initValue: T\n) => {\n  let value = initValue\n  for (let i = 1; i <= count; i++) {\n    value = func(value, i)\n  }\n  return value\n}\n\n/**\n * Returns all items from the first list that\n * do not exist in the second list.\n */\nexport const diff = <T>(\n  root: readonly T[],\n  other: readonly T[],\n  identity: (item: T) => string | number | symbol = (t: T) =>\n    t as unknown as string | number | symbol\n): T[] => {\n  if (!root?.length && !other?.length) return []\n  if (root?.length === undefined) return [...other]\n  if (!other?.length) return [...root]\n  const bKeys = other.reduce((acc, item) => {\n    acc[identity(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return root.filter(a => !bKeys[identity(a)])\n}\n\n/**\n * Shift array items by n steps\n * If n > 0 items will shift n steps to the right\n * If n < 0 items will shift n steps to the left\n */\nexport function shift<T>(arr: Array<T>, n: number) {\n  if (arr.length === 0) return arr\n\n  const shiftNumber = n % arr.length\n\n  if (shiftNumber === 0) return arr\n\n  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)]\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:11:35"}, {"role": "assistant", "content": "```ts\nimport { assert } from 'chai'\nimport * as _ from '..'\n\ndescribe('series module', () => {\n  type Weekday = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday'\n  const sut = _.series<Weekday>([\n    'monday',\n    'tuesday',\n    'wednesday',\n    'thursday',\n    'friday'\n  ])\n\n  describe('min function', () => {\n    test('correctly returns min', () => {\n      const result = sut.min('monday', 'tuesday')\n      assert.equal(result, 'monday')\n    })\n    test('correctly returns min when second arg', () => {\n      const result = sut.min('tuesday', 'monday')\n      assert.equal(result, 'monday')\n    })\n  })\n\n  describe('max function', () => {\n    test('correctly returns max', () => {\n      const result = sut.max('thursday', 'tuesday')\n      assert.equal(result, 'thursday')\n    })\n    test('correctly returns max when second arg', () => {\n      const result = sut.max('tuesday', 'thursday')\n      assert.equal(result, 'thursday')\n    })\n  })\n\n  describe('first function', () => {\n    test('returns first item', () => {\n      const result = sut.first()\n      assert.equal(result, 'monday')\n    })\n  })\n\n  describe('last function', () => {\n    test('returns last item', () => {\n      const result = sut.last()\n      assert.equal(result, 'friday')\n    })\n  })\n\n  describe('next function', () => {\n    test('returns next item', () => {\n      const result = sut.next('wednesday')\n      assert.equal(result, 'thursday')\n    })\n    test('returns first given last exhausted', () => {\n      const result = sut.next('friday')\n      assert.equal(result, 'monday')\n    })\n    test('returns the given default when the last is exhausted', () => {\n      const result = sut.next('friday', 'wednesday')\n      assert.equal(result, 'wednesday')\n    })\n  })\n\n  describe('previous function', () => {\n    test('returns previous item', () => {\n      const result = sut.previous('wednesday')\n      assert.equal(result, 'tuesday')\n    })\n    test('returns last given first exhausted', () => {\n      const result = sut.previous('monday')\n      assert.equal(result, 'friday')\n    })\n    test('returns the given default when the first is exhausted', () => {\n      const result = sut.previous('monday', 'wednesday')\n      assert.equal(result, 'wednesday')\n    })\n  })\n\n  describe('spin function', () => {\n    test('returns current given zero', () => {\n      const result = sut.spin('wednesday', 0)\n      assert.equal(result, 'wednesday')\n    })\n    test('returns friday given -3 starting at wednesday', () => {\n      const result = sut.spin('wednesday', -3)\n      assert.equal(result, 'friday')\n    })\n    test('returns monday given 3 starting at wednesday', () => {\n      const result = sut.spin('wednesday', 3)\n      assert.equal(result, 'monday')\n    })\n    test('returns monday given 13 starting at wednesday', () => {\n      const result = sut.spin('wednesday', 13)\n      assert.equal(result, 'monday')\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: radash\nTest File Path: radash\\string.test.ts\\string.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\n/**\n * Capitalize the first word of the string\n *\n * capitalize('hello')   -> 'Hello'\n * capitalize('va va voom') -> 'Va va voom'\n */\nexport const capitalize = (str: string): string => {\n  if (!str || str.length === 0) return ''\n  const lower = str.toLowerCase()\n  return lower.substring(0, 1).toUpperCase() + lower.substring(1, lower.length)\n}\n\n/**\n * Formats the given string in camel case fashion\n *\n * camel('hello world')   -> 'helloWorld'\n * camel('va va-VOOM') -> 'vaVaVoom'\n * camel('helloWorld') -> 'helloWorld'\n */\nexport const camel = (str: string): string => {\n  const parts =\n    str\n      ?.replace(/([A-Z])+/g, capitalize)\n      ?.split(/(?=[A-Z])|[\\.\\-\\s_]/)\n      .map(x => x.toLowerCase()) ?? []\n  if (parts.length === 0) return ''\n  if (parts.length === 1) return parts[0]\n  return parts.reduce((acc, part) => {\n    return `${acc}${part.charAt(0).toUpperCase()}${part.slice(1)}`\n  })\n}\n\n/**\n * Formats the given string in snake case fashion\n *\n * snake('hello world')   -> 'hello_world'\n * snake('va va-VOOM') -> 'va_va_voom'\n * snake('helloWord') -> 'hello_world'\n */\nexport const snake = (\n  str: string,\n  options?: {\n    splitOnNumber?: boolean\n  }\n): string => {\n  const parts =\n    str\n      ?.replace(/([A-Z])+/g, capitalize)\n      .split(/(?=[A-Z])|[\\.\\-\\s_]/)\n      .map(x => x.toLowerCase()) ?? []\n  if (parts.length === 0) return ''\n  if (parts.length === 1) return parts[0]\n  const result = parts.reduce((acc, part) => {\n    return `${acc}_${part.toLowerCase()}`\n  })\n  return options?.splitOnNumber === false\n    ? result\n    : result.replace(/([A-Za-z]{1}[0-9]{1})/, val => `${val[0]!}_${val[1]!}`)\n}\n\n/**\n * Formats the given string in dash case fashion\n *\n * dash('hello world')   -> 'hello-world'\n * dash('va va_VOOM') -> 'va-va-voom'\n * dash('helloWord') -> 'hello-word'\n */\nexport const dash = (str: string): string => {\n  const parts =\n    str\n      ?.replace(/([A-Z])+/g, capitalize)\n      ?.split(/(?=[A-Z])|[\\.\\-\\s_]/)\n      .map(x => x.toLowerCase()) ?? []\n  if (parts.length === 0) return ''\n  if (parts.length === 1) return parts[0]\n  return parts.reduce((acc, part) => {\n    return `${acc}-${part.toLowerCase()}`\n  })\n}\n\n/**\n * Formats the given string in pascal case fashion\n *\n * pascal('hello world') -> 'HelloWorld'\n * pascal('va va boom') -> 'VaVaBoom'\n */\nexport const pascal = (str: string): string => {\n  const parts = str?.split(/[\\.\\-\\s_]/).map(x => x.toLowerCase()) ?? []\n  if (parts.length === 0) return ''\n  return parts.map(str => str.charAt(0).toUpperCase() + str.slice(1)).join('')\n}\n\n/**\n * Formats the given string in title case fashion\n *\n * title('hello world') -> 'Hello World'\n * title('va_va_boom') -> 'Va Va Boom'\n * title('root-hook') -> 'Root Hook'\n * title('queryItems') -> 'Query Items'\n */\nexport const title = (str: string | null | undefined): string => {\n  if (!str) return ''\n  return str\n    .split(/(?=[A-Z])|[\\.\\-\\s_]/)\n    .map(s => s.trim())\n    .filter(s => !!s)\n    .map(s => capitalize(s.toLowerCase()))\n    .join(' ')\n}\n\n/**\n * template is used to replace data by name in template strings.\n * The default expression looks for {{name}} to identify names.\n *\n * Ex. template('Hello, {{name}}', { name: 'ray' })\n * Ex. template('Hello, <name>', { name: 'ray' }, /<(.+?)>/g)\n */\nexport const template = (\n  str: string,\n  data: Record<string, any>,\n  regex = /\\{\\{(.+?)\\}\\}/g\n) => {\n  return Array.from(str.matchAll(regex)).reduce((acc, match) => {\n    return acc.replace(match[0], data[match[1]])\n  }, str)\n}\n\n/**\n * Trims all prefix and suffix characters from the given\n * string. Like the builtin trim function but accepts\n * other characters you would like to trim and trims\n * multiple characters.\n *\n * ```typescript\n * trim('  hello ') // => 'hello'\n * trim('__hello__', '_') // => 'hello'\n * trim('/repos/:owner/:repo/', '/') // => 'repos/:owner/:repo'\n * trim('222222__hello__1111111', '12_') // => 'hello'\n * ```\n */\nexport const trim = (\n  str: string | null | undefined,\n  charsToTrim: string = ' '\n) => {\n  if (!str) return ''\n  const toTrim = charsToTrim.replace(/[\\W]{1}/g, '\\\\$&')\n  const regex = new RegExp(`^[${toTrim}]+|[${toTrim}]+$`, 'g')\n  return str.replace(regex, '')\n}\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:11:35"}, {"role": "assistant", "content": "```ts\nimport { assert } from 'chai'\nimport * as _ from '..'\n\ndescribe('string module', () => {\n  describe('camel function', () => {\n    test('returns correctly cased string', () => {\n      const result = _.camel('hello world')\n      assert.equal(result, 'helloWorld')\n    })\n    test('returns single word', () => {\n      const result = _.camel('hello')\n      assert.equal(result, 'hello')\n    })\n    test('returns empty string for empty input', () => {\n      const result = _.camel(null as any)\n      assert.equal(result, '')\n    })\n    test('a word in camel case should remain in camel case', () => {\n      const result = _.camel('helloWorld')\n      assert.equal(result, 'helloWorld')\n    })\n  })\n\n  describe('camelCase function', () => {\n    test('returns non alphanumerics with -space and capital', () => {\n      const result = _.camel('Exobase Starter_flash AND-go')\n      assert.equal(result, 'exobaseStarterFlashAndGo')\n    })\n  })\n\n  describe('snake function', () => {\n    test('returns correctly cased string', () => {\n      const result = _.snake('hello world')\n      assert.equal(result, 'hello_world')\n    })\n    test('must handle strings that are camelCase', () => {\n      const result = _.snake('helloWorld')\n      assert.equal(result, 'hello_world')\n    })\n    test('must handle strings that are dash', () => {\n      const result = _.snake('hello-world')\n      assert.equal(result, 'hello_world')\n    })\n    test('splits numbers that are next to letters', () => {\n      const result = _.snake('hello-world12_19-bye')\n      assert.equal(result, 'hello_world_12_19_bye')\n    })\n    test('does not split numbers when flag is set to false', () => {\n      const result = _.snake('hello-world12_19-bye', {\n        splitOnNumber: false\n      })\n      assert.equal(result, 'hello_world12_19_bye')\n    })\n    test('returns single word', () => {\n      const result = _.snake('hello')\n      assert.equal(result, 'hello')\n    })\n    test('returns empty string for empty input', () => {\n      const result = _.snake(null as any)\n      assert.equal(result, '')\n    })\n  })\n\n  describe('snakeCase function', () => {\n    test('returns non alphanumerics with _', () => {\n      const result = _.snake('Exobase Starter_flash AND-go')\n      assert.equal(result, 'exobase_starter_flash_and_go')\n    })\n  })\n\n  describe('dash function', () => {\n    test('returns correctly cased string', () => {\n      const result = _.dash('hello world')\n      assert.equal(result, 'hello-world')\n    })\n    test('returns single word', () => {\n      const result = _.dash('hello')\n      assert.equal(result, 'hello')\n    })\n    test('returns empty string for empty input', () => {\n      const result = _.dash(null as any)\n      assert.equal(result, '')\n    })\n    test('must handle strings that are camelCase', () => {\n      const result = _.dash('helloWorld')\n      assert.equal(result, 'hello-world')\n    })\n    test('must handle strings that are dash', () => {\n      const result = _.dash('hello-world')\n      assert.equal(result, 'hello-world')\n    })\n  })\n\n  describe('dashCase function', () => {\n    test('returns non alphanumerics with -', () => {\n      const result = _.dash('Exobase Starter_flash AND-go')\n      assert.equal(result, 'exobase-starter-flash-and-go')\n    })\n  })\n\n  describe('template function', () => {\n    test('replaces all occurrences', () => {\n      const tmp = `\n    Hello my name is {{name}}. I am a {{type}}.\n    Not sure why I am {{reason}}.\n\n    Thank You - {{name}}\n  `\n      const data = {\n        name: 'Ray',\n        type: 'template',\n        reason: 'so beautiful'\n      }\n\n      const result = _.template(tmp, data)\n      const expected = `\n    Hello my name is ${data.name}. I am a ${data.type}.\n    Not sure why I am ${data.reason}.\n\n    Thank You - ${data.name}\n  `\n\n      assert.equal(result, expected)\n    })\n\n    test('replaces all occurrences given template', () => {\n      const tmp = `Hello <name>.`\n      const data = {\n        name: 'Ray'\n      }\n\n      const result = _.template(tmp, data, /<(.+?)>/g)\n      assert.equal(result, `Hello ${data.name}.`)\n    })\n  })\n\n  describe('capitalize function', () => {\n    test('handles null', () => {\n      const result = _.capitalize(null as any)\n      assert.equal(result, '')\n    })\n    test('converts hello as Hello', () => {\n      const result = _.capitalize('hello')\n      assert.equal(result, 'Hello')\n    })\n    test('converts hello Bob as Hello bob', () => {\n      const result = _.capitalize('hello Bob')\n      assert.equal(result, 'Hello bob')\n    })\n  })\n\n  describe('pascal function', () => {\n    test('returns non alphanumerics in pascal', () => {\n      const result = _.pascal('Exobase Starter_flash AND-go')\n      assert.equal(result, 'ExobaseStarterFlashAndGo')\n    })\n    test('returns single word', () => {\n      const result = _.pascal('hello')\n      assert.equal(result, 'Hello')\n    })\n    test('returns empty string for empty input', () => {\n      const result = _.pascal(null as any)\n      assert.equal(result, '')\n    })\n  })\n\n  describe('title function', () => {\n    test('returns input formatted in title case', () => {\n      assert.equal(_.title('hello world'), 'Hello World')\n      assert.equal(_.title('va_va_boom'), 'Va Va Boom')\n      assert.equal(_.title('root-hook   -  ok!'), 'Root Hook Ok!')\n      assert.equal(_.title('queryItems'), 'Query Items')\n      assert.equal(\n        _.title('queryAllItems-in_Database'),\n        'Query All Items In Database'\n      )\n    })\n    test('returns empty string for bad input', () => {\n      assert.equal(_.title(null), '')\n      assert.equal(_.title(undefined), '')\n    })\n  })\n\n  describe('trim function', () => {\n    test('handles bad input', () => {\n      assert.equal(_.trim(null), '')\n      assert.equal(_.trim(undefined), '')\n    })\n    test('returns input string correctly trimmed', () => {\n      assert.equal(_.trim('\\n\\n\\t\\nhello\\n\\t  \\n', '\\n\\t '), 'hello')\n      assert.equal(_.trim('hello', 'x'), 'hello')\n      assert.equal(_.trim(' hello  '), 'hello')\n      assert.equal(_.trim(' __hello__  ', '_'), ' __hello__  ')\n      assert.equal(_.trim('__hello__', '_'), 'hello')\n      assert.equal(_.trim('//repos////', '/'), 'repos')\n      assert.equal(_.trim('/repos/:owner/:repo/', '/'), 'repos/:owner/:repo')\n    })\n\n    test('handles when char to trim is special case in regex', () => {\n      assert.equal(_.trim('_- hello_- ', '_- '), 'hello')\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: radash\nTest File Path: radash\\typed.test.ts\\typed.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nexport const isSymbol = (value: any): value is symbol => {\n  return !!value && value.constructor === Symbol\n}\n\nexport const isArray = Array.isArray\n\nexport const isObject = (value: any): value is object => {\n  return !!value && value.constructor === Object\n}\n\n/**\n * Checks if the given value is primitive.\n *\n * Primitive Types: number , string , boolean , symbol, bigint, undefined, null\n *\n * @param {*} value value to check\n * @returns {boolean} result\n */\nexport const isPrimitive = (value: any): boolean => {\n  return (\n    value === undefined ||\n    value === null ||\n    (typeof value !== 'object' && typeof value !== 'function')\n  )\n}\n\nexport const isFunction = (value: any): value is Function => {\n  return !!(value && value.constructor && value.call && value.apply)\n}\n\nexport const isString = (value: any): value is string => {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport const isInt = (value: any): value is number => {\n  return isNumber(value) && value % 1 === 0\n}\n\nexport const isFloat = (value: any): value is number => {\n  return isNumber(value) && value % 1 !== 0\n}\n\nexport const isNumber = (value: any): value is number => {\n  try {\n    return Number(value) === value\n  } catch {\n    return false\n  }\n}\n\nexport const isDate = (value: any): value is Date => {\n  return Object.prototype.toString.call(value) === '[object Date]'\n}\n\n/**\n * This is really a _best guess_ promise checking. You\n * should probably use Promise.resolve(value) to be 100%\n * sure you're handling it correctly.\n */\nexport const isPromise = (value: any): value is Promise<any> => {\n  if (!value) return false\n  if (!value.then) return false\n  if (!isFunction(value.then)) return false\n  return true\n}\n\nexport const isEmpty = (value: any) => {\n  if (value === true || value === false) return true\n  if (value === null || value === undefined) return true\n  if (isNumber(value)) return value === 0\n  if (isDate(value)) return isNaN(value.getTime())\n  if (isFunction(value)) return false\n  if (isSymbol(value)) return false\n  const length = (value as any).length\n  if (isNumber(length)) return length === 0\n  const size = (value as any).size\n  if (isNumber(size)) return size === 0\n  const keys = Object.keys(value).length\n  return keys === 0\n}\n\nexport const isEqual = <TType>(x: TType, y: TType): boolean => {\n  if (Object.is(x, y)) return true\n  if (x instanceof Date && y instanceof Date) {\n    return x.getTime() === y.getTime()\n  }\n  if (x instanceof RegExp && y instanceof RegExp) {\n    return x.toString() === y.toString()\n  }\n  if (\n    typeof x !== 'object' ||\n    x === null ||\n    typeof y !== 'object' ||\n    y === null\n  ) {\n    return false\n  }\n  const keysX = Reflect.ownKeys(x as unknown as object) as (keyof typeof x)[]\n  const keysY = Reflect.ownKeys(y as unknown as object)\n  if (keysX.length !== keysY.length) return false\n  for (let i = 0; i < keysX.length; i++) {\n    if (!Reflect.has(y as unknown as object, keysX[i])) return false\n    if (!isEqual(x[keysX[i]], y[keysX[i]])) return false\n  }\n  return true\n}\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:11:35"}, {"role": "assistant", "content": "```ts\nimport { assert } from 'chai'\nimport * as _ from '..'\n\ndescribe('typed module', () => {\n  describe('isArray function', () => {\n    test('returns false for null', () => {\n      const result = _.isArray(null)\n      assert.isFalse(result)\n    })\n    test('returns false for undefined', () => {\n      const result = _.isArray(undefined)\n      assert.isFalse(result)\n    })\n    test('returns false for boolean', () => {\n      const result = _.isArray(false)\n      assert.isFalse(result)\n    })\n    test('returns false for object', () => {\n      const result = _.isArray({})\n      assert.isFalse(result)\n    })\n    test('returns false for class instance', () => {\n      class Data {}\n      const result = _.isArray(new Data())\n      assert.isFalse(result)\n    })\n    test('returns false for number', () => {\n      const result = _.isArray(22)\n      assert.isFalse(result)\n    })\n    test('returns false for string', () => {\n      const result = _.isArray('abc')\n      assert.isFalse(result)\n    })\n    test('returns true for array', () => {\n      const result = _.isArray([1, 2, 3])\n      assert.isTrue(result)\n    })\n    test('returns true for empty array', () => {\n      const result = _.isArray([])\n      assert.isTrue(result)\n    })\n  })\n\n  describe('isObject function', () => {\n    test('returns false for null', () => {\n      const result = _.isObject(null)\n      assert.isFalse(result)\n    })\n    test('returns false for undefined', () => {\n      const result = _.isObject(undefined)\n      assert.isFalse(result)\n    })\n    test('returns false for boolean', () => {\n      const result = _.isObject(false)\n      assert.isFalse(result)\n    })\n    test('returns false for class instance', () => {\n      class Data {}\n      const result = _.isObject(new Data())\n      assert.isFalse(result)\n    })\n    test('returns false for number', () => {\n      const result = _.isObject(22)\n      assert.isFalse(result)\n    })\n    test('returns false for string', () => {\n      const result = _.isObject('abc')\n      assert.isFalse(result)\n    })\n    test('returns false for array', () => {\n      const result = _.isObject([1, 2, 3])\n      assert.isFalse(result)\n    })\n    test('returns true for object', () => {\n      const result = _.isObject({})\n      assert.isTrue(result)\n    })\n  })\n\n  describe('isPrimitive function', () => {\n    test('returns true for all the primitives', () => {\n      const arr = [\n        1.1,\n        'How you doin?',\n        false,\n        Symbol('key'),\n        BigInt('1'),\n        undefined,\n        null\n      ]\n\n      for (const elm of arr) {\n        assert.isTrue(_.isPrimitive(elm))\n      }\n    }),\n      test('returns false for non-primitives', () => {\n        const arr = [new Date(), Number, {}, Object({}), () => 0, [1, 2]]\n\n        for (const elm of arr) {\n          assert.isFalse(_.isPrimitive(elm))\n        }\n      })\n  })\n\n  describe('isFunction function', () => {\n    test('returns false for null', () => {\n      const result = _.isFunction(null)\n      assert.isFalse(result)\n    })\n    test('returns false for undefined', () => {\n      const result = _.isFunction(undefined)\n      assert.isFalse(result)\n    })\n    test('returns false for boolean', () => {\n      const result = _.isFunction(false)\n      assert.isFalse(result)\n    })\n    test('returns false for class instance', () => {\n      class Data {}\n      const result = _.isFunction(new Data())\n      assert.isFalse(result)\n    })\n    test('returns false for number', () => {\n      const result = _.isFunction(22)\n      assert.isFalse(result)\n    })\n    test('returns false for string', () => {\n      const result = _.isFunction('abc')\n      assert.isFalse(result)\n    })\n    test('returns false for array', () => {\n      const result = _.isFunction([1, 2, 3])\n      assert.isFalse(result)\n    })\n    test('returns false for object', () => {\n      const result = _.isFunction({})\n      assert.isFalse(result)\n    })\n    test('returns true for anonymous function', () => {\n      const result = _.isFunction(function () {\n        return 'hello'\n      })\n      assert.isTrue(result)\n    })\n    test('returns true for arrow function', () => {\n      const result = _.isFunction(() => {\n        return 'hello'\n      })\n      assert.isTrue(result)\n    })\n    test('returns true for named function', () => {\n      function sayHello() {\n        return 'hello'\n      }\n      const result = _.isFunction(sayHello)\n      assert.isTrue(result)\n    })\n  })\n\n  describe('isString function', () => {\n    test('returns false for null', () => {\n      const result = _.isString(null)\n      assert.isFalse(result)\n    })\n    test('returns false for undefined', () => {\n      const result = _.isString(undefined)\n      assert.isFalse(result)\n    })\n    test('returns false for boolean', () => {\n      const result = _.isString(false)\n      assert.isFalse(result)\n    })\n    test('returns false for class instance', () => {\n      class Data {}\n      const result = _.isString(new Data())\n      assert.isFalse(result)\n    })\n    test('returns false for number', () => {\n      const result = _.isString(22)\n      assert.isFalse(result)\n    })\n    test('returns false for array', () => {\n      const result = _.isString([1, 2, 3])\n      assert.isFalse(result)\n    })\n    test('returns false for object', () => {\n      const result = _.isString({})\n      assert.isFalse(result)\n    })\n    test('returns true for string', () => {\n      const result = _.isString('abc')\n      assert.isTrue(result)\n    })\n    test('returns true for string class', () => {\n      const result = _.isString(String('abc'))\n      assert.isTrue(result)\n    })\n  })\n\n  describe('isNumber function', () => {\n    test('returns false for null', () => {\n      const result = _.isNumber(null)\n      assert.isFalse(result)\n    })\n    test('returns false for undefined', () => {\n      const result = _.isNumber(undefined)\n      assert.isFalse(result)\n    })\n    test('returns false for boolean', () => {\n      const result = _.isNumber(false)\n      assert.isFalse(result)\n    })\n    test('returns false for class instance', () => {\n      class Data {}\n      const result = _.isNumber(new Data())\n      assert.isFalse(result)\n    })\n    test('returns true for int', () => {\n      const result = _.isNumber(22)\n      assert.isTrue(result)\n    })\n    test('returns true for float', () => {\n      const result = _.isNumber(22.0567)\n      assert.isTrue(result)\n    })\n    test('returns false for NaN', () => {\n      const result = _.isNumber(NaN)\n      assert.isFalse(result)\n    })\n    test('returns false for array', () => {\n      const result = _.isNumber([1, 2, 3])\n      assert.isFalse(result)\n    })\n    test('returns false for object', () => {\n      const result = _.isNumber({})\n      assert.isFalse(result)\n    })\n    test('returns false for string', () => {\n      const result = _.isNumber('abc')\n      assert.isFalse(result)\n    })\n    test('returns false for string class', () => {\n      const result = _.isNumber(String('abc'))\n      assert.isFalse(result)\n    })\n  })\n\n  describe('isInt function', () => {\n    class Data {}\n    test('returns false for non-number values', () => {\n      assert.isFalse(_.isInt(undefined))\n      assert.isFalse(_.isInt(null))\n      assert.isFalse(_.isInt(false))\n      assert.isFalse(_.isInt(new Data()))\n      assert.isFalse(_.isInt(NaN))\n      assert.isFalse(_.isInt([1, 2, 3]))\n      assert.isFalse(_.isInt({}))\n      assert.isFalse(_.isInt('abc'))\n      assert.isFalse(_.isInt(String('abc')))\n    })\n    test('returns true for int', () => {\n      const result = _.isInt(22)\n      assert.isTrue(result)\n    })\n    test('returns false for float', () => {\n      const result = _.isInt(22.0567)\n      assert.isFalse(result)\n    })\n  })\n\n  describe('isFloat function', () => {\n    class Data {}\n    test('returns false for non-number values', () => {\n      assert.isFalse(_.isFloat(undefined))\n      assert.isFalse(_.isFloat(null))\n      assert.isFalse(_.isFloat(false))\n      assert.isFalse(_.isFloat(new Data()))\n      assert.isFalse(_.isFloat(NaN))\n      assert.isFalse(_.isFloat([1, 2, 3]))\n      assert.isFalse(_.isFloat({}))\n      assert.isFalse(_.isFloat('abc'))\n      assert.isFalse(_.isFloat(String('abc')))\n    })\n    test('returns false for int', () => {\n      const result = _.isFloat(22)\n      assert.isFalse(result)\n    })\n    test('returns true for float', () => {\n      const result = _.isFloat(22.0567)\n      assert.isTrue(result)\n    })\n  })\n\n  describe('isEmpty function', () => {\n    class Data {}\n    class Person {\n      name: string = 'ray'\n    }\n    test('returns true for empty values', () => {\n      assert.isTrue(_.isEmpty(null))\n      assert.isTrue(_.isEmpty(undefined))\n      assert.isTrue(_.isEmpty(new Data()))\n      assert.isTrue(_.isEmpty(0))\n      assert.isTrue(_.isEmpty(true))\n      assert.isTrue(_.isEmpty([]))\n      assert.isTrue(_.isEmpty(false))\n      assert.isTrue(_.isEmpty({}))\n      assert.isTrue(_.isEmpty(''))\n      assert.isTrue(_.isEmpty(String()))\n      assert.isTrue(_.isEmpty(new Map()))\n      assert.isTrue(_.isEmpty(new Date('invalid value')))\n    })\n    test('returns false for non-empty values', () => {\n      assert.isFalse(_.isEmpty(new Date()))\n      assert.isFalse(_.isEmpty(new Date('2022-09-01T02:19:55.976Z')))\n      assert.isFalse(_.isEmpty(22))\n      assert.isFalse(_.isEmpty(new Person()))\n      assert.isFalse(_.isEmpty({ name: 'x' }))\n      assert.isFalse(_.isEmpty('abc'))\n      assert.isFalse(_.isEmpty(String('abc')))\n      assert.isFalse(_.isEmpty([1, 2, 3]))\n      assert.isFalse(_.isEmpty(function work() {}))\n      assert.isFalse(_.isEmpty(() => {}))\n      assert.isFalse(_.isEmpty(Symbol('')))\n      assert.isFalse(_.isEmpty(Symbol('hello')))\n      const map = new Map()\n      map.set('a', 1)\n      assert.isFalse(_.isEmpty(map))\n    })\n  })\n\n  describe('isDate function', () => {\n    test('return true for Date values', () => {\n      assert.isTrue(_.isDate(new Date()))\n      assert.isTrue(_.isDate(new Date('2022-09-01T02:19:55.976Z')))\n      assert.isTrue(_.isDate(new Date('invalid value')))\n    })\n    test('return false for non-Date values', () => {\n      assert.isFalse(_.isDate(22))\n      assert.isFalse(_.isDate({ name: 'x' }))\n      assert.isFalse(_.isDate('abc'))\n      assert.isFalse(_.isDate(String('abc')))\n      assert.isFalse(_.isDate([1, 2, 3]))\n      assert.isFalse(_.isDate(function work() {}))\n      assert.isFalse(_.isDate(() => {}))\n      assert.isFalse(_.isDate(Symbol('')))\n      assert.isFalse(_.isDate(Symbol('hello')))\n    })\n  })\n\n  describe('isPromise function', () => {\n    test('return true for Promise values', () => {\n      assert.isTrue(_.isPromise(new Promise(res => res(0))))\n      assert.isTrue(_.isPromise(new Promise(res => res(''))))\n      assert.isTrue(_.isPromise((async () => {})()))\n    })\n    test('return false for non-Date values', () => {\n      assert.isFalse(_.isPromise(22))\n      assert.isFalse(_.isPromise({ name: 'x' }))\n      assert.isFalse(_.isPromise('abc'))\n      assert.isFalse(_.isPromise(String('abc')))\n      assert.isFalse(_.isPromise([1, 2, 3]))\n      assert.isFalse(_.isPromise(function work() {}))\n      assert.isFalse(_.isPromise(() => {}))\n      assert.isFalse(_.isPromise(Symbol('')))\n      assert.isFalse(_.isPromise(Symbol('hello')))\n      assert.isFalse(_.isPromise({ then: 2 }))\n    })\n  })\n\n  describe('isSymbol function', () => {\n    test('returns false for null', () => {\n      const input = null\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for undefined', () => {\n      const input = undefined\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for empty class instance', () => {\n      class Data {}\n      const input = new Data()\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for class instance with properties', () => {\n      class Data {\n        name: string = 'ray'\n      }\n      const input = new Data()\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for number greater than 0', () => {\n      const input = 22\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for number 0', () => {\n      const input = 0\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for array with values', () => {\n      const input = [1, 2, 3]\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for empty array', () => {\n      const input: unknown[] = []\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for true', () => {\n      const input = true\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for false', () => {\n      const input = false\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for empty object', () => {\n      const input = {}\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for object with values', () => {\n      const input = { name: 'x' }\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for string with chars', () => {\n      const input = 'abc'\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for empty string', () => {\n      const input = ''\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for empty string class', () => {\n      const input = ''\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for string class with chars', () => {\n      const input = 'abc'\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns false for empty Map', () => {\n      const input = new Map()\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n    test('returns true for empty Symbol', () => {\n      const input = Symbol('')\n      const result = _.isSymbol(input)\n      assert.isTrue(result)\n    })\n    test('returns true for Symbol instance', () => {\n      const input = Symbol('hello')\n      const result = _.isSymbol(input)\n      assert.isTrue(result)\n    })\n    test('returns false for Map with values', () => {\n      const input = new Map()\n      input.set('a', 1)\n      input.set('b', 2)\n      input.set('c', 3)\n      const result = _.isSymbol(input)\n      assert.isFalse(result)\n    })\n  })\n\n  describe('isEqual function', () => {\n    class Person {\n      name: string\n      friends: Person[] = []\n      self?: Person\n      constructor(name: string) {\n        this.name = name\n      }\n    }\n    const jake = new Person('jake')\n    jake.self = jake\n    jake.friends = [jake, jake]\n    const symbolKey = Symbol('symkey')\n    const complex = {\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: void 0,\n      nul: null,\n      obj: { name: 'object', id: 1, chilren: [0, 1, 2] },\n      arr: [0, 1, 2],\n      func() {\n        console.log('function')\n      },\n      loop: null as any,\n      person: jake,\n      date: new Date(0),\n      reg: new RegExp('/regexp/ig'),\n      [symbolKey]: 'symbol'\n    }\n    complex.loop = complex\n    test('returns true for equal things', () => {\n      assert.isTrue(_.isEqual(0, 0))\n      assert.isTrue(_.isEqual('a', 'a'))\n      const hello = Symbol('hello')\n      assert.isTrue(_.isEqual(hello, hello))\n      assert.isTrue(_.isEqual({}, {}))\n      assert.isTrue(_.isEqual(true, true))\n      assert.isTrue(_.isEqual(new RegExp(/a*s/), new RegExp(/a*s/)))\n      const now = new Date()\n      assert.isTrue(_.isEqual(now, now))\n      assert.isTrue(_.isEqual([], []))\n      assert.isTrue(_.isEqual(complex, { ...complex }))\n      assert.isTrue(\n        _.isEqual([complex, complex], [{ ...complex }, { ...complex }])\n      )\n    })\n    test('returns false for non-equal things', () => {\n      assert.isFalse(_.isEqual(0, 1))\n      assert.isFalse(_.isEqual('a', 'b'))\n      assert.isFalse(_.isEqual(new RegExp(/^http:/), new RegExp(/https/)))\n      assert.isFalse(_.isEqual(Symbol('hello'), Symbol('goodbye')))\n      assert.isFalse(_.isEqual({ z: 23 }, { a: 1 }))\n      assert.isFalse(_.isEqual(true, false))\n      assert.isFalse(\n        _.isEqual(new Date(), new Date('2022-09-01T03:25:12.750Z'))\n      )\n      assert.isFalse(_.isEqual([], [1]))\n      assert.isFalse(_.isEqual(complex, { ...complex, num: 222 }))\n      assert.isFalse(_.isEqual([complex], [{ ...complex, num: 222 }]))\n    })\n  })\n})\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\generateId.test.ts\\generateId.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nexport default () => {\n  const d =\n    typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport generateId from '../../logic/generateId';\n\ndescribe('generateId', () => {\n  it('should generate a unique id', () => {\n    expect(/\\w{8}-\\w{4}-4\\w{3}-\\w{4}-\\w{12}/i.test(generateId())).toBeTruthy();\n  });\n\n  it('should fallback to current date if performance is undefined', () => {\n    Object.defineProperty(window, 'performance', {\n      value: undefined,\n    });\n\n    expect(/\\w{8}-\\w{4}-4\\w{3}-\\w{4}-\\w{12}/i.test(generateId())).toBeTruthy();\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\getCheckboxValue.test.ts\\getCheckboxValue.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport isUndefined from '../utils/isUndefined';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean | undefined;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: HTMLInputElement[]): CheckboxFieldResult => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.checked && !option.disabled)\n        .map((option) => option.value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    return options[0].checked && !options[0].disabled\n      ? // @ts-expect-error expected to work in the browser\n        options[0].attributes && !isUndefined(options[0].attributes.value)\n        ? isUndefined(options[0].value) || options[0].value === ''\n          ? validResult\n          : { value: options[0].value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n\n### Source File Dependency Files Content\n### Dependency File: isUndefined.ts\nexport default (val: unknown): val is undefined => val === undefined;\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport getCheckboxValue from '../../logic/getCheckboxValue';\n\ndescribe('getCheckboxValue', () => {\n  it('should return default value if not valid or empty options', () => {\n    expect(getCheckboxValue(undefined)).toEqual({\n      value: false,\n      isValid: false,\n    });\n  });\n\n  it('should return checked value if single checkbox is checked', () => {\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: true,\n          value: '3',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '3' },\n        },\n      ]),\n    ).toEqual({ value: '3', isValid: true });\n  });\n\n  it('should return true if single checkbox is checked and has no value', () => {\n    expect(\n      // @ts-expect-error this is a mock for html input\n      getCheckboxValue([{ name: 'bill', checked: true, attributes: {} }]),\n    ).toEqual({ value: true, isValid: true });\n  });\n\n  it('should return true if single checkbox is checked and has empty value', () => {\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: true,\n          value: '',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: 'test' },\n        },\n      ]),\n    ).toEqual({ value: true, isValid: true });\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: true,\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: 'test' },\n        },\n      ]),\n    ).toEqual({ value: true, isValid: true });\n  });\n\n  it('should return false if single checkbox is un-checked', () => {\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: false,\n          // @ts-expect-error this is a mock for html input\n          attributes: {},\n        },\n      ]),\n    ).toEqual({ value: false, isValid: false });\n  });\n\n  it('should return multiple selected values', () => {\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: true,\n          value: '2',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '2' },\n        },\n        {\n          name: 'bill',\n          checked: true,\n          value: '3',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '3' },\n        },\n      ]),\n    ).toEqual({ value: ['2', '3'], isValid: true });\n  });\n\n  it('should return values for checked boxes only', () => {\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: false,\n          value: '2',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '2' },\n        },\n        {\n          name: 'bill',\n          checked: true,\n          value: '3',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '3' },\n        },\n        {\n          name: 'bill',\n          checked: false,\n          value: '4',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '4' },\n        },\n      ]),\n    ).toEqual({ value: ['3'], isValid: true });\n  });\n\n  it('should return empty array for multi checkbox with no checked box', () => {\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: false,\n          value: '2',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '2' },\n        },\n        {\n          name: 'bill',\n          checked: false,\n          value: '3',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '3' },\n        },\n      ]),\n    ).toEqual({ value: [], isValid: false });\n  });\n\n  it('should not return error when check box ref is undefined', () => {\n    expect(\n      getCheckboxValue([\n        // @ts-expect-error this is a mock for html input\n        undefined,\n        {\n          name: 'bill',\n          checked: false,\n          value: '2',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '2' },\n        },\n      ]),\n    ).toEqual({ value: [], isValid: false });\n  });\n\n  it('should return disabled input result', () => {\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: true,\n          value: '2',\n          disabled: true,\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '2' },\n        },\n        {\n          name: 'bill',\n          checked: true,\n          value: '3',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '3' },\n        },\n      ]),\n    ).toEqual({\n      value: ['3'],\n      isValid: true,\n    });\n\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: true,\n          value: '2',\n          disabled: true,\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '2' },\n        },\n        {\n          name: 'bill',\n          disabled: true,\n          checked: true,\n          value: '3',\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '3' },\n        },\n      ]),\n    ).toEqual({\n      value: [],\n      isValid: false,\n    });\n\n    expect(\n      getCheckboxValue([\n        {\n          name: 'bill',\n          checked: true,\n          value: '2',\n          disabled: true,\n          // @ts-expect-error this is a mock for html input\n          attributes: { value: '2' },\n        },\n      ]),\n    ).toEqual({\n      value: false,\n      isValid: false,\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\getEventValue.test.ts\\getEventValue.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isObject from '../utils/isObject';\n\ntype Event = { target: any };\n\nexport default (event: unknown) =>\n  isObject(event) && (event as Event).target\n    ? isCheckBoxInput((event as Event).target)\n      ? (event as Event).target.checked\n      : (event as Event).target.value\n    : event;\n\n### Source File Dependency Files Content\n### Dependency File: isCheckBoxInput.ts\nimport { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n\n\n### Dependency File: isObject.ts\nimport isDateObject from './isDateObject';\nimport isNullOrUndefined from './isNullOrUndefined';\n\nexport const isObjectType = (value: unknown): value is object =>\n  typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !Array.isArray(value) &&\n  isObjectType(value) &&\n  !isDateObject(value);\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport getEventValue from '../../logic/getEventValue';\n\ntest('getEventValue should return correct value', () => {\n  expect(\n    getEventValue({\n      target: { checked: true, type: 'checkbox' },\n    }),\n  ).toEqual(true);\n  expect(\n    getEventValue({\n      target: { checked: true, type: 'checkbox', value: 'test' },\n    }),\n  ).toEqual(true);\n  expect(getEventValue({ target: { value: 'test' }, type: 'test' })).toEqual(\n    'test',\n  );\n  expect(getEventValue({ data: 'test' })).toEqual({ data: 'test' });\n  expect(getEventValue('test')).toEqual('test');\n  expect(getEventValue(undefined)).toEqual(undefined);\n  expect(getEventValue(null)).toEqual(null);\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\getNodeParentName.test.ts\\getNodeParentName.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nexport default (name: string) =>\n  name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport getNodeParentName from '../../logic/getNodeParentName';\n\ndescribe('getNodeParentName', () => {\n  it('should return parent name when name is field array', () => {\n    expect(getNodeParentName('test.0')).toBe('test');\n    expect(getNodeParentName('test1.1')).toBe('test1');\n    expect(getNodeParentName('test.0.data.0')).toBe('test');\n    expect(getNodeParentName('test.data.0')).toBe('test.data');\n    expect(getNodeParentName('test.1st')).toBe('test.1st');\n  });\n\n  it('should return empty string when name is not field array', () => {\n    expect(getNodeParentName('test')).toBe('test');\n    expect(getNodeParentName('test0')).toBe('test0');\n    expect(getNodeParentName('te1st')).toBe('te1st');\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\getRadioValue.test.ts\\getRadioValue.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\ntype RadioFieldResult = {\n  isValid: boolean;\n  value: number | string | null;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: null,\n};\n\nexport default (options?: HTMLInputElement[]): RadioFieldResult =>\n  Array.isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.checked && !option.disabled\n            ? {\n                isValid: true,\n                value: option.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport getRadioValue from '../../logic/getRadioValue';\n\ndescribe('getRadioValue', () => {\n  it('should return default value if not valid or empty options', () => {\n    expect(getRadioValue(undefined)).toEqual({\n      isValid: false,\n      value: null,\n    });\n  });\n\n  it('should return valid to true when value found', () => {\n    expect(\n      getRadioValue([\n        { name: 'bill', checked: false, value: '1' } as HTMLInputElement,\n        { name: 'bill', checked: true, value: '2' } as HTMLInputElement,\n      ]),\n    ).toEqual({\n      isValid: true,\n      value: '2',\n    });\n  });\n\n  it('should return disabled input correctly', () => {\n    expect(\n      getRadioValue([\n        {\n          name: 'bill',\n          checked: false,\n          value: '1',\n          disabled: true,\n        } as HTMLInputElement,\n        { name: 'bill', checked: true, value: '2' } as HTMLInputElement,\n      ]),\n    ).toEqual({\n      isValid: true,\n      value: '2',\n    });\n\n    expect(\n      getRadioValue([\n        {\n          name: 'bill',\n          checked: false,\n          value: '1',\n        } as HTMLInputElement,\n        {\n          name: 'bill',\n          checked: true,\n          disabled: true,\n          value: '2',\n        } as HTMLInputElement,\n      ]),\n    ).toEqual({\n      isValid: false,\n      value: null,\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\isBoolean.test.ts\\isBoolean.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nexport default (value: unknown): value is boolean => typeof value === 'boolean';\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport isBoolean from '../../utils/isBoolean';\n\ndescribe('isBoolean', () => {\n  it('should return true when value is a boolean', () => {\n    expect(isBoolean(true)).toBeTruthy();\n    expect(isBoolean(false)).toBeTruthy();\n  });\n\n  it('should return false when value is not a boolean', () => {\n    expect(isBoolean(null)).toBeFalsy();\n    expect(isBoolean(undefined)).toBeFalsy();\n    expect(isBoolean(-1)).toBeFalsy();\n    expect(isBoolean(0)).toBeFalsy();\n    expect(isBoolean(1)).toBeFalsy();\n    expect(isBoolean('')).toBeFalsy();\n    expect(isBoolean({})).toBeFalsy();\n    expect(isBoolean([])).toBeFalsy();\n    expect(isBoolean(() => null)).toBeFalsy();\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\isCheckBoxInput.test.ts\\isCheckBoxInput.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n\n### Source File Dependency Files Content\n### Dependency File: fields.ts\nimport { IsFlatObject, Noop } from './utils';\nimport { RegisterOptions } from './validator';\n\nexport type InternalFieldName = string;\n\nexport type FieldName<TFieldValues extends FieldValues> =\n  IsFlatObject<TFieldValues> extends true\n    ? Extract<keyof TFieldValues, string>\n    : string;\n\nexport type CustomElement<TFieldValues extends FieldValues> =\n  Partial<HTMLElement> & {\n    name: FieldName<TFieldValues>;\n    type?: string;\n    value?: any;\n    disabled?: boolean;\n    checked?: boolean;\n    options?: HTMLOptionsCollection;\n    files?: FileList | null;\n    focus?: Noop;\n  };\n\nexport type FieldValue<TFieldValues extends FieldValues> =\n  TFieldValues[InternalFieldName];\n\nexport type FieldValues = Record<string, any>;\n\nexport type NativeFieldValue =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | unknown[];\n\nexport type FieldElement<TFieldValues extends FieldValues = FieldValues> =\n  | HTMLInputElement\n  | HTMLSelectElement\n  | HTMLTextAreaElement\n  | CustomElement<TFieldValues>;\n\nexport type Ref = FieldElement;\n\nexport type Field = {\n  _f: {\n    ref: Ref;\n    name: InternalFieldName;\n    refs?: HTMLInputElement[];\n    mount?: boolean;\n  } & RegisterOptions;\n};\n\nexport type FieldRefs = Partial<{\n  [key: InternalFieldName]: Field | FieldRefs;\n}>;\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport isCheckBoxInput from '../../utils/isCheckBoxInput';\n\ndescribe('isCheckBoxInput', () => {\n  it('should return true when type is checkbox', () => {\n    expect(isCheckBoxInput({ name: 'test', type: 'checkbox' })).toBeTruthy();\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\isFileInput.test.ts\\isFileInput.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n\n### Source File Dependency Files Content\n### Dependency File: fields.ts\nimport { IsFlatObject, Noop } from './utils';\nimport { RegisterOptions } from './validator';\n\nexport type InternalFieldName = string;\n\nexport type FieldName<TFieldValues extends FieldValues> =\n  IsFlatObject<TFieldValues> extends true\n    ? Extract<keyof TFieldValues, string>\n    : string;\n\nexport type CustomElement<TFieldValues extends FieldValues> =\n  Partial<HTMLElement> & {\n    name: FieldName<TFieldValues>;\n    type?: string;\n    value?: any;\n    disabled?: boolean;\n    checked?: boolean;\n    options?: HTMLOptionsCollection;\n    files?: FileList | null;\n    focus?: Noop;\n  };\n\nexport type FieldValue<TFieldValues extends FieldValues> =\n  TFieldValues[InternalFieldName];\n\nexport type FieldValues = Record<string, any>;\n\nexport type NativeFieldValue =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | unknown[];\n\nexport type FieldElement<TFieldValues extends FieldValues = FieldValues> =\n  | HTMLInputElement\n  | HTMLSelectElement\n  | HTMLTextAreaElement\n  | CustomElement<TFieldValues>;\n\nexport type Ref = FieldElement;\n\nexport type Field = {\n  _f: {\n    ref: Ref;\n    name: InternalFieldName;\n    refs?: HTMLInputElement[];\n    mount?: boolean;\n  } & RegisterOptions;\n};\n\nexport type FieldRefs = Partial<{\n  [key: InternalFieldName]: Field | FieldRefs;\n}>;\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport isFileInput from '../../utils/isFileInput';\n\ndescribe('isFileInput', () => {\n  it('should return true when type is file', () => {\n    expect(isFileInput({ name: 'test', type: 'file' })).toBeTruthy();\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\isKey.test.ts\\isKey.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nexport default (value: string) => /^\\w*$/.test(value);\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport isKey from '../../utils/isKey';\n\ndescribe('isKey', () => {\n  it('should return true when it is not a deep key', () => {\n    expect(isKey('test')).toBeTruthy();\n    expect(isKey('fooBar')).toBeTruthy();\n  });\n\n  it('should return false when it is a deep key', () => {\n    expect(isKey('test.foo')).toBeFalsy();\n    expect(isKey('test.foo[0]')).toBeFalsy();\n    expect(isKey('test[1]')).toBeFalsy();\n    expect(isKey('test.foo[0].bar')).toBeFalsy();\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\shouldSubscribeByName.test.ts\\shouldSubscribeByName.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport convertToArrayPayload from '../utils/convertToArrayPayload';\n\nexport default <T extends string | string[] | undefined>(\n  name?: T,\n  signalName?: string,\n  exact?: boolean,\n) =>\n  !name ||\n  !signalName ||\n  name === signalName ||\n  convertToArrayPayload(name).some(\n    (currentName) =>\n      currentName &&\n      (exact\n        ? currentName === signalName\n        : currentName.startsWith(signalName) ||\n          signalName.startsWith(currentName)),\n  );\n\n### Source File Dependency Files Content\n### Dependency File: convertToArrayPayload.ts\nexport default <T>(value: T) => (Array.isArray(value) ? value : [value]);\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport shouldSubscribeByName from '../../logic/shouldSubscribeByName';\n\ndescribe('shouldSubscribeByName', () => {\n  it('should return correct response for subscription name coverage', () => {\n    expect(shouldSubscribeByName(undefined, 'test')).toBeTruthy();\n    expect(shouldSubscribeByName('test', undefined)).toBeTruthy();\n    expect(shouldSubscribeByName(['test'], undefined)).toBeTruthy();\n    expect(shouldSubscribeByName(['test'], 'test')).toBeTruthy();\n    expect(shouldSubscribeByName(['tes'], 'test')).toBeTruthy();\n    expect(shouldSubscribeByName(['test1'], 'test')).toBeTruthy();\n    expect(shouldSubscribeByName('test1', 'test')).toBeTruthy();\n    expect(shouldSubscribeByName('tes', 'test')).toBeTruthy();\n\n    expect(shouldSubscribeByName('testXXX', 'data')).toBeFalsy();\n    expect(shouldSubscribeByName(['testXXX'], 'data')).toBeFalsy();\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: react-hook-form\nTest File Path: react-hook-form\\skipValidation.test.ts\\skipValidation.test.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { ValidationModeFlags } from '../types';\n\nexport default (\n  isBlurEvent: boolean,\n  isTouched: boolean,\n  isSubmitted: boolean,\n  reValidateMode: {\n    isOnBlur: boolean;\n    isOnChange: boolean;\n  },\n  mode: Partial<ValidationModeFlags>,\n) => {\n  if (mode.isOnAll) {\n    return false;\n  } else if (!isSubmitted && mode.isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n\n### Source File Dependency Files Content\n### Dependency File: form.ts\nimport React from 'react';\n\nimport { VALIDATION_MODE } from '../constants';\nimport { Subject, Subscription } from '../utils/createSubject';\n\nimport { ErrorOption, FieldError, FieldErrors } from './errors';\nimport { EventType } from './events';\nimport { FieldArray } from './fieldArray';\nimport {\n  FieldName,\n  FieldRefs,\n  FieldValue,\n  FieldValues,\n  InternalFieldName,\n} from './fields';\nimport {\n  FieldArrayPath,\n  FieldPath,\n  FieldPathValue,\n  FieldPathValues,\n} from './path';\nimport { Resolver } from './resolvers';\nimport { DeepMap, DeepPartial, Noop } from './utils';\nimport { RegisterOptions } from './validator';\n\ndeclare const $NestedValue: unique symbol;\n\n/**\n * @deprecated to be removed in the next major version\n */\nexport type NestedValue<TValue extends object = object> = {\n  [$NestedValue]: never;\n} & TValue;\n\nexport type DefaultValues<TFieldValues> =\n  TFieldValues extends AsyncDefaultValues<TFieldValues>\n    ? DeepPartial<Awaited<TFieldValues>>\n    : DeepPartial<TFieldValues>;\n\nexport type InternalNameSet = Set<InternalFieldName>;\n\nexport type ValidationMode = typeof VALIDATION_MODE;\n\nexport type Mode = keyof ValidationMode;\n\nexport type ValidationModeFlags = {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n};\n\nexport type CriteriaMode = 'firstError' | 'all';\n\nexport type SubmitHandler<T> = (\n  data: T,\n  event?: React.BaseSyntheticEvent,\n) => unknown | Promise<unknown>;\n\nexport type FormSubmitHandler<TTransformedValues> = (payload: {\n  data: TTransformedValues;\n  event?: React.BaseSyntheticEvent;\n  formData: FormData;\n  formDataJson: string;\n  method?: 'post' | 'put' | 'delete';\n}) => unknown | Promise<unknown>;\n\nexport type SubmitErrorHandler<TFieldValues extends FieldValues> = (\n  errors: FieldErrors<TFieldValues>,\n  event?: React.BaseSyntheticEvent,\n) => unknown | Promise<unknown>;\n\nexport type SetValueConfig = Partial<{\n  shouldValidate: boolean;\n  shouldDirty: boolean;\n  shouldTouch: boolean;\n}>;\n\nexport type TriggerConfig = Partial<{\n  shouldFocus: boolean;\n}>;\n\nexport type ChangeHandler = (event: {\n  target: any;\n  type?: any;\n}) => Promise<void | boolean>;\n\nexport type DelayCallback = (wait: number) => void;\n\ntype AsyncDefaultValues<TFieldValues> = (\n  payload?: unknown,\n) => Promise<TFieldValues>;\n\nexport type UseFormProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext = any,\n  TTransformedValues = TFieldValues,\n> = Partial<{\n  mode: Mode;\n  disabled: boolean;\n  reValidateMode: Exclude<Mode, 'onTouched' | 'all'>;\n  defaultValues: DefaultValues<TFieldValues> | AsyncDefaultValues<TFieldValues>;\n  values: TFieldValues;\n  errors: FieldErrors<TFieldValues>;\n  resetOptions: Parameters<UseFormReset<TFieldValues>>[1];\n  resolver: Resolver<TFieldValues, TContext, TTransformedValues>;\n  context: TContext;\n  shouldFocusError: boolean;\n  shouldUnregister: boolean;\n  shouldUseNativeValidation: boolean;\n  progressive: boolean;\n  criteriaMode: CriteriaMode;\n  delayError: number;\n  formControl?: Omit<\n    UseFormReturn<TFieldValues, TContext, TTransformedValues>,\n    'formState'\n  >;\n}>;\n\nexport type FieldNamesMarkedBoolean<TFieldValues extends FieldValues> = DeepMap<\n  DeepPartial<TFieldValues>,\n  boolean\n>;\n\nexport type FormStateProxy<TFieldValues extends FieldValues = FieldValues> = {\n  isDirty: boolean;\n  isValidating: boolean;\n  dirtyFields: FieldNamesMarkedBoolean<TFieldValues>;\n  touchedFields: FieldNamesMarkedBoolean<TFieldValues>;\n  validatingFields: FieldNamesMarkedBoolean<TFieldValues>;\n  errors: boolean;\n  isValid: boolean;\n};\n\nexport type ReadFormState = { [K in keyof FormStateProxy]: boolean | 'all' } & {\n  values?: boolean;\n};\n\nexport type FormState<TFieldValues extends FieldValues> = {\n  isDirty: boolean;\n  isLoading: boolean;\n  isSubmitted: boolean;\n  isSubmitSuccessful: boolean;\n  isSubmitting: boolean;\n  isValidating: boolean;\n  isValid: boolean;\n  disabled: boolean;\n  submitCount: number;\n  defaultValues?: undefined | Readonly<DeepPartial<TFieldValues>>;\n  dirtyFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;\n  touchedFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;\n  validatingFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;\n  errors: FieldErrors<TFieldValues>;\n};\n\nexport type KeepStateOptions = Partial<{\n  keepDirtyValues: boolean;\n  keepErrors: boolean;\n  keepDirty: boolean;\n  keepValues: boolean;\n  keepDefaultValues: boolean;\n  keepIsSubmitted: boolean;\n  keepIsSubmitSuccessful: boolean;\n  keepTouched: boolean;\n  keepIsValidating: boolean;\n  keepIsValid: boolean;\n  keepSubmitCount: boolean;\n}>;\n\nexport type SetFieldValue<TFieldValues extends FieldValues> =\n  FieldValue<TFieldValues>;\n\nexport type RefCallBack = (instance: any) => void;\n\nexport type UseFormRegisterReturn<\n  TFieldName extends InternalFieldName = InternalFieldName,\n> = {\n  onChange: ChangeHandler;\n  onBlur: ChangeHandler;\n  ref: RefCallBack;\n  name: TFieldName;\n  min?: string | number;\n  max?: string | number;\n  maxLength?: number;\n  minLength?: number;\n  pattern?: string;\n  required?: boolean;\n  disabled?: boolean;\n};\n\n/**\n * Register field into hook form with or without the actual DOM ref. You can invoke register anywhere in the component including at `useEffect`.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/register) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-register-ts-ip2j3) \u2022 [Video](https://www.youtube.com/watch?v=JFIpCoajYkA)\n *\n * @param name - the path name to the form field value, name is required and unique\n * @param options - register options include validation, disabled, unregister, value as and dependent validation\n *\n * @returns onChange, onBlur, name, ref, and native contribute attribute if browser validation is enabled.\n *\n * @example\n * ```tsx\n * // Register HTML native input\n * <input {...register(\"input\")} />\n * <select {...register(\"select\")} />\n *\n * // Register options\n * <textarea {...register(\"textarea\", { required: \"This is required.\", maxLength: 20 })} />\n * <input type=\"number\" {...register(\"name2\", { valueAsNumber: true })} />\n * <input {...register(\"name3\", { deps: [\"name2\"] })} />\n *\n * // Register custom field at useEffect\n * useEffect(() => {\n *   register(\"name4\");\n *   register(\"name5\", { value: \"hiddenValue\" });\n * }, [register])\n *\n * // Register without ref\n * const { onChange, onBlur, name } = register(\"name6\")\n * <input onChange={onChange} onBlur={onBlur} name={name} />\n * ```\n */\nexport type UseFormRegister<TFieldValues extends FieldValues> = <\n  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(\n  name: TFieldName,\n  options?: RegisterOptions<TFieldValues, TFieldName>,\n) => UseFormRegisterReturn<TFieldName>;\n\nexport type SetFocusOptions = Partial<{\n  shouldSelect: boolean;\n}>;\n\n/**\n * Set focus on a registered field. You can start to invoke this method after all fields are mounted to the DOM.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/setfocus) \u2022 [Demo](https://codesandbox.io/s/setfocus-rolus)\n *\n * @param name - the path name to the form field value.\n * @param options - input focus behavior options\n *\n * @example\n * ```tsx\n * useEffect(() => {\n *   setFocus(\"name\");\n * }, [setFocus])\n * // shouldSelect allows to select input's content on focus\n * <button onClick={() => setFocus(\"name\", { shouldSelect: true })}>Focus</button>\n * ```\n */\nexport type UseFormSetFocus<TFieldValues extends FieldValues> = <\n  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(\n  name: TFieldName,\n  options?: SetFocusOptions,\n) => void;\n\nexport type UseFormGetValues<TFieldValues extends FieldValues> = {\n  /**\n   * Get the entire form values when no argument is supplied to this function.\n   *\n   * @remarks\n   * [API](https://react-hook-form.com/docs/useform/getvalues) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-getvalues-txsfg)\n   *\n   * @returns form values\n   *\n   * @example\n   * ```tsx\n   * <button onClick={() => getValues()}>getValues</button>\n   *\n   * <input {...register(\"name\", {\n   *   validate: (value, formValues) => formValues.otherField === value;\n   * })} />\n   * ```\n   */\n  (): TFieldValues;\n  /**\n   * Get a single field value.\n   *\n   * @remarks\n   * [API](https://react-hook-form.com/docs/useform/getvalues) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-getvalues-txsfg)\n   *\n   * @param name - the path name to the form field value.\n   *\n   * @returns the single field value\n   *\n   * @example\n   * ```tsx\n   * <button onClick={() => getValues(\"name\")}>getValues</button>\n   *\n   * <input {...register(\"name\", {\n   *   validate: () => getValues('otherField') === \"test\";\n   * })} />\n   * ```\n   */\n  <TFieldName extends FieldPath<TFieldValues>>(\n    name: TFieldName,\n  ): FieldPathValue<TFieldValues, TFieldName>;\n  /**\n   * Get an array of field values.\n   *\n   * @remarks\n   * [API](https://react-hook-form.com/docs/useform/getvalues) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-getvalues-txsfg)\n   *\n   * @param names - an array of field names\n   *\n   * @returns An array of field values\n   *\n   * @example\n   * ```tsx\n   * <button onClick={() => getValues([\"name\", \"name1\"])}>getValues</button>\n   *\n   * <input {...register(\"name\", {\n   *   validate: () => getValues([\"fieldA\", \"fieldB\"]).includes(\"test\");\n   * })} />\n   * ```\n   */\n  <TFieldNames extends FieldPath<TFieldValues>[]>(\n    names: readonly [...TFieldNames],\n  ): [...FieldPathValues<TFieldValues, TFieldNames>];\n};\n\n/**\n * This method will return individual field states. It will be useful when you are trying to retrieve the nested value field state in a typesafe approach.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/getfieldstate) \u2022 [Demo](https://codesandbox.io/s/getfieldstate-jvekk)\n *\n * @param name - the path name to the form field value.\n *\n * @returns invalid, isDirty, isTouched and error object\n *\n * @example\n * ```tsx\n * // those formState has to be subscribed\n * const { formState: { dirtyFields, errors, touchedFields } } = formState();\n * getFieldState('name')\n * // Get field state when form state is not subscribed yet\n * getFieldState('name', formState)\n *\n * // It's ok to combine with useFormState\n * const formState = useFormState();\n * getFieldState('name')\n * getFieldState('name', formState)\n * ```\n */\nexport type UseFormGetFieldState<TFieldValues extends FieldValues> = <\n  TFieldName extends FieldPath<TFieldValues>,\n>(\n  name: TFieldName,\n  formState?: FormState<TFieldValues>,\n) => {\n  invalid: boolean;\n  isDirty: boolean;\n  isTouched: boolean;\n  isValidating: boolean;\n  error?: FieldError;\n};\n\n/**\n * This method will allow you to subscribe to formState without component render\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/subscribe) \u2022 [Demo](https://codesandbox.io/s/subscribe)\n *\n * @param options - subscription options on which formState subscribe to\n *\n * @example\n * ```tsx\nconst { subscribe } = useForm()\n\nuseEffect(() => {\n subscribe({\n   formState: { isDirty: true },\n   callback: () => {}\n })\n})\n * ```\n */\nexport type UseFromSubscribe<TFieldValues extends FieldValues> = (payload: {\n  name?: string;\n  formState?: Partial<ReadFormState>;\n  callback: (\n    data: Partial<FormState<TFieldValues>> & { values: TFieldValues },\n  ) => void;\n  exact?: boolean;\n}) => () => void;\n\nexport type UseFormWatch<TFieldValues extends FieldValues> = {\n  /**\n   * Watch and subscribe to the entire form update/change based on onChange and re-render at the useForm.\n   *\n   * @remarks\n   * [API](https://react-hook-form.com/docs/useform/watch) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d) \u2022 [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)\n   *\n   * @returns return the entire form values\n   *\n   * @example\n   * ```tsx\n   * const formValues = watch();\n   * ```\n   */\n  (): TFieldValues;\n  /**\n   * Watch and subscribe to an array of fields used outside of render.\n   *\n   * @remarks\n   * [API](https://react-hook-form.com/docs/useform/watch) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d) \u2022 [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)\n   *\n   * @param names - an array of field names\n   * @param defaultValue - defaultValues for the entire form\n   *\n   * @returns return an array of field values\n   *\n   * @example\n   * ```tsx\n   * const [name, name1] = watch([\"name\", \"name1\"]);\n   * ```\n   */\n  <TFieldNames extends readonly FieldPath<TFieldValues>[]>(\n    names: readonly [...TFieldNames],\n    defaultValue?: DeepPartial<TFieldValues>,\n  ): FieldPathValues<TFieldValues, TFieldNames>;\n  /**\n   * Watch and subscribe to a single field used outside of render.\n   *\n   * @remarks\n   * [API](https://react-hook-form.com/docs/useform/watch) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d) \u2022 [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)\n   *\n   * @param name - the path name to the form field value.\n   * @param defaultValue - defaultValues for the entire form\n   *\n   * @returns return the single field value\n   *\n   * @example\n   * ```tsx\n   * const name = watch(\"name\");\n   * ```\n   */\n  <TFieldName extends FieldPath<TFieldValues>>(\n    name: TFieldName,\n    defaultValue?: FieldPathValue<TFieldValues, TFieldName>,\n  ): FieldPathValue<TFieldValues, TFieldName>;\n  /**\n   * Subscribe to field update/change without trigger re-render\n   *\n   * @remarks\n   * [API](https://react-hook-form.com/docs/useform/watch) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d) \u2022 [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)\n   *\n   * @param callback - call back function to subscribe all fields change and return unsubscribe function\n   * @param defaultValues - defaultValues for the entire form\n   *\n   * @returns unsubscribe function\n   *\n   * @example\n   * ```tsx\n   * useEffect(() => {\n   *   const { unsubscribe } = watch((value) => {\n   *     console.log(value);\n   *   });\n   *   return () => unsubscribe();\n   * }, [watch])\n   * ```\n   */\n  (\n    callback: WatchObserver<TFieldValues>,\n    defaultValues?: DeepPartial<TFieldValues>,\n  ): Subscription;\n};\n\n/**\n * Trigger field or form validation\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/trigger) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-triggervalidation-forked-xs7hl) \u2022 [Video](https://www.youtube.com/watch?v=-bcyJCDjksE)\n *\n * @param name - provide empty argument will trigger the entire form validation, an array of field names will validate an array of fields, and a single field name will only trigger that field's validation.\n * @param options - should focus on the error field\n *\n * @returns validation result\n *\n * @example\n * ```tsx\n * useEffect(() => {\n *   trigger();\n * }, [trigger])\n *\n * <button onClick={async () => {\n *   const result = await trigger(); // result will be a boolean value\n * }}>\n *  trigger\n *  </button>\n * ```\n */\nexport type UseFormTrigger<TFieldValues extends FieldValues> = (\n  name?:\n    | FieldPath<TFieldValues>\n    | FieldPath<TFieldValues>[]\n    | readonly FieldPath<TFieldValues>[],\n  options?: TriggerConfig,\n) => Promise<boolean>;\n\n/**\n * Clear the entire form errors.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/clearerrors) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-clearerrors-w3ymx)\n *\n * @param name - the path name to the form field value.\n *\n * @example\n * Clear all errors\n * ```tsx\n * clearErrors(); // clear the entire form error\n * clearErrors([\"name\", \"name1\"]) // clear an array of fields' error\n * clearErrors(\"name2\"); // clear a single field error\n * ```\n */\nexport type UseFormClearErrors<TFieldValues extends FieldValues> = (\n  name?:\n    | FieldPath<TFieldValues>\n    | FieldPath<TFieldValues>[]\n    | readonly FieldPath<TFieldValues>[]\n    | `root.${string}`\n    | 'root',\n) => void;\n\n/**\n * Set a single field value, or a group of fields value.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/setvalue) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-setvalue-8z9hx) \u2022 [Video](https://www.youtube.com/watch?v=qpv51sCH3fI)\n *\n * @param name - the path name to the form field value.\n * @param value - field value\n * @param options - should validate or update form state\n *\n * @example\n * ```tsx\n * // Update a single field\n * setValue('name', 'value', {\n *   shouldValidate: true, // trigger validation\n *   shouldTouch: true, // update touched fields form state\n *   shouldDirty: true, // update dirty and dirty fields form state\n * });\n *\n * // Update a group fields\n * setValue('root', {\n *   a: 'test', // setValue('root.a', 'data')\n *   b: 'test1', // setValue('root.b', 'data')\n * });\n *\n * // Update a nested object field\n * setValue('select', { label: 'test', value: 'Test' });\n * ```\n */\nexport type UseFormSetValue<TFieldValues extends FieldValues> = <\n  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(\n  name: TFieldName,\n  value: FieldPathValue<TFieldValues, TFieldName>,\n  options?: SetValueConfig,\n) => void;\n\n/**\n * Set an error for the field. When set an error which is not associated to a field then manual `clearErrors` invoke is required.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/seterror) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-seterror-nfxxu) \u2022 [Video](https://www.youtube.com/watch?v=raMqvE0YyIY)\n *\n * @param name - the path name to the form field value.\n * @param error - an error object which contains type and optional message\n * @param options - whether or not to focus on the field\n *\n * @example\n * ```tsx\n * // when the error is not associated with any fields, `clearError` will need to invoke to clear the error\n * const onSubmit = () => setError(\"serverError\", { type: \"server\", message: \"Error occurred\"})\n *\n * <button onClick={() => setError(\"name\", { type: \"min\" })} />\n *\n * // focus on the input after setting the error\n * <button onClick={() => setError(\"name\", { type: \"max\" }, { shouldFocus: true })} />\n * ```\n */\nexport type UseFormSetError<TFieldValues extends FieldValues> = (\n  name: FieldPath<TFieldValues> | `root.${string}` | 'root',\n  error: ErrorOption,\n  options?: {\n    shouldFocus: boolean;\n  },\n) => void;\n\n/**\n * Unregister a field reference and remove its value.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/unregister) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-unregister-4k2ey) \u2022 [Video](https://www.youtube.com/watch?v=TM99g_NW5Gk&feature=emb_imp_woyt)\n *\n * @param name - the path name to the form field value.\n * @param options - keep form state options\n *\n * @example\n * ```tsx\n * register(\"name\", { required: true })\n *\n * <button onClick={() => unregister(\"name\")} />\n * // there are various keep options to retain formState\n * <button onClick={() => unregister(\"name\", { keepErrors: true })} />\n * ```\n */\nexport type UseFormUnregister<TFieldValues extends FieldValues> = (\n  name?:\n    | FieldPath<TFieldValues>\n    | FieldPath<TFieldValues>[]\n    | readonly FieldPath<TFieldValues>[],\n  options?: Omit<\n    KeepStateOptions,\n    | 'keepIsSubmitted'\n    | 'keepSubmitCount'\n    | 'keepValues'\n    | 'keepDefaultValues'\n    | 'keepErrors'\n  > & { keepValue?: boolean; keepDefaultValue?: boolean; keepError?: boolean },\n) => void;\n\n/**\n * Validate the entire form. Handle submit and error callback.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/handlesubmit) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-handlesubmit-ts-v7-lcrtu) \u2022 [Video](https://www.youtube.com/watch?v=KzcPKB9SOEk)\n *\n * @param onValid - callback function invoked after form pass validation\n * @param onInvalid - callback function invoked when form failed validation\n *\n * @returns callback - return callback function\n *\n * @example\n * ```tsx\n * const onSubmit = (data) => console.log(data);\n * const onError = (error) => console.log(error);\n *\n * <form onSubmit={handleSubmit(onSubmit, onError)} />\n * ```\n */\nexport type UseFormHandleSubmit<\n  TFieldValues extends FieldValues,\n  TTransformedValues = TFieldValues,\n> = (\n  onValid: SubmitHandler<TTransformedValues>,\n  onInvalid?: SubmitErrorHandler<TFieldValues>,\n) => (e?: React.BaseSyntheticEvent) => Promise<void>;\n\n/**\n * Reset a field state and reference.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/resetfield) \u2022 [Demo](https://codesandbox.io/s/priceless-firefly-d0kuv) \u2022 [Video](https://www.youtube.com/watch?v=IdLFcNaEFEo)\n *\n * @param name - the path name to the form field value.\n * @param options - keep form state options\n *\n * @example\n * ```tsx\n * <input {...register(\"firstName\", { required: true })} />\n * <button type=\"button\" onClick={() => resetField(\"firstName\"))}>Reset</button>\n * ```\n */\nexport type UseFormResetField<TFieldValues extends FieldValues> = <\n  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(\n  name: TFieldName,\n  options?: Partial<{\n    keepDirty: boolean;\n    keepTouched: boolean;\n    keepError: boolean;\n    defaultValue: FieldPathValue<TFieldValues, TFieldName>;\n  }>,\n) => void;\n\ntype ResetAction<TFieldValues> = (formValues: TFieldValues) => TFieldValues;\n\n/**\n * Reset at the entire form state.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform/reset) \u2022 [Demo](https://codesandbox.io/s/react-hook-form-reset-v7-ts-pu901) \u2022 [Video](https://www.youtube.com/watch?v=qmCLBjyPwVk)\n *\n * @param values - the entire form values to be reset\n * @param keepStateOptions - keep form state options\n *\n * @example\n * ```tsx\n * useEffect(() => {\n *   // reset the entire form after component mount or form defaultValues is ready\n *   reset({\n *     fieldA: \"test\"\n *     fieldB: \"test\"\n *   });\n * }, [reset])\n *\n * // reset by combine with existing form values\n * reset({\n *   ...getValues(),\n *  fieldB: \"test\"\n *});\n *\n * // reset and keep form state\n * reset({\n *   ...getValues(),\n *}, {\n *   keepErrors: true,\n *   keepDirty: true\n *});\n * ```\n */\nexport type UseFormReset<TFieldValues extends FieldValues> = (\n  values?:\n    | DefaultValues<TFieldValues>\n    | TFieldValues\n    | ResetAction<TFieldValues>,\n  keepStateOptions?: KeepStateOptions,\n) => void;\n\nexport type WatchInternal<TFieldValues> = (\n  fieldNames?: InternalFieldName | InternalFieldName[],\n  defaultValue?: DeepPartial<TFieldValues>,\n  isMounted?: boolean,\n  isGlobal?: boolean,\n) =>\n  | FieldPathValue<FieldValues, InternalFieldName>\n  | FieldPathValues<FieldValues, InternalFieldName[]>;\n\nexport type GetIsDirty = <TName extends InternalFieldName, TData>(\n  name?: TName,\n  data?: TData,\n) => boolean;\n\nexport type FormStateSubjectRef<TFieldValues extends FieldValues> = Subject<\n  Partial<FormState<TFieldValues>> & {\n    name?: InternalFieldName;\n    values?: TFieldValues;\n    type?: EventType;\n  }\n>;\n\nexport type Subjects<TFieldValues extends FieldValues = FieldValues> = {\n  array: Subject<{\n    name?: InternalFieldName;\n    values?: FieldValues;\n  }>;\n  state: FormStateSubjectRef<TFieldValues>;\n};\n\nexport type Names = {\n  mount: InternalNameSet;\n  unMount: InternalNameSet;\n  disabled: InternalNameSet;\n  array: InternalNameSet;\n  watch: InternalNameSet;\n  focus?: InternalFieldName;\n  watchAll?: boolean;\n};\n\nexport type BatchFieldArrayUpdate = <\n  T extends Function,\n  TFieldValues extends FieldValues,\n  TFieldArrayName extends\n    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,\n>(\n  name: InternalFieldName,\n  updatedFieldArrayValues?: Partial<\n    FieldArray<TFieldValues, TFieldArrayName>\n  >[],\n  method?: T,\n  args?: Partial<{\n    argA: unknown;\n    argB: unknown;\n  }>,\n  shouldSetValue?: boolean,\n  shouldUpdateFieldsAndErrors?: boolean,\n) => void;\n\nexport type FromSubscribe<TFieldValues extends FieldValues> = (payload: {\n  name?: string;\n  formState?: Partial<ReadFormState>;\n  callback: (\n    data: Partial<FormState<TFieldValues>> & { values: TFieldValues },\n  ) => void;\n  exact?: boolean;\n  reRenderRoot?: boolean;\n}) => () => void;\n\nexport type Control<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext = any,\n  TTransformedValues = TFieldValues,\n> = {\n  _subjects: Subjects<TFieldValues>;\n  _removeUnmounted: Noop;\n  _names: Names;\n  _state: {\n    mount: boolean;\n    action: boolean;\n    watch: boolean;\n  };\n  _reset: UseFormReset<TFieldValues>;\n  _options: UseFormProps<TFieldValues, TContext, TTransformedValues>;\n  _getDirty: GetIsDirty;\n  _resetDefaultValues: Noop;\n  _formState: FormState<TFieldValues>;\n  _setValid: (shouldUpdateValid?: boolean) => void;\n  _fields: FieldRefs;\n  _formValues: FieldValues;\n  _proxyFormState: ReadFormState;\n  _defaultValues: Partial<DefaultValues<TFieldValues>>;\n  _getWatch: WatchInternal<TFieldValues>;\n  _setFieldArray: BatchFieldArrayUpdate;\n  _getFieldArray: <TFieldArrayValues>(\n    name: InternalFieldName,\n  ) => Partial<TFieldArrayValues>[];\n  _setErrors: (errors: FieldErrors<TFieldValues>) => void;\n  _setDisabledField: (props: {\n    disabled?: boolean;\n    name: FieldName<any>;\n  }) => void;\n  _runSchema: (names: InternalFieldName[]) => Promise<{ errors: FieldErrors }>;\n  _disableForm: (disabled?: boolean) => void;\n  _subscribe: FromSubscribe<TFieldValues>;\n  register: UseFormRegister<TFieldValues>;\n  handleSubmit: UseFormHandleSubmit<TFieldValues, TTransformedValues>;\n  unregister: UseFormUnregister<TFieldValues>;\n  getFieldState: UseFormGetFieldState<TFieldValues>;\n  setError: UseFormSetError<TFieldValues>;\n};\n\nexport type WatchObserver<TFieldValues extends FieldValues> = (\n  value: DeepPartial<TFieldValues>,\n  info: {\n    name?: FieldPath<TFieldValues>;\n    type?: EventType;\n    values?: unknown;\n  },\n) => void;\n\nexport type UseFormReturn<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext = any,\n  TTransformedValues = TFieldValues,\n> = {\n  watch: UseFormWatch<TFieldValues>;\n  getValues: UseFormGetValues<TFieldValues>;\n  getFieldState: UseFormGetFieldState<TFieldValues>;\n  setError: UseFormSetError<TFieldValues>;\n  clearErrors: UseFormClearErrors<TFieldValues>;\n  setValue: UseFormSetValue<TFieldValues>;\n  trigger: UseFormTrigger<TFieldValues>;\n  formState: FormState<TFieldValues>;\n  resetField: UseFormResetField<TFieldValues>;\n  reset: UseFormReset<TFieldValues>;\n  handleSubmit: UseFormHandleSubmit<TFieldValues, TTransformedValues>;\n  unregister: UseFormUnregister<TFieldValues>;\n  control: Control<TFieldValues, TContext, TTransformedValues>;\n  register: UseFormRegister<TFieldValues>;\n  setFocus: UseFormSetFocus<TFieldValues>;\n  subscribe: UseFromSubscribe<TFieldValues>;\n};\n\nexport type UseFormStateProps<\n  TFieldValues extends FieldValues,\n  TTransformedValues = TFieldValues,\n> = Partial<{\n  control?: Control<TFieldValues, any, TTransformedValues>;\n  disabled?: boolean;\n  name?:\n    | FieldPath<TFieldValues>\n    | FieldPath<TFieldValues>[]\n    | readonly FieldPath<TFieldValues>[];\n  exact?: boolean;\n}>;\n\nexport type UseFormStateReturn<TFieldValues extends FieldValues> =\n  FormState<TFieldValues>;\n\nexport type UseWatchProps<TFieldValues extends FieldValues = FieldValues> = {\n  defaultValue?: unknown;\n  disabled?: boolean;\n  name?:\n    | FieldPath<TFieldValues>\n    | FieldPath<TFieldValues>[]\n    | readonly FieldPath<TFieldValues>[];\n  control?: Control<TFieldValues>;\n  exact?: boolean;\n};\n\nexport type FormProviderProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext = any,\n  TTransformedValues = TFieldValues,\n> = {\n  children: React.ReactNode | React.ReactNode[];\n} & UseFormReturn<TFieldValues, TContext, TTransformedValues>;\n\nexport type FormProps<\n  TFieldValues extends FieldValues,\n  TTransformedValues = TFieldValues,\n> = Omit<React.FormHTMLAttributes<HTMLFormElement>, 'onError' | 'onSubmit'> &\n  Partial<{\n    control: Control<TFieldValues, any, TTransformedValues>;\n    headers: Record<string, string>;\n    validateStatus: (status: number) => boolean;\n    onError: ({\n      response,\n      error,\n    }:\n      | {\n          response: Response;\n          error?: undefined;\n        }\n      | {\n          response?: undefined;\n          error: unknown;\n        }) => void;\n    onSuccess: ({ response }: { response: Response }) => void;\n    onSubmit: FormSubmitHandler<TTransformedValues>;\n    method: 'post' | 'put' | 'delete';\n    children: React.ReactNode | React.ReactNode[];\n    render: (props: {\n      submit: (e?: React.FormEvent) => void;\n    }) => React.ReactNode | React.ReactNode[];\n    encType:\n      | 'application/x-www-form-urlencoded'\n      | 'multipart/form-data'\n      | 'text/plain'\n      | 'application/json';\n  }>;\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:12:58"}, {"role": "assistant", "content": "```ts\nimport skipValidation from '../../logic/skipValidation';\n\ndescribe('should skip validation', () => {\n  it('when is onChange mode and blur event', () => {\n    expect(\n      skipValidation(\n        false,\n        false,\n        false,\n        {\n          isOnChange: true,\n          isOnBlur: false,\n        },\n        {\n          isOnChange: true,\n          isOnBlur: true,\n          isOnTouch: false,\n        },\n      ),\n    ).toBeTruthy();\n  });\n\n  it('when is onSubmit mode and re-validate on Submit', () => {\n    expect(\n      skipValidation(\n        false,\n        false,\n        false,\n        {\n          isOnChange: false,\n          isOnBlur: false,\n        },\n        {\n          isOnChange: false,\n          isOnBlur: false,\n          isOnTouch: false,\n        },\n      ),\n    ).toBeTruthy();\n  });\n\n  it('when is onSubmit mode and not submitted yet', () => {\n    expect(\n      skipValidation(\n        false,\n        false,\n        false,\n        {\n          isOnChange: true,\n          isOnBlur: false,\n        },\n        {\n          isOnChange: false,\n          isOnBlur: false,\n          isOnTouch: false,\n        },\n      ),\n    ).toBeTruthy();\n  });\n\n  it('when on blur mode, not blur event and error gets clear', () => {\n    expect(\n      skipValidation(\n        false,\n        false,\n        false,\n        {\n          isOnChange: true,\n          isOnBlur: false,\n        },\n        {\n          isOnChange: false,\n          isOnBlur: true,\n          isOnTouch: false,\n        },\n      ),\n    ).toBeTruthy();\n  });\n\n  it('when re-validate mode is blur, not blur event and has error ', () => {\n    expect(\n      skipValidation(\n        false,\n        false,\n        true,\n        {\n          isOnChange: true,\n          isOnBlur: true,\n        },\n        {\n          isOnChange: false,\n          isOnBlur: false,\n          isOnTouch: false,\n        },\n      ),\n    ).toBeTruthy();\n  });\n\n  it('when is re-validate mode on submit and have error', () => {\n    expect(\n      skipValidation(\n        false,\n        false,\n        true,\n        {\n          isOnChange: false,\n          isOnBlur: false,\n        },\n        {\n          isOnChange: false,\n          isOnBlur: false,\n          isOnTouch: false,\n        },\n      ),\n    ).toBeTruthy();\n  });\n});\n\ndescribe('should validate the input', () => {\n  it('when form is submitted and there is error', () => {\n    expect(\n      skipValidation(\n        false,\n        false,\n        true,\n        {\n          isOnChange: true,\n          isOnBlur: false,\n        },\n        {\n          isOnChange: false,\n          isOnBlur: false,\n          isOnTouch: false,\n        },\n      ),\n    ).toBeFalsy();\n  });\n\n  it('when mode is under all', () => {\n    expect(\n      skipValidation(\n        false,\n        false,\n        false,\n        {\n          isOnChange: false,\n          isOnBlur: false,\n        },\n        {\n          isOnChange: false,\n          isOnBlur: false,\n          isOnAll: true,\n        },\n      ),\n    ).toBeFalsy();\n  });\n\n  it('when user blur input and there is no more error', () => {\n    expect(\n      skipValidation(\n        true,\n        false,\n        false,\n        {\n          isOnChange: true,\n          isOnBlur: false,\n        },\n        {\n          isOnChange: false,\n          isOnBlur: true,\n          isOnTouch: false,\n        },\n      ),\n    ).toBeFalsy();\n  });\n\n  it('when user blur and there is an error', () => {\n    expect(\n      skipValidation(\n        true,\n        false,\n        false,\n        {\n          isOnChange: true,\n          isOnBlur: false,\n        },\n        {\n          isOnChange: false,\n          isOnBlur: true,\n          isOnTouch: false,\n        },\n      ),\n    ).toBeFalsy();\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\animationFrameProvider-spec.ts\\animationFrameProvider-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { Subscription } from '@rxjs/observable';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n\n### Source File Dependency Files Content\n### Dependency File: empty.txt\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:04"}, {"role": "assistant", "content": "```ts\n/** @prettier */\nimport { expect } from 'chai';\nimport { animationFrameProvider } from 'rxjs/internal/scheduler/animationFrameProvider';\n\ndescribe('animationFrameProvider', () => {\n  const originalRequest = global.requestAnimationFrame;\n  const originalCancel = global.cancelAnimationFrame;\n\n  afterEach(() => {\n    global.requestAnimationFrame = originalRequest;\n    global.cancelAnimationFrame = originalCancel;\n  });\n\n  it('should be monkey patchable', () => {\n    let requestCalled = false;\n    let cancelCalled = false;\n\n    global.requestAnimationFrame = () => {\n      requestCalled = true;\n      return 0;\n    };\n    global.cancelAnimationFrame = () => {\n      cancelCalled = true;\n    };\n\n    const handle = animationFrameProvider.requestAnimationFrame(() => {\n      /* noop */\n    });\n    animationFrameProvider.cancelAnimationFrame(handle);\n\n    expect(requestCalled).to.be.true;\n    expect(cancelCalled).to.be.true;\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\AnimationFrameScheduler-spec.ts\\AnimationFrameScheduler-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type { AsyncAction } from './AsyncAction.js';\nimport { AsyncScheduler } from './AsyncScheduler.js';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: AsapAction.ts\nimport { AsyncAction } from './AsyncAction.js';\nimport type { AsapScheduler } from './AsapScheduler.js';\nimport type { SchedulerAction } from '../types.js';\nimport { immediateProvider } from './immediateProvider.js';\nimport type { TimerHandle } from './timerHandle.js';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n\n\n### Dependency File: AsapScheduler.ts\nimport type { AsyncAction } from './AsyncAction.js';\nimport { AsyncScheduler } from './AsyncScheduler.js';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:04"}, {"role": "assistant", "content": "```ts\n/** @prettier */\nimport { expect } from 'chai';\nimport * as sinon from 'sinon';\nimport type { Subscription} from 'rxjs';\nimport { animationFrameScheduler, merge } from 'rxjs';\nimport { delay } from 'rxjs/operators';\nimport { TestScheduler } from 'rxjs/testing';\nimport { observableMatcher } from '../helpers/observableMatcher';\nimport { animationFrameProvider } from 'rxjs/internal/scheduler/animationFrameProvider';\nimport { intervalProvider } from 'rxjs/internal/scheduler/intervalProvider';\n\nconst animationFrame = animationFrameScheduler;\n\n/** @test {Scheduler} */\ndescribe('Scheduler.animationFrame', () => {\n  let testScheduler: TestScheduler;\n\n  beforeEach(() => {\n    testScheduler = new TestScheduler(observableMatcher);\n  });\n\n  it('should exist', () => {\n    expect(animationFrame).exist;\n  });\n\n  it('should act like the async scheduler if delay > 0', () => {\n    testScheduler.run(({ animate, cold, expectObservable, time }) => {\n      animate('         ----------x--');\n      const a = cold('  a            ');\n      const ta = time(' ----|        ');\n      const b = cold('  b            ');\n      const tb = time(' --------|    ');\n      const expected = '----a---b----';\n\n      const result = merge(a.pipe(delay(ta, animationFrame)), b.pipe(delay(tb, animationFrame)));\n      expectObservable(result).toBe(expected);\n    });\n  });\n\n  it('should cancel animationFrame actions when delay > 0', () => {\n    testScheduler.run(({ animate, cold, expectObservable, flush, time }) => {\n      const requestSpy = sinon.spy(animationFrameProvider, 'requestAnimationFrame');\n      const setSpy = sinon.spy(intervalProvider, 'setInterval');\n      const clearSpy = sinon.spy(intervalProvider, 'clearInterval');\n\n      animate('         ----------x--');\n      const a = cold('  a            ');\n      const ta = time(' ----|        ');\n      const subs = '    ^-!          ';\n      const expected = '-------------';\n\n      const result = merge(a.pipe(delay(ta, animationFrame)));\n      expectObservable(result, subs).toBe(expected);\n\n      flush();\n      expect(requestSpy).to.have.not.been.called;\n      expect(setSpy).to.have.been.calledOnce;\n      expect(clearSpy).to.have.been.calledOnce;\n      requestSpy.restore();\n      setSpy.restore();\n      clearSpy.restore();\n    });\n  });\n\n  it('should schedule an action to happen later', (done) => {\n    let actionHappened = false;\n    animationFrame.schedule(() => {\n      actionHappened = true;\n      done();\n    });\n    if (actionHappened) {\n      done(new Error('Scheduled action happened synchronously'));\n    }\n  });\n\n  it('should execute recursively scheduled actions in separate asynchronous contexts', (done) => {\n    let syncExec1 = true;\n    let syncExec2 = true;\n    animationFrame.schedule(\n      function (index) {\n        if (index === 0) {\n          this.schedule(1);\n          animationFrame.schedule(() => {\n            syncExec1 = false;\n          });\n        } else if (index === 1) {\n          this.schedule(2);\n          animationFrame.schedule(() => {\n            syncExec2 = false;\n          });\n        } else if (index === 2) {\n          this.schedule(3);\n        } else if (index === 3) {\n          if (!syncExec1 && !syncExec2) {\n            done();\n          } else {\n            done(new Error('Execution happened synchronously.'));\n          }\n        }\n      },\n      0,\n      0\n    );\n  });\n\n  it('should cancel the animation frame if all scheduled actions unsubscribe before it executes', (done) => {\n    let animationFrameExec1 = false;\n    let animationFrameExec2 = false;\n    const action1 = animationFrame.schedule(() => {\n      animationFrameExec1 = true;\n    });\n    const action2 = animationFrame.schedule(() => {\n      animationFrameExec2 = true;\n    });\n    expect(animationFrame._scheduled).to.exist;\n    expect(animationFrame.actions.length).to.equal(2);\n    action1.unsubscribe();\n    action2.unsubscribe();\n    expect(animationFrame.actions.length).to.equal(0);\n    expect(animationFrame._scheduled).to.equal(undefined);\n    animationFrame.schedule(() => {\n      expect(animationFrameExec1).to.equal(false);\n      expect(animationFrameExec2).to.equal(false);\n      done();\n    });\n  });\n\n  it('should execute the rest of the scheduled actions if the first action is canceled', (done) => {\n    let actionHappened = false;\n    let secondSubscription: Subscription | null = null;\n\n    const firstSubscription = animationFrame.schedule(() => {\n      actionHappened = true;\n      if (secondSubscription) {\n        secondSubscription.unsubscribe();\n      }\n      done(new Error('The first action should not have executed.'));\n    });\n\n    secondSubscription = animationFrame.schedule(() => {\n      if (!actionHappened) {\n        done();\n      }\n    });\n\n    if (actionHappened) {\n      done(new Error('Scheduled action happened synchronously'));\n    } else {\n      firstSubscription.unsubscribe();\n    }\n  });\n\n  it('should not execute rescheduled actions when flushing', (done) => {\n    let flushCount = 0;\n    const scheduledIndices: number[] = [];\n\n    const originalFlush = animationFrame.flush;\n    animationFrame.flush = (...args) => {\n      ++flushCount;\n      originalFlush.apply(animationFrame, args);\n      if (flushCount === 2) {\n        animationFrame.flush = originalFlush;\n        try {\n          expect(scheduledIndices).to.deep.equal([0, 1]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      }\n    };\n\n    animationFrame.schedule(\n      function (index) {\n        if (flushCount < 2) {\n          this.schedule(index! + 1);\n          scheduledIndices.push(index! + 1);\n        }\n      },\n      0,\n      0\n    );\n    scheduledIndices.push(0);\n  });\n\n  it('should execute actions scheduled when flushing in a subsequent flush', (done) => {\n    const sandbox = sinon.createSandbox();\n    const stubFlush = sandbox.stub(animationFrameScheduler, 'flush').callThrough();\n\n    animationFrameScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n      animationFrameScheduler.schedule(() => {\n        expect(stubFlush).to.have.callCount(2);\n        sandbox.restore();\n        done();\n      });\n    });\n    animationFrameScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n    });\n  });\n\n  it('should execute actions scheduled when flushing in a subsequent flush when some actions are unsubscribed', (done) => {\n    const sandbox = sinon.createSandbox();\n    const stubFlush = sandbox.stub(animationFrameScheduler, 'flush').callThrough();\n\n    // eslint-disable-next-line prefer-const\n    let b: Subscription;\n\n    animationFrameScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n      animationFrameScheduler.schedule(() => {\n        expect(stubFlush).to.have.callCount(2);\n        sandbox.restore();\n        done();\n      });\n      b.unsubscribe();\n    });\n    b = animationFrameScheduler.schedule(() => {\n      done(new Error('Unexpected execution of b'));\n    });\n  });\n\n  it('should properly cancel an unnecessary flush', (done) => {\n    const sandbox = sinon.createSandbox();\n    const cancelAnimationFrameStub = sandbox.stub(animationFrameProvider, 'cancelAnimationFrame').callThrough();\n\n    animationFrameScheduler.schedule(() => {\n      expect(animationFrameScheduler.actions).to.have.length(1);\n      const c = animationFrameScheduler.schedule(() => {\n        done(new Error('Unexpected execution of c'));\n      });\n      expect(animationFrameScheduler.actions).to.have.length(2);\n      // What we're testing here is that the unsubscription of action c effects\n      // the cancellation of the animation frame in a scenario in which the\n      // actions queue is not empty - it contains action b.\n      c.unsubscribe();\n      expect(animationFrameScheduler.actions).to.have.length(1);\n      expect(cancelAnimationFrameStub).to.have.callCount(1);\n    });\n    animationFrameScheduler.schedule(() => {\n      sandbox.restore();\n      done();\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\AsapScheduler-spec.ts\\AsapScheduler-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type { AsyncAction } from './AsyncAction.js';\nimport { AsyncScheduler } from './AsyncScheduler.js';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: AsapAction.ts\nimport { AsyncAction } from './AsyncAction.js';\nimport type { AsapScheduler } from './AsapScheduler.js';\nimport type { SchedulerAction } from '../types.js';\nimport { immediateProvider } from './immediateProvider.js';\nimport type { TimerHandle } from './timerHandle.js';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n\n\n### Dependency File: AsapScheduler.ts\nimport type { AsyncAction } from './AsyncAction.js';\nimport { AsyncScheduler } from './AsyncScheduler.js';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:04"}, {"role": "assistant", "content": "```ts\n/** @prettier  */\nimport { expect } from 'chai';\nimport * as sinon from 'sinon';\nimport type { Subscription, SchedulerAction} from 'rxjs';\nimport { asapScheduler, merge } from 'rxjs';\nimport { delay } from 'rxjs/operators';\nimport { TestScheduler } from 'rxjs/testing';\nimport { observableMatcher } from '../helpers/observableMatcher';\nimport { immediateProvider } from 'rxjs/internal/scheduler/immediateProvider';\nimport { intervalProvider } from 'rxjs/internal/scheduler/intervalProvider';\n\nconst asap = asapScheduler;\n\n/** @test {Scheduler} */\ndescribe('Scheduler.asap', () => {\n  let testScheduler: TestScheduler;\n\n  beforeEach(() => {\n    testScheduler = new TestScheduler(observableMatcher);\n  });\n\n  it('should exist', () => {\n    expect(asap).exist;\n  });\n\n  it('should act like the async scheduler if delay > 0', () => {\n    testScheduler.run(({ cold, expectObservable, time }) => {\n      const a = cold('  a            ');\n      const ta = time(' ----|        ');\n      const b = cold('  b            ');\n      const tb = time(' --------|    ');\n      const expected = '----a---b----';\n\n      const result = merge(a.pipe(delay(ta, asap)), b.pipe(delay(tb, asap)));\n      expectObservable(result).toBe(expected);\n    });\n  });\n\n  it('should cancel asap actions when delay > 0', () => {\n    testScheduler.run(({ cold, expectObservable, flush, time }) => {\n      const sandbox = sinon.createSandbox();\n      const setImmediateSpy = sandbox.spy(immediateProvider, 'setImmediate');\n      const setSpy = sandbox.spy(intervalProvider, 'setInterval');\n      const clearSpy = sandbox.spy(intervalProvider, 'clearInterval');\n\n      const a = cold('  a            ');\n      const ta = time(' ----|        ');\n      const subs = '    ^-!          ';\n      const expected = '-------------';\n\n      const result = merge(a.pipe(delay(ta, asap)));\n      expectObservable(result, subs).toBe(expected);\n\n      flush();\n      expect(setImmediateSpy).to.have.not.been.called;\n      expect(setSpy).to.have.been.calledOnce;\n      expect(clearSpy).to.have.been.calledOnce;\n      sandbox.restore();\n    });\n  });\n\n  it('should reuse the interval for recursively scheduled actions with the same delay', () => {\n    const sandbox = sinon.createSandbox();\n    const fakeTimer = sandbox.useFakeTimers();\n    // callThrough is missing from the declarations installed by the typings tool in stable\n    const stubSetInterval = (<any>sandbox.stub(global, 'setInterval')).callThrough();\n    const period = 50;\n    const state = { index: 0, period };\n    type State = typeof state;\n    function dispatch(this: SchedulerAction<State>, state: State): void {\n      state.index += 1;\n      if (state.index < 3) {\n        this.schedule(state, state.period);\n      }\n    }\n    asap.schedule(dispatch as any, period, state);\n    expect(state).to.have.property('index', 0);\n    expect(stubSetInterval).to.have.property('callCount', 1);\n    fakeTimer.tick(period);\n    expect(state).to.have.property('index', 1);\n    expect(stubSetInterval).to.have.property('callCount', 1);\n    fakeTimer.tick(period);\n    expect(state).to.have.property('index', 2);\n    expect(stubSetInterval).to.have.property('callCount', 1);\n    sandbox.restore();\n  });\n\n  it('should not reuse the interval for recursively scheduled actions with a different delay', () => {\n    const sandbox = sinon.createSandbox();\n    const fakeTimer = sandbox.useFakeTimers();\n    // callThrough is missing from the declarations installed by the typings tool in stable\n    const stubSetInterval = (<any>sandbox.stub(global, 'setInterval')).callThrough();\n    const period = 50;\n    const state = { index: 0, period };\n    type State = typeof state;\n    function dispatch(this: SchedulerAction<State>, state: State): void {\n      state.index += 1;\n      state.period -= 1;\n      if (state.index < 3) {\n        this.schedule(state, state.period);\n      }\n    }\n    asap.schedule(dispatch as any, period, state);\n    expect(state).to.have.property('index', 0);\n    expect(stubSetInterval).to.have.property('callCount', 1);\n    fakeTimer.tick(period);\n    expect(state).to.have.property('index', 1);\n    expect(stubSetInterval).to.have.property('callCount', 2);\n    fakeTimer.tick(period);\n    expect(state).to.have.property('index', 2);\n    expect(stubSetInterval).to.have.property('callCount', 3);\n    sandbox.restore();\n  });\n\n  it('should schedule an action to happen later', (done) => {\n    let actionHappened = false;\n    asap.schedule(() => {\n      actionHappened = true;\n      done();\n    });\n    if (actionHappened) {\n      done(new Error('Scheduled action happened synchronously'));\n    }\n  });\n\n  it('should execute recursively scheduled actions in separate asynchronous contexts', (done) => {\n    let syncExec1 = true;\n    let syncExec2 = true;\n    asap.schedule(\n      function (index) {\n        if (index === 0) {\n          this.schedule(1);\n          asap.schedule(() => {\n            syncExec1 = false;\n          });\n        } else if (index === 1) {\n          this.schedule(2);\n          asap.schedule(() => {\n            syncExec2 = false;\n          });\n        } else if (index === 2) {\n          this.schedule(3);\n        } else if (index === 3) {\n          if (!syncExec1 && !syncExec2) {\n            done();\n          } else {\n            done(new Error('Execution happened synchronously.'));\n          }\n        }\n      },\n      0,\n      0\n    );\n  });\n\n  it('should cancel the setImmediate if all scheduled actions unsubscribe before it executes', (done) => {\n    let asapExec1 = false;\n    let asapExec2 = false;\n    const action1 = asap.schedule(() => {\n      asapExec1 = true;\n    });\n    const action2 = asap.schedule(() => {\n      asapExec2 = true;\n    });\n    expect(asap._scheduled).to.exist;\n    expect(asap.actions.length).to.equal(2);\n    action1.unsubscribe();\n    action2.unsubscribe();\n    expect(asap.actions.length).to.equal(0);\n    expect(asap._scheduled).to.equal(undefined);\n    asap.schedule(() => {\n      expect(asapExec1).to.equal(false);\n      expect(asapExec2).to.equal(false);\n      done();\n    });\n  });\n\n  it('should execute the rest of the scheduled actions if the first action is canceled', (done) => {\n    let actionHappened = false;\n    let secondSubscription: Subscription | null = null;\n\n    const firstSubscription = asap.schedule(() => {\n      actionHappened = true;\n      if (secondSubscription) {\n        secondSubscription.unsubscribe();\n      }\n      done(new Error('The first action should not have executed.'));\n    });\n\n    secondSubscription = asap.schedule(() => {\n      if (!actionHappened) {\n        done();\n      }\n    });\n\n    if (actionHappened) {\n      done(new Error('Scheduled action happened synchronously'));\n    } else {\n      firstSubscription.unsubscribe();\n    }\n  });\n\n  it('should not execute rescheduled actions when flushing', (done) => {\n    let flushCount = 0;\n    const scheduledIndices: number[] = [];\n\n    const originalFlush = asap.flush;\n    asap.flush = (...args) => {\n      ++flushCount;\n      originalFlush.apply(asap, args);\n      if (flushCount === 2) {\n        asap.flush = originalFlush;\n        try {\n          expect(scheduledIndices).to.deep.equal([0, 1]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      }\n    };\n\n    asap.schedule(\n      function (index) {\n        if (flushCount < 2) {\n          this.schedule(index! + 1);\n          scheduledIndices.push(index! + 1);\n        }\n      },\n      0,\n      0\n    );\n    scheduledIndices.push(0);\n  });\n\n  it('should execute actions scheduled when flushing in a subsequent flush', (done) => {\n    const sandbox = sinon.createSandbox();\n    const stubFlush = sandbox.stub(asapScheduler, 'flush').callThrough();\n\n    asapScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n      asapScheduler.schedule(() => {\n        expect(stubFlush).to.have.callCount(2);\n        sandbox.restore();\n        done();\n      });\n    });\n    asapScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n    });\n  });\n\n  it('should execute actions scheduled when flushing in a subsequent flush when some actions are unsubscribed', (done) => {\n    const sandbox = sinon.createSandbox();\n    const stubFlush = sandbox.stub(asapScheduler, 'flush').callThrough();\n\n    // eslint-disable-next-line prefer-const\n    let b: Subscription;\n\n    asapScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n      asapScheduler.schedule(() => {\n        expect(stubFlush).to.have.callCount(2);\n        sandbox.restore();\n        done();\n      });\n      b.unsubscribe();\n    });\n    b = asapScheduler.schedule(() => {\n      done(new Error('Unexpected execution of b'));\n    });\n  });\n\n  it('should properly cancel an unnecessary flush', (done) => {\n    const sandbox = sinon.createSandbox();\n    const clearImmediateStub = sandbox.stub(immediateProvider, 'clearImmediate').callThrough();\n\n    let c: Subscription;\n\n    asapScheduler.schedule(() => {\n      expect(asapScheduler.actions).to.have.length(1);\n      c = asapScheduler.schedule(() => {\n        done(new Error('Unexpected execution of c'));\n      });\n      expect(asapScheduler.actions).to.have.length(2);\n      // What we're testing here is that the unsubscription of action c effects\n      // the cancellation of the microtask in a scenario in which the actions\n      // queue is not empty - it contains action b.\n      c.unsubscribe();\n      expect(asapScheduler.actions).to.have.length(1);\n      expect(clearImmediateStub).to.have.callCount(1);\n    });\n    asapScheduler.schedule(() => {\n      sandbox.restore();\n      done();\n    });\n  });\n\n  it('scheduling inside of an executing action more than once should work', (done) => {\n    const results: any[] = [];\n\n    let resolve: () => void;\n    const promise = new Promise<void>((r) => (resolve = r));\n\n    asapScheduler.schedule(() => {\n      results.push(1);\n      asapScheduler.schedule(() => {\n        results.push(2);\n      });\n      asapScheduler.schedule(() => {\n        results.push(3);\n        resolve();\n      });\n    });\n\n    promise.then(() => {\n      // This should always fire after two recursively scheduled microtasks.\n      expect(results).to.deep.equal([1, 2, 3]);\n      done();\n    });\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\AsyncSubject-spec.ts\\AsyncSubject-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { Subject } from './Subject.js';\nimport type { Subscriber } from '@rxjs/observable';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, _closed, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (_closed || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this._closed) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: Subject.ts\nimport type { Subscriber} from '@rxjs/observable';\nimport { Observable, Subscription } from '@rxjs/observable';\nimport type { Observer, SubscriptionLike } from './types.js';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  /** @internal */\n  _closed = false;\n\n  /**\n   * Will return true if this subject has been closed and is no longer accepting new values.\n   */\n  get closed() {\n    return this._closed;\n  }\n\n  private _observerCounter = 0;\n  private currentObservers = new Map<number, Observer<T>>();\n\n  /**\n   * This is used to track a known array of observers, so we don't have to\n   * clone them while iterating to prevent reentrant behaviors.\n   * (for example, what if the subject is subscribed to when nexting to an observer)\n   */\n  private observerSnapshot: Observer<T>[] | undefined;\n\n  /** @internal */\n  get observers(): Observer<T>[] {\n    return (this.observerSnapshot ??= Array.from(this.currentObservers.values()));\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  protected _clearObservers() {\n    this.currentObservers.clear();\n    this.observerSnapshot = undefined;\n  }\n\n  next(value: T) {\n    if (!this._closed) {\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (!this._closed) {\n      this.hasError = this._closed = true;\n      this.thrownError = err;\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].error(err);\n      }\n      this._clearObservers();\n    }\n  }\n\n  complete() {\n    if (!this._closed) {\n      this._closed = true;\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].complete();\n      }\n      this._clearObservers();\n    }\n  }\n\n  unsubscribe() {\n    this._closed = true;\n    this._clearObservers();\n  }\n\n  get observed() {\n    return this.currentObservers.size > 0;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    if (this.hasError || this._closed) {\n      return Subscription.EMPTY;\n    }\n    const { currentObservers } = this;\n\n    const observerId = this._observerCounter++;\n    currentObservers.set(observerId, subscriber);\n    this.observerSnapshot = undefined;\n    subscriber.add(() => {\n      currentObservers.delete(observerId);\n      this.observerSnapshot = undefined;\n    });\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, _closed } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (_closed) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return Observable that this Subject casts to.\n   */\n  asObservable(): Observable<T> {\n    return new Observable((subscriber) => this.subscribe(subscriber));\n  }\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:05"}, {"role": "assistant", "content": "```ts\nimport { expect } from 'chai';\nimport type { Observer } from 'rxjs';\nimport { AsyncSubject } from 'rxjs';\n\nclass TestObserver implements Observer<number> {\n  results: (number | string)[] = [];\n\n  next(value: number): void {\n    this.results.push(value);\n  }\n\n  error(err: any): void {\n    this.results.push(err);\n  }\n\n  complete(): void {\n    this.results.push('done');\n  }\n}\n\n/** @test {AsyncSubject} */\ndescribe('AsyncSubject', () => {\n  it('should emit the last value when complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.next(2);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal([2, 'done']);\n  });\n\n  it('should emit the last value when subscribing after complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n\n    subject.next(1);\n    subject.next(2);\n    subject.complete();\n\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal([2, 'done']);\n  });\n\n  it('should keep emitting the last value to subsequent subscriptions', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.next(2);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal([2, 'done']);\n\n    subscription.unsubscribe();\n\n    observer.results = [];\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal([2, 'done']);\n  });\n\n  it('should not emit values after complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n\n    subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.next(2);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    subject.next(3);\n    expect(observer.results).to.deep.equal([2, 'done']);\n  });\n\n  it('should not allow change value after complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const otherObserver = new TestObserver();\n    subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal([1, 'done']);\n    subject.next(2);\n    subject.subscribe(otherObserver);\n    expect(otherObserver.results).to.deep.equal([1, 'done']);\n  });\n\n  it('should not emit values if unsubscribed before complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.next(2);\n    expect(observer.results).to.deep.equal([]);\n\n    subscription.unsubscribe();\n\n    subject.next(3);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal([]);\n  });\n\n  it('should just complete if no value has been nexted into it', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    subject.subscribe(observer);\n\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal(['done']);\n  });\n\n  it('should keep emitting complete to subsequent subscriptions', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal(['done']);\n\n    subscription.unsubscribe();\n    observer.results = [];\n\n    subject.error(new Error(''));\n\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal(['done']);\n  });\n\n  it('should only error if an error is passed into it', () => {\n    const expected = new Error('bad');\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n\n    subject.error(expected);\n    expect(observer.results).to.deep.equal([expected]);\n  });\n\n  it('should keep emitting error to subsequent subscriptions', () => {\n    const expected = new Error('bad');\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n\n    subject.error(expected);\n    expect(observer.results).to.deep.equal([expected]);\n\n    subscription.unsubscribe();\n\n    observer.results = [];\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal([expected]);\n  });\n\n  it('should not allow send complete after error', () => {\n    const expected = new Error('bad');\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n\n    subject.error(expected);\n    expect(observer.results).to.deep.equal([expected]);\n\n    subscription.unsubscribe();\n\n    observer.results = [];\n\n    subject.complete();\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal([expected]);\n  });\n\n  it('should not be reentrant via complete', () => {\n    const subject = new AsyncSubject<number>();\n    let calls = 0;\n    subject.subscribe({\n      next: (value) => {\n        calls++;\n        if (calls < 2) {\n          // if this is more than 1, we're reentrant, and that's bad.\n          subject.complete();\n        }\n      },\n    });\n\n    subject.next(1);\n    subject.complete();\n\n    expect(calls).to.equal(1);\n  });\n\n  it('should not be reentrant via next', () => {\n    const subject = new AsyncSubject<number>();\n    let calls = 0;\n    subject.subscribe({\n      next: (value) => {\n        calls++;\n        if (calls < 2) {\n          // if this is more than 1, we're reentrant, and that's bad.\n          subject.next(value + 1);\n        }\n      },\n    });\n\n    subject.next(1);\n    subject.complete();\n\n    expect(calls).to.equal(1);\n  });\n\n  it('should allow reentrant subscriptions', () => {\n    const subject = new AsyncSubject<number>();\n    const results: any[] = [];\n\n    subject.subscribe({\n      next: (value) => {\n        subject.subscribe({\n          next: (value) => results.push('inner: ' + (value + value)),\n          complete: () => results.push('inner: done'),\n        });\n        results.push('outer: ' + value);\n      },\n      complete: () => results.push('outer: done'),\n    });\n\n    subject.next(1);\n    expect(results).to.deep.equal([]);\n    subject.complete();\n    expect(results).to.deep.equal(['inner: 2', 'inner: done', 'outer: 1', 'outer: done']);\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\BehaviorSubject-spec.ts\\BehaviorSubject-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport { Subject } from './Subject.js';\nimport type { Subscriber, Subscription } from '@rxjs/observable';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: Subject.ts\nimport type { Subscriber} from '@rxjs/observable';\nimport { Observable, Subscription } from '@rxjs/observable';\nimport type { Observer, SubscriptionLike } from './types.js';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  /** @internal */\n  _closed = false;\n\n  /**\n   * Will return true if this subject has been closed and is no longer accepting new values.\n   */\n  get closed() {\n    return this._closed;\n  }\n\n  private _observerCounter = 0;\n  private currentObservers = new Map<number, Observer<T>>();\n\n  /**\n   * This is used to track a known array of observers, so we don't have to\n   * clone them while iterating to prevent reentrant behaviors.\n   * (for example, what if the subject is subscribed to when nexting to an observer)\n   */\n  private observerSnapshot: Observer<T>[] | undefined;\n\n  /** @internal */\n  get observers(): Observer<T>[] {\n    return (this.observerSnapshot ??= Array.from(this.currentObservers.values()));\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  protected _clearObservers() {\n    this.currentObservers.clear();\n    this.observerSnapshot = undefined;\n  }\n\n  next(value: T) {\n    if (!this._closed) {\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (!this._closed) {\n      this.hasError = this._closed = true;\n      this.thrownError = err;\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].error(err);\n      }\n      this._clearObservers();\n    }\n  }\n\n  complete() {\n    if (!this._closed) {\n      this._closed = true;\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].complete();\n      }\n      this._clearObservers();\n    }\n  }\n\n  unsubscribe() {\n    this._closed = true;\n    this._clearObservers();\n  }\n\n  get observed() {\n    return this.currentObservers.size > 0;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    if (this.hasError || this._closed) {\n      return Subscription.EMPTY;\n    }\n    const { currentObservers } = this;\n\n    const observerId = this._observerCounter++;\n    currentObservers.set(observerId, subscriber);\n    this.observerSnapshot = undefined;\n    subscriber.add(() => {\n      currentObservers.delete(observerId);\n      this.observerSnapshot = undefined;\n    });\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, _closed } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (_closed) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return Observable that this Subject casts to.\n   */\n  asObservable(): Observable<T> {\n    return new Observable((subscriber) => this.subscribe(subscriber));\n  }\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:05"}, {"role": "assistant", "content": "```ts\nimport { expect } from 'chai';\nimport { BehaviorSubject, Subject, of } from 'rxjs';\nimport { tap, mergeMapTo } from 'rxjs/operators';\nimport { asInteropSubject } from '../helpers/interop-helper';\nimport { TestScheduler } from 'rxjs/testing';\nimport { observableMatcher } from '../helpers/observableMatcher';\n\n/** @test {BehaviorSubject} */\ndescribe('BehaviorSubject', () => {\n  let testScheduler: TestScheduler;\n\n  beforeEach(() => {\n    testScheduler = new TestScheduler(observableMatcher);\n  });\n\n  it('should extend Subject', () => {\n    const subject = new BehaviorSubject(null);\n    expect(subject).to.be.instanceof(Subject);\n  });\n\n  it('should throw if it has received an error and getValue() is called', () => {\n    const subject = new BehaviorSubject(null);\n    subject.error(new Error('derp'));\n    expect(() => {\n      subject.getValue();\n    }).to.throw(Error, 'derp');\n  });\n\n  it('should be closed if unsubscribed', () => {\n    const subject = new BehaviorSubject('hi there');\n    subject.unsubscribe();\n    expect(subject.closed).to.be.true;\n  });\n\n  it('should not be closed if not unsubscribed', () => {\n    const subject = new BehaviorSubject('hi there');\n    expect(subject.closed).to.be.false;\n  });\n\n  it('should be closed if it has received an error', () => {\n    const subject = new BehaviorSubject('hi there');\n    subject.error(new Error('derp'));\n    expect(subject.closed).to.be.true;\n  });\n\n  it('should be closed if it has received a complete notification', () => {\n    const subject = new BehaviorSubject('hi there');\n    subject.complete();\n    expect(subject.closed).to.be.true;\n  });\n\n  it('should have a getValue() method to retrieve the current value', () => {\n    const subject = new BehaviorSubject('staltz');\n    expect(subject.getValue()).to.equal('staltz');\n\n    subject.next('oj');\n\n    expect(subject.getValue()).to.equal('oj');\n  });\n\n  it('should not allow you to set `value` directly', () => {\n    const subject = new BehaviorSubject('flibberty');\n\n    try {\n      // XXX: escape from readonly restriction for testing.\n      (subject as any).value = 'jibbets';\n    } catch (e) {\n      //noop\n    }\n\n    expect(subject.getValue()).to.equal('flibberty');\n    expect(subject.value).to.equal('flibberty');\n  });\n\n  it('should still allow you to retrieve the value from the value property', () => {\n    const subject = new BehaviorSubject('fuzzy');\n    expect(subject.value).to.equal('fuzzy');\n    subject.next('bunny');\n    expect(subject.value).to.equal('bunny');\n  });\n\n  it('should start with an initialization value', (done) => {\n    const subject = new BehaviorSubject('foo');\n    const expected = ['foo', 'bar'];\n    let i = 0;\n\n    subject.subscribe({\n      next: (x: string) => {\n        expect(x).to.equal(expected[i++]);\n      },\n      complete: done,\n    });\n\n    subject.next('bar');\n    subject.complete();\n  });\n\n  it('should pump values to multiple subscribers', (done) => {\n    const subject = new BehaviorSubject('init');\n    const expected = ['init', 'foo', 'bar'];\n    let i = 0;\n    let j = 0;\n\n    subject.subscribe((x: string) => {\n      expect(x).to.equal(expected[i++]);\n    });\n\n    subject.subscribe({\n      next: (x: string) => {\n        expect(x).to.equal(expected[j++]);\n      },\n      complete: done,\n    });\n\n    expect(subject.observers.length).to.equal(2);\n    subject.next('foo');\n    subject.next('bar');\n    subject.complete();\n  });\n\n  it('should not pass values nexted after a complete', () => {\n    const subject = new BehaviorSubject('init');\n    const results: string[] = [];\n\n    subject.subscribe((x: string) => {\n      results.push(x);\n    });\n    expect(results).to.deep.equal(['init']);\n\n    subject.next('foo');\n    expect(results).to.deep.equal(['init', 'foo']);\n\n    subject.complete();\n    expect(results).to.deep.equal(['init', 'foo']);\n\n    subject.next('bar');\n    expect(results).to.deep.equal(['init', 'foo']);\n  });\n\n  it('should clean out unsubscribed subscribers', (done) => {\n    const subject = new BehaviorSubject('init');\n\n    const sub1 = subject.subscribe((x: string) => {\n      expect(x).to.equal('init');\n    });\n\n    const sub2 = subject.subscribe((x: string) => {\n      expect(x).to.equal('init');\n    });\n\n    expect(subject.observers.length).to.equal(2);\n    sub1.unsubscribe();\n    expect(subject.observers.length).to.equal(1);\n    sub2.unsubscribe();\n    expect(subject.observers.length).to.equal(0);\n    done();\n  });\n\n  it('should replay the previous value when subscribed', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const behaviorSubject = new BehaviorSubject('0');\n      function feedNextIntoSubject(x: string) {\n        behaviorSubject.next(x);\n      }\n      function feedErrorIntoSubject(err: any) {\n        behaviorSubject.error(err);\n      }\n      function feedCompleteIntoSubject() {\n        behaviorSubject.complete();\n      }\n\n      const sourceTemplate = ' -1-2-3----4------5-6---7--8----9--|';\n      const subscriber1 = hot('------(a|)                         ').pipe(mergeMapTo(behaviorSubject));\n      const unsub1 = '         ---------------------!             ';\n      const expected1 = '      ------3---4------5-6--             ';\n      const subscriber2 = hot('------------(b|)                   ').pipe(mergeMapTo(behaviorSubject));\n      const unsub2 = '         -------------------------!         ';\n      const expected2 = '      ------------4----5-6---7--         ';\n      const subscriber3 = hot('---------------------------(c|)    ').pipe(mergeMapTo(behaviorSubject));\n      const expected3 = '      ---------------------------8---9--|';\n\n      expectObservable(\n        hot(sourceTemplate).pipe(tap({ next: feedNextIntoSubject, error: feedErrorIntoSubject, complete: feedCompleteIntoSubject }))\n      ).toBe(sourceTemplate);\n      expectObservable(subscriber1, unsub1).toBe(expected1);\n      expectObservable(subscriber2, unsub2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n    });\n  });\n\n  it('should emit complete when subscribed after completed', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const behaviorSubject = new BehaviorSubject('0');\n      function feedNextIntoSubject(x: string) {\n        behaviorSubject.next(x);\n      }\n      function feedErrorIntoSubject(err: any) {\n        behaviorSubject.error(err);\n      }\n      function feedCompleteIntoSubject() {\n        behaviorSubject.complete();\n      }\n\n      const sourceTemplate = ' -1-2-3--4--|       ';\n      const subscriber1 = hot('---------------(a|)').pipe(mergeMapTo(behaviorSubject));\n      const expected1 = '      ---------------|   ';\n\n      expectObservable(\n        hot(sourceTemplate).pipe(tap({ next: feedNextIntoSubject, error: feedErrorIntoSubject, complete: feedCompleteIntoSubject }))\n      ).toBe(sourceTemplate);\n      expectObservable(subscriber1).toBe(expected1);\n    });\n  });\n\n  it('should be an Observer which can be given to Observable.subscribe', (done) => {\n    const source = of(1, 2, 3, 4, 5);\n    const subject = new BehaviorSubject(0);\n    const expected = [0, 1, 2, 3, 4, 5];\n\n    subject.subscribe({\n      next: (x: number) => {\n        expect(x).to.equal(expected.shift());\n      },\n      error: (x) => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        expect(subject.value).to.equal(5);\n        done();\n      },\n    });\n\n    source.subscribe(subject);\n  });\n\n  it('should be an Observer which can be given to an interop source', (done) => {\n    // This test reproduces a bug reported in this issue:\n    // https://github.com/ReactiveX/rxjs/issues/5105\n    // However, it cannot easily be fixed. See this comment:\n    // https://github.com/ReactiveX/rxjs/issues/5105#issuecomment-578405446\n    const source = of(1, 2, 3, 4, 5);\n    const subject = new BehaviorSubject(0);\n    const expected = [0, 1, 2, 3, 4, 5];\n\n    subject.subscribe({\n      next: (x: number) => {\n        expect(x).to.equal(expected.shift());\n      },\n      error: (x) => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        expect(subject.value).to.equal(5);\n        done();\n      },\n    });\n\n    source.subscribe(asInteropSubject(subject));\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\firstValueFrom-spec.ts\\firstValueFrom-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type { Observable} from '@rxjs/observable';\nimport { Subscriber } from '@rxjs/observable';\nimport { EmptyError } from './util/EmptyError.js';\n\nexport interface FirstValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * and returning a promise that will resolve as soon as the first value\n * arrives from the observable. The subscription will then be closed.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\n * *OR* complete. If the source observable does not emit one value or complete, you will\n * end up with a promise that is hung up, and potentially all of the state of an\n * async function hanging out in memory. To avoid this situation, look into adding\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\n * amongst others.\n *\n * ## Example\n *\n * Wait for the first value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, firstValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000);\n *   const firstNumber = await firstValueFrom(source$);\n *   console.log(`The first number is ${ firstNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The first number is 0'\n * ```\n *\n * @see {@link lastValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    const subscriber = new Subscriber({\n      next: (value: T) => {\n        resolve(value);\n        subscriber.unsubscribe();\n      },\n      error: reject,\n      complete: () => {\n        if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n    source.subscribe(subscriber);\n  });\n}\n\n### Source File Dependency Files Content\n### Dependency File: EmptyError.ts\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n */\nexport class EmptyError extends Error {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  constructor() {\n    super('no elements in sequence');\n    this.name = 'EmptyError';\n  }\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:05"}, {"role": "assistant", "content": "```ts\nimport { interval, firstValueFrom, EMPTY, EmptyError, throwError, of, Observable } from 'rxjs';\nimport { expect } from 'chai';\nimport { finalize } from 'rxjs/operators';\n\ndescribe('firstValueFrom', () => {\n  it('should emit the first value as a promise', async () => {\n    let finalized = false;\n    const source = interval(10).pipe(finalize(() => (finalized = true)));\n    const result = await firstValueFrom(source);\n    expect(result).to.equal(0);\n    expect(finalized).to.be.true;\n  });\n\n  it('should support a default value', async () => {\n    const source = EMPTY;\n    const result = await firstValueFrom(source, { defaultValue: 0 });\n    expect(result).to.equal(0);\n  });\n\n  it('should support an undefined config', async () => {\n    const source = EMPTY;\n    let error: any = null;\n    try {\n      await firstValueFrom(source, undefined as any);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(EmptyError);\n  });\n\n  it('should error for empty observables', async () => {\n    const source = EMPTY;\n    let error: any = null;\n    try {\n      await firstValueFrom(source);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(EmptyError);\n  });\n\n  it('should error for errored observables', async () => {\n    const source = throwError(() => new Error('blorp!'));\n    let error: any = null;\n    try {\n      await firstValueFrom(source);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(Error);\n    expect(error.message).to.equal('blorp!');\n  });\n\n  it('should work with a synchronous observable', async () => {\n    let finalized = false;\n    const source = of('apples', 'bananas').pipe(finalize(() => (finalized = true)));\n    const result = await firstValueFrom(source);\n    expect(result).to.equal('apples');\n    expect(finalized).to.be.true;\n  });\n\n  it('should stop listening to a synchronous observable when resolved', async () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    const result = await firstValueFrom(synchronousObservable);\n    expect(sideEffects).to.deep.equal([0]);\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\intervalProvider-spec.ts\\intervalProvider-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type { TimerHandle } from './timerHandle.js';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n\n### Source File Dependency Files Content\n### Dependency File: timerHandle.ts\nexport type TimerHandle = number | ReturnType<typeof setTimeout>;\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:05"}, {"role": "assistant", "content": "```ts\n/** @prettier */\nimport { expect } from 'chai';\nimport { intervalProvider } from 'rxjs/internal/scheduler/intervalProvider';\n\ndescribe('intervalProvider', () => {\n  const originalSet = global.setInterval;\n  const originalClear = global.clearInterval;\n\n  afterEach(() => {\n    global.setInterval = originalSet;\n    global.clearInterval = originalClear;\n  });\n\n  it('should be monkey patchable', () => {\n    let setCalled = false;\n    let clearCalled = false;\n\n    global.setInterval = (() => {\n      setCalled = true;\n      return 0 as any;\n    }) as any; // TypeScript complains about a __promisify__ property\n    global.clearInterval = () => {\n      clearCalled = true;\n    };\n\n    const handle = intervalProvider.setInterval(() => {\n      /* noop */\n    });\n    intervalProvider.clearInterval(handle);\n\n    expect(setCalled).to.be.true;\n    expect(clearCalled).to.be.true;\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\lastValueFrom-spec.ts\\lastValueFrom-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type { Observable } from '@rxjs/observable';\nimport { EmptyError } from './util/EmptyError.js';\n\nexport interface LastValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function lastValueFrom<T, D>(source: Observable<T>, config: LastValueFromConfig<D>): Promise<T | D>;\nexport function lastValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * waiting for it to complete, and resolving the returned promise with the\n * last value from the observed stream.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will complete. If the source\n * observable does not complete, you will end up with a promise that is hung up, and\n * potentially all of the state of an async function hanging out in memory. To avoid\n * this situation, look into adding something like {@link timeout}, {@link take},\n * {@link takeWhile}, or {@link takeUntil} amongst others.\n *\n * ## Example\n *\n * Wait for the last value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, take, lastValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000).pipe(take(10));\n *   const finalNumber = await lastValueFrom(source$);\n *   console.log(`The final number is ${ finalNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The final number is 9'\n * ```\n *\n * @see {@link firstValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function lastValueFrom<T, D>(source: Observable<T>, config?: LastValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    let _hasValue = false;\n    let _value: T;\n    source.subscribe({\n      next: (value) => {\n        _value = value;\n        _hasValue = true;\n      },\n      error: reject,\n      complete: () => {\n        if (_hasValue) {\n          resolve(_value);\n        } else if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n  });\n}\n\n### Source File Dependency Files Content\n### Dependency File: EmptyError.ts\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n */\nexport class EmptyError extends Error {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  constructor() {\n    super('no elements in sequence');\n    this.name = 'EmptyError';\n  }\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:05"}, {"role": "assistant", "content": "```ts\nimport { interval, lastValueFrom, EMPTY, EmptyError, throwError, of } from 'rxjs';\nimport { expect } from 'chai';\nimport { finalize, take } from 'rxjs/operators';\n\ndescribe('lastValueFrom', () => {\n  it('should emit the last value as a promise', async () => {\n    let finalized = false;\n    const source = interval(2).pipe(\n      take(10),\n      finalize(() => (finalized = true))\n    );\n    const result = await lastValueFrom(source);\n    expect(result).to.equal(9);\n    expect(finalized).to.be.true;\n  });\n\n  it('should support a default value', async () => {\n    const source = EMPTY;\n    const result = await lastValueFrom(source, { defaultValue: 0 });\n    expect(result).to.equal(0);\n  });\n\n  it('should support an undefined config', async () => {\n    const source = EMPTY;\n    let error: any = null;\n    try {\n      await lastValueFrom(source, undefined as any);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(EmptyError);\n  });\n\n  it('should error for empty observables', async () => {\n    const source = EMPTY;\n    let error: any = null;\n    try {\n      await lastValueFrom(source);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(EmptyError);\n  });\n\n  it('should error for errored observables', async () => {\n    const source = throwError(() => new Error('blorp!'));\n    let error: any = null;\n    try {\n      await lastValueFrom(source);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(Error);\n    expect(error.message).to.equal('blorp!');\n  });\n\n  it('should work with a synchronous observable', async () => {\n    let finalized = false;\n    const source = of('apples', 'bananas').pipe(finalize(() => (finalized = true)));\n    const result = await lastValueFrom(source);\n    expect(result).to.equal('bananas');\n    expect(finalized).to.be.true;\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\Subject-spec.ts\\Subject-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type { Subscriber} from '@rxjs/observable';\nimport { Observable, Subscription } from '@rxjs/observable';\nimport type { Observer, SubscriptionLike } from './types.js';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  /** @internal */\n  _closed = false;\n\n  /**\n   * Will return true if this subject has been closed and is no longer accepting new values.\n   */\n  get closed() {\n    return this._closed;\n  }\n\n  private _observerCounter = 0;\n  private currentObservers = new Map<number, Observer<T>>();\n\n  /**\n   * This is used to track a known array of observers, so we don't have to\n   * clone them while iterating to prevent reentrant behaviors.\n   * (for example, what if the subject is subscribed to when nexting to an observer)\n   */\n  private observerSnapshot: Observer<T>[] | undefined;\n\n  /** @internal */\n  get observers(): Observer<T>[] {\n    return (this.observerSnapshot ??= Array.from(this.currentObservers.values()));\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  protected _clearObservers() {\n    this.currentObservers.clear();\n    this.observerSnapshot = undefined;\n  }\n\n  next(value: T) {\n    if (!this._closed) {\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (!this._closed) {\n      this.hasError = this._closed = true;\n      this.thrownError = err;\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].error(err);\n      }\n      this._clearObservers();\n    }\n  }\n\n  complete() {\n    if (!this._closed) {\n      this._closed = true;\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].complete();\n      }\n      this._clearObservers();\n    }\n  }\n\n  unsubscribe() {\n    this._closed = true;\n    this._clearObservers();\n  }\n\n  get observed() {\n    return this.currentObservers.size > 0;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    if (this.hasError || this._closed) {\n      return Subscription.EMPTY;\n    }\n    const { currentObservers } = this;\n\n    const observerId = this._observerCounter++;\n    currentObservers.set(observerId, subscriber);\n    this.observerSnapshot = undefined;\n    subscriber.add(() => {\n      currentObservers.delete(observerId);\n      this.observerSnapshot = undefined;\n    });\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, _closed } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (_closed) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return Observable that this Subject casts to.\n   */\n  asObservable(): Observable<T> {\n    return new Observable((subscriber) => this.subscribe(subscriber));\n  }\n}\n\n### Source File Dependency Files Content\n### Dependency File: types.ts\n// https://github.com/microsoft/TypeScript/issues/40462#issuecomment-689879308\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport type { Observable, Subscription } from '@rxjs/observable';\n\n/**\n * Note: This will add Symbol.observable globally for all TypeScript users,\n * however, we are no longer polyfilling Symbol.observable\n */\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\n/* OPERATOR INTERFACES */\n\n/**\n * A function type interface that describes a function that accepts one parameter `T`\n * and returns another parameter `R`.\n *\n * Usually used to describe {@link OperatorFunction} - it always takes a single\n * parameter (the source Observable) and returns another Observable.\n */\nexport interface UnaryFunction<T, R> {\n  (source: T): R;\n}\n\nexport interface OperatorFunction<T, R> extends UnaryFunction<Observable<T>, Observable<R>> {}\n\nexport type FactoryOrValue<T> = T | (() => T);\n\n/**\n * A function type interface that describes a function that accepts and returns a parameter of the same type.\n *\n * Used to describe {@link OperatorFunction} with the only one type: `OperatorFunction<T, T>`.\n *\n */\nexport interface MonoTypeOperatorFunction<T> extends OperatorFunction<T, T> {}\n\n/**\n * A value and the time at which it was emitted.\n *\n * Emitted by the `timestamp` operator\n *\n * @see {@link timestamp}\n */\nexport interface Timestamp<T> {\n  value: T;\n  /**\n   * The timestamp. By default, this is in epoch milliseconds.\n   * Could vary based on the timestamp provider passed to the operator.\n   */\n  timestamp: number;\n}\n\n/**\n * A value emitted and the amount of time since the last value was emitted.\n *\n * Emitted by the `timeInterval` operator.\n *\n * @see {@link timeInterval}\n */\nexport interface TimeInterval<T> {\n  value: T;\n\n  /**\n   * The amount of time between this value's emission and the previous value's emission.\n   * If this is the first emitted value, then it will be the amount of time since subscription\n   * started.\n   */\n  interval: number;\n}\n\n/* SUBSCRIPTION INTERFACES */\n\nexport interface Unsubscribable {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = Subscription | Unsubscribable | (() => void) | void;\n\nexport interface SubscriptionLike extends Unsubscribable {\n  unsubscribe(): void;\n  readonly closed: boolean;\n}\n\n/* OBSERVABLE INTERFACES */\n\nexport interface Subscribable<T> {\n  subscribe(observer: Partial<Observer<T>>): Unsubscribable;\n}\n\n/**\n * Valid types that can be converted to observables.\n */\nexport type ObservableInput<T> =\n  | Observable<T>\n  | InteropObservable<T>\n  | AsyncIterable<T>\n  | PromiseLike<T>\n  | ArrayLike<T>\n  | Iterable<T>\n  | ReadableStreamLike<T>;\n\n/**\n * An object that implements the `Symbol.observable` interface.\n */\nexport interface InteropObservable<T> {\n  [Symbol.observable]: () => Subscribable<T>;\n}\n\n/* NOTIFICATIONS */\n\n/**\n * A notification representing a \"next\" from an observable.\n * Can be used with {@link dematerialize}.\n */\nexport interface NextNotification<T> {\n  /** The kind of notification. Always \"N\" */\n  kind: 'N';\n  /** The value of the notification. */\n  value: T;\n}\n\n/**\n * A notification representing an \"error\" from an observable.\n * Can be used with {@link dematerialize}.\n */\nexport interface ErrorNotification {\n  /** The kind of notification. Always \"E\" */\n  kind: 'E';\n  error: any;\n}\n\n/**\n * A notification representing a \"completion\" from an observable.\n * Can be used with {@link dematerialize}.\n */\nexport interface CompleteNotification {\n  kind: 'C';\n}\n\n/**\n * Valid observable notification types.\n */\nexport type ObservableNotification<T> = NextNotification<T> | ErrorNotification | CompleteNotification;\n\n/* OBSERVER INTERFACES */\n\nexport interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\n/**\n * An object interface that defines a set of callback functions a user can use to get\n * notified of any set of {@link Observable}\n * {@link guide/glossary-and-semantics#notification notification} events.\n *\n * For more info, please refer to {@link guide/observer this guide}.\n */\nexport interface Observer<T> {\n  /**\n   * A callback function that gets called by the producer during the subscription when\n   * the producer \"has\" the `value`. It won't be called if `error` or `complete` callback\n   * functions have been called, nor after the consumer has unsubscribed.\n   *\n   * For more info, please refer to {@link guide/glossary-and-semantics#next this guide}.\n   */\n  next: (value: T) => void;\n  /**\n   * A callback function that gets called by the producer if and when it encountered a\n   * problem of any kind. The errored value will be provided through the `err` parameter.\n   * This callback can't be called more than one time, it can't be called if the\n   * `complete` callback function have been called previously, nor it can't be called if\n   * the consumer has unsubscribed.\n   *\n   * For more info, please refer to {@link guide/glossary-and-semantics#error this guide}.\n   */\n  error: (err: any) => void;\n  /**\n   * A callback function that gets called by the producer if and when it has no more\n   * values to provide (by calling `next` callback function). This means that no error\n   * has happened. This callback can't be called more than one time, it can't be called\n   * if the `error` callback function have been called previously, nor it can't be called\n   * if the consumer has unsubscribed.\n   *\n   * For more info, please refer to {@link guide/glossary-and-semantics#complete this guide}.\n   */\n  complete: () => void;\n}\n\nexport interface SubjectLike<T> extends Observer<T>, Subscribable<T> {}\n\n/* SCHEDULER INTERFACES */\n\nexport interface SchedulerLike extends TimestampProvider {\n  schedule<T>(work: (this: SchedulerAction<T>, state: T) => void, delay: number, state: T): Subscription;\n  schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number, state?: T): Subscription;\n  schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\n\nexport interface SchedulerAction<T> extends Subscription {\n  schedule(state?: T, delay?: number): Subscription;\n}\n\n/**\n * This is a type that provides a method to allow RxJS to create a numeric timestamp\n */\nexport interface TimestampProvider {\n  /**\n   * Returns a timestamp as a number.\n   *\n   * This is used by types like `ReplaySubject` or operators like `timestamp` to calculate\n   * the amount of time passed between events.\n   */\n  now(): number;\n}\n\n/**\n * Extracts the type from an `ObservableInput<any>`. If you have\n * `O extends ObservableInput<any>` and you pass in `Observable<number>`, or\n * `Promise<number>`, etc, it will type as `number`.\n */\nexport type ObservedValueOf<O> = O extends ObservableInput<infer T> ? T : never;\n\n/**\n * Extracts a union of element types from an `ObservableInput<any>[]`.\n * If you have `O extends ObservableInput<any>[]` and you pass in\n * `Observable<string>[]` or `Promise<string>[]` you would get\n * back a type of `string`.\n * If you pass in `[Observable<string>, Observable<number>]` you would\n * get back a type of `string | number`.\n */\nexport type ObservedValueUnionFromArray<X> = X extends Array<ObservableInput<infer T>> ? T : never;\n\n/**\n * Extracts a tuple of element types from an `ObservableInput<any>[]`.\n * If you have `O extends ObservableInput<any>[]` and you pass in\n * `[Observable<string>, Observable<number>]` you would get back a type\n * of `[string, number]`.\n */\nexport type ObservedValueTupleFromArray<X> = { [K in keyof X]: ObservedValueOf<X[K]> };\n\n/**\n * Used to infer types from arguments to functions like {@link forkJoin}.\n * So that you can have `forkJoin([Observable<A>, PromiseLike<B>]): Observable<[A, B]>`\n * et al.\n */\nexport type ObservableInputTuple<T> = {\n  [K in keyof T]: ObservableInput<T[K]>;\n};\n\n/**\n * Constructs a new tuple with the specified type at the head.\n * If you declare `Cons<A, [B, C]>` you will get back `[A, B, C]`.\n */\nexport type Cons<X, Y extends readonly any[]> = ((arg: X, ...rest: Y) => any) extends (...args: infer U) => any ? U : never;\n\n/**\n * Extracts the head of a tuple.\n * If you declare `Head<[A, B, C]>` you will get back `A`.\n */\nexport type Head<X extends readonly any[]> = ((...args: X) => any) extends (arg: infer U, ...rest: any[]) => any ? U : never;\n\n/**\n * Extracts the tail of a tuple.\n * If you declare `Tail<[A, B, C]>` you will get back `[B, C]`.\n */\nexport type Tail<X extends readonly any[]> = ((...args: X) => any) extends (arg: any, ...rest: infer U) => any ? U : never;\n\n/**\n * Extracts the generic value from an Array type.\n * If you have `T extends Array<any>`, and pass a `string[]` to it,\n * `ValueFromArray<T>` will return the actual type of `string`.\n */\nexport type ValueFromArray<A extends readonly unknown[]> = A extends Array<infer T> ? T : never;\n\n/**\n * Gets the value type from an {@link ObservableNotification}, if possible.\n */\nexport type ValueFromNotification<T> = T extends { kind: 'N' | 'E' | 'C' }\n  ? T extends NextNotification<any>\n    ? T extends { value: infer V }\n      ? V\n      : undefined\n    : never\n  : never;\n\n/**\n * A simple type to represent a gamut of \"falsy\" values... with a notable exception:\n * `NaN` is \"falsy\" however, it is not and cannot be typed via TypeScript. See\n * comments here: https://github.com/microsoft/TypeScript/issues/28682#issuecomment-707142417\n */\nexport type Falsy = null | undefined | false | 0 | -0 | 0n | '';\n\nexport type TruthyTypesOf<T> = T extends Falsy ? never : T;\n\n/**\n * The base signature RxJS will look for to identify and use\n * a [ReadableStream](https://streams.spec.whatwg.org/#rs-class)\n * as an {@link ObservableInput} source.\n */\nexport type ReadableStreamLike<T> = Pick<ReadableStream<T>, 'getReader'>;\n\n/**\n * An observable with a `connect` method that is used to create a subscription\n * to an underlying source, connecting it with all consumers via a multicast.\n */\nexport interface Connectable<T> extends Observable<T> {\n  /**\n   * (Idempotent) Calling this method will connect the underlying source observable to all subscribed consumers\n   * through an underlying {@link Subject}.\n   * @returns A subscription, that when unsubscribed, will \"disconnect\" the source from the connector subject,\n   * severing notifications to all consumers.\n   */\n  connect(): Subscription;\n}\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:05"}, {"role": "assistant", "content": "```ts\nimport { expect } from 'chai';\nimport type { Subscription} from 'rxjs';\nimport { Subject, Observable, AsyncSubject, of, config, Subscriber, noop, operate } from 'rxjs';\nimport { delay } from 'rxjs/operators';\nimport { TestScheduler } from 'rxjs/testing';\nimport { observableMatcher } from './helpers/observableMatcher';\n\n/** @test {Subject} */\ndescribe('Subject', () => {\n  let rxTestScheduler: TestScheduler;\n\n  beforeEach(() => {\n    rxTestScheduler = new TestScheduler(observableMatcher);\n  });\n\n  it('should allow next with undefined or any when created with no type', (done) => {\n    const subject = new Subject();\n    subject.subscribe({\n      next: (x) => {\n        expect(x).to.be.a('undefined');\n      },\n      complete: done,\n    });\n\n    const data: any = undefined;\n    subject.next(undefined);\n    subject.next(data);\n    subject.complete();\n  });\n\n  it('should allow empty next when created with void type', (done) => {\n    const subject = new Subject<void>();\n    subject.subscribe({\n      next: (x) => {\n        expect(x).to.be.a('undefined');\n      },\n      complete: done,\n    });\n\n    subject.next();\n    subject.complete();\n  });\n\n  it('should pump values right on through itself', (done) => {\n    const subject = new Subject<string>();\n    const expected = ['foo', 'bar'];\n\n    subject.subscribe({\n      next: (x: string) => {\n        expect(x).to.equal(expected.shift());\n      },\n      complete: done,\n    });\n\n    subject.next('foo');\n    subject.next('bar');\n    subject.complete();\n  });\n\n  it('should pump values to multiple subscribers', (done) => {\n    const subject = new Subject<string>();\n    const expected = ['foo', 'bar'];\n\n    let i = 0;\n    let j = 0;\n\n    subject.subscribe(function (x) {\n      expect(x).to.equal(expected[i++]);\n    });\n\n    subject.subscribe({\n      next: function (x) {\n        expect(x).to.equal(expected[j++]);\n      },\n      complete: done,\n    });\n\n    expect(subject.observers.length).to.equal(2);\n    subject.next('foo');\n    subject.next('bar');\n    subject.complete();\n  });\n\n  it('should handle subscribers that arrive and leave at different times, ' + 'subject does not complete', () => {\n    const subject = new Subject<number>();\n    const results1: (number | string)[] = [];\n    const results2: (number | string)[] = [];\n    const results3: (number | string)[] = [];\n\n    subject.next(1);\n    subject.next(2);\n    subject.next(3);\n    subject.next(4);\n\n    const subscription1 = subject.subscribe({\n      next: function (x) {\n        results1.push(x);\n      },\n      error: function (e) {\n        results1.push('E');\n      },\n      complete: () => {\n        results1.push('C');\n      },\n    });\n\n    subject.next(5);\n\n    const subscription2 = subject.subscribe({\n      next: function (x) {\n        results2.push(x);\n      },\n      error: function (e) {\n        results2.push('E');\n      },\n      complete: () => {\n        results2.push('C');\n      },\n    });\n\n    subject.next(6);\n    subject.next(7);\n\n    subscription1.unsubscribe();\n\n    subject.next(8);\n\n    subscription2.unsubscribe();\n\n    subject.next(9);\n    subject.next(10);\n\n    const subscription3 = subject.subscribe({\n      next: function (x) {\n        results3.push(x);\n      },\n      error: function (e) {\n        results3.push('E');\n      },\n      complete: () => {\n        results3.push('C');\n      },\n    });\n\n    subject.next(11);\n\n    subscription3.unsubscribe();\n\n    expect(results1).to.deep.equal([5, 6, 7]);\n    expect(results2).to.deep.equal([6, 7, 8]);\n    expect(results3).to.deep.equal([11]);\n  });\n\n  it('should handle subscribers that arrive and leave at different times, ' + 'subject completes', () => {\n    const subject = new Subject<number>();\n    const results1: (number | string)[] = [];\n    const results2: (number | string)[] = [];\n    const results3: (number | string)[] = [];\n\n    subject.next(1);\n    subject.next(2);\n    subject.next(3);\n    subject.next(4);\n\n    const subscription1 = subject.subscribe({\n      next: function (x) {\n        results1.push(x);\n      },\n      error: function (e) {\n        results1.push('E');\n      },\n      complete: () => {\n        results1.push('C');\n      },\n    });\n\n    subject.next(5);\n\n    const subscription2 = subject.subscribe({\n      next: function (x) {\n        results2.push(x);\n      },\n      error: function (e) {\n        results2.push('E');\n      },\n      complete: () => {\n        results2.push('C');\n      },\n    });\n\n    subject.next(6);\n    subject.next(7);\n\n    subscription1.unsubscribe();\n\n    subject.complete();\n\n    subscription2.unsubscribe();\n\n    const subscription3 = subject.subscribe({\n      next: function (x) {\n        results3.push(x);\n      },\n      error: function (e) {\n        results3.push('E');\n      },\n      complete: () => {\n        results3.push('C');\n      },\n    });\n\n    subscription3.unsubscribe();\n\n    expect(results1).to.deep.equal([5, 6, 7]);\n    expect(results2).to.deep.equal([6, 7, 'C']);\n    expect(results3).to.deep.equal(['C']);\n  });\n\n  it('should handle subscribers that arrive and leave at different times, ' + 'subject terminates with an error', () => {\n    const subject = new Subject<number>();\n    const results1: (number | string)[] = [];\n    const results2: (number | string)[] = [];\n    const results3: (number | string)[] = [];\n\n    subject.next(1);\n    subject.next(2);\n    subject.next(3);\n    subject.next(4);\n\n    const subscription1 = subject.subscribe({\n      next: function (x) {\n        results1.push(x);\n      },\n      error: function (e) {\n        results1.push('E');\n      },\n      complete: () => {\n        results1.push('C');\n      },\n    });\n\n    subject.next(5);\n\n    const subscription2 = subject.subscribe({\n      next: function (x) {\n        results2.push(x);\n      },\n      error: function (e) {\n        results2.push('E');\n      },\n      complete: () => {\n        results2.push('C');\n      },\n    });\n\n    subject.next(6);\n    subject.next(7);\n\n    subscription1.unsubscribe();\n\n    subject.error(new Error('err'));\n\n    subscription2.unsubscribe();\n\n    const subscription3 = subject.subscribe({\n      next: function (x) {\n        results3.push(x);\n      },\n      error: function (e) {\n        results3.push('E');\n      },\n      complete: () => {\n        results3.push('C');\n      },\n    });\n\n    subscription3.unsubscribe();\n\n    expect(results1).to.deep.equal([5, 6, 7]);\n    expect(results2).to.deep.equal([6, 7, 'E']);\n    expect(results3).to.deep.equal(['E']);\n  });\n\n  it('should handle subscribers that arrive and leave at different times, ' + 'subject completes before nexting any value', () => {\n    const subject = new Subject<number>();\n    const results1: (number | string)[] = [];\n    const results2: (number | string)[] = [];\n    const results3: (number | string)[] = [];\n\n    const subscription1 = subject.subscribe({\n      next: function (x) {\n        results1.push(x);\n      },\n      error: function (e) {\n        results1.push('E');\n      },\n      complete: () => {\n        results1.push('C');\n      },\n    });\n\n    const subscription2 = subject.subscribe({\n      next: function (x) {\n        results2.push(x);\n      },\n      error: function (e) {\n        results2.push('E');\n      },\n      complete: () => {\n        results2.push('C');\n      },\n    });\n\n    subscription1.unsubscribe();\n\n    subject.complete();\n\n    subscription2.unsubscribe();\n\n    const subscription3 = subject.subscribe({\n      next: function (x) {\n        results3.push(x);\n      },\n      error: function (e) {\n        results3.push('E');\n      },\n      complete: () => {\n        results3.push('C');\n      },\n    });\n\n    subscription3.unsubscribe();\n\n    expect(results1).to.deep.equal([]);\n    expect(results2).to.deep.equal(['C']);\n    expect(results3).to.deep.equal(['C']);\n  });\n\n  it('should disallow new subscriber once subject has been disposed', () => {\n    const subject = new Subject<number>();\n    const results1: (number | string)[] = [];\n    const results2: (number | string)[] = [];\n    const results3: (number | string)[] = [];\n\n    const subscription1 = subject.subscribe({\n      next: function (x) {\n        results1.push(x);\n      },\n      error: function (e) {\n        results1.push('E');\n      },\n      complete: () => {\n        results1.push('C');\n      },\n    });\n\n    subject.next(1);\n    subject.next(2);\n\n    const subscription2 = subject.subscribe({\n      next: function (x) {\n        results2.push(x);\n      },\n      error: function (e) {\n        results2.push('E');\n      },\n      complete: () => {\n        results2.push('C');\n      },\n    });\n\n    subject.next(3);\n    subject.next(4);\n    subject.next(5);\n\n    subscription1.unsubscribe();\n    subscription2.unsubscribe();\n    subject.unsubscribe();\n\n    const subscription = subject.subscribe({\n      next: function (x) {\n        results3.push(x);\n      },\n      error: function (err) {\n        expect(false).to.equal('should not throw error: ' + err.toString());\n      },\n    });\n\n    expect(subscription.closed).to.be.true;\n\n    expect(results1).to.deep.equal([1, 2, 3, 4, 5]);\n    expect(results2).to.deep.equal([3, 4, 5]);\n    expect(results3).to.deep.equal([]);\n  });\n\n  it('should not allow values to be nexted after it is unsubscribed', () => {\n    const subject = new Subject<string>();\n    const results: any[] = [];\n    subject.subscribe((x) => results.push(x));\n\n    subject.next('foo');\n    subject.unsubscribe();\n    subject.next('bar');\n\n    expect(results).to.deep.equal(['foo']);\n  });\n\n  it('should clean out unsubscribed subscribers', (done) => {\n    const subject = new Subject();\n\n    const sub1 = subject.subscribe(function (x) {\n      //noop\n    });\n\n    const sub2 = subject.subscribe(function (x) {\n      //noop\n    });\n\n    expect(subject.observers.length).to.equal(2);\n    sub1.unsubscribe();\n    expect(subject.observers.length).to.equal(1);\n    sub2.unsubscribe();\n    expect(subject.observers.length).to.equal(0);\n    done();\n  });\n\n  it('should expose observed status', () => {\n    const subject = new Subject();\n\n    expect(subject.observed).to.equal(false);\n\n    const sub1 = subject.subscribe(function (x) {\n      //noop\n    });\n\n    expect(subject.observed).to.equal(true);\n\n    const sub2 = subject.subscribe(function (x) {\n      //noop\n    });\n\n    expect(subject.observed).to.equal(true);\n    sub1.unsubscribe();\n    expect(subject.observed).to.equal(true);\n    sub2.unsubscribe();\n    expect(subject.observed).to.equal(false);\n    subject.unsubscribe();\n    expect(subject.observed).to.equal(false);\n  });\n\n  it('should be an Observer which can be given to Observable.subscribe', (done) => {\n    const source = of(1, 2, 3, 4, 5);\n    const subject = new Subject<number>();\n    const expected = [1, 2, 3, 4, 5];\n\n    subject.subscribe({\n      next: function (x) {\n        expect(x).to.equal(expected.shift());\n      },\n      error: (x) => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        done();\n      },\n    });\n\n    source.subscribe(subject);\n  });\n\n  it('should be usable as an Observer of a finite delayed Observable', (done) => {\n    const source = of(1, 2, 3).pipe(delay(50));\n    const subject = new Subject<number>();\n\n    const expected = [1, 2, 3];\n\n    subject.subscribe({\n      next: function (x) {\n        expect(x).to.equal(expected.shift());\n      },\n      error: (x) => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        done();\n      },\n    });\n\n    source.subscribe(subject);\n  });\n\n  it('should be closed after unsubscribed', () => {\n    const subject = new Subject<string>();\n    subject.unsubscribe();\n    expect(subject.closed).to.be.true;\n  });\n\n  it('should be closed after error', () => {\n    const subject = new Subject<string>();\n    subject.error('bad');\n    expect(subject.closed).to.be.true;\n  });\n\n  it('should be closed after complete', () => {\n    const subject = new Subject<string>();\n    subject.complete();\n    expect(subject.closed).to.be.true;\n  });\n\n  it('should not next after completed', () => {\n    const subject = new Subject<string>();\n    const results: string[] = [];\n    subject.subscribe({ next: (x) => results.push(x), complete: () => results.push('C') });\n    subject.next('a');\n    subject.complete();\n    subject.next('b');\n    expect(results).to.deep.equal(['a', 'C']);\n  });\n\n  it('should not next after error', () => {\n    const error = new Error('wut?');\n    const subject = new Subject<string>();\n    const results: string[] = [];\n    subject.subscribe({ next: (x) => results.push(x), error: (err) => results.push(err) });\n    subject.next('a');\n    subject.error(error);\n    subject.next('b');\n    expect(results).to.deep.equal(['a', error]);\n  });\n\n  describe('asObservable', () => {\n    it('should hide subject', () => {\n      const subject = new Subject();\n      const observable = subject.asObservable();\n\n      expect(subject).not.to.equal(observable);\n\n      expect(observable instanceof Observable).to.be.true;\n      expect(observable instanceof Subject).to.be.false;\n    });\n\n    it('should handle subject never emits', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const observable = hot('-').asObservable();\n\n        expectObservable(observable).toBe('-');\n      });\n    });\n\n    it('should handle subject completes without emits', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const observable = hot('--^--|').asObservable();\n        const expected = '        ---|';\n\n        expectObservable(observable).toBe(expected);\n      });\n    });\n\n    it('should handle subject throws', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const observable = hot('--^--#').asObservable();\n        const expected = '        ---#';\n\n        expectObservable(observable).toBe(expected);\n      });\n    });\n\n    it('should handle subject emits', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const observable = hot('--^--x--|').asObservable();\n        const expected = '        ---x--|';\n\n        expectObservable(observable).toBe(expected);\n      });\n    });\n\n    it('should work with inherited subject', () => {\n      const results: (number | string)[] = [];\n      const subject = new AsyncSubject<number>();\n\n      subject.next(42);\n      subject.complete();\n\n      const observable = subject.asObservable();\n\n      observable.subscribe({ next: (x) => results.push(x), complete: () => results.push('done') });\n\n      expect(results).to.deep.equal([42, 'done']);\n    });\n  });\n\n  describe('error thrown scenario', () => {\n    afterEach(() => {\n      config.onUnhandledError = null;\n    });\n\n    it('should not synchronously error when nexted into', (done) => {\n      config.onUnhandledError = (err) => {\n        expect(err.message).to.equal('Boom!');\n        done();\n      };\n\n      const source = new Subject<number>();\n      source.subscribe();\n      source.subscribe(() => {\n        throw new Error('Boom!');\n      });\n      source.subscribe();\n      try {\n        source.next(42);\n      } catch (err) {\n        // This should not happen!\n        expect(true).to.be.false;\n      }\n      expect(true).to.be.true;\n    });\n  });\n\n  describe('many subscribers', () => {\n    it('should be able to subscribe and unsubscribe huge amounts of subscribers', () => {\n      let numResultsReceived = 0;\n      const allSubscriptions: Subscription[] = [];\n      const source = new Subject<number>();\n      const numSubscribers = 100000;\n      for (let index = 0; index !== numSubscribers; ++index) {\n        allSubscriptions.push(\n          source.subscribe(() => {\n            ++numResultsReceived;\n          })\n        );\n      }\n      expect(numResultsReceived).to.eq(0);\n      expect(source.observed).to.be.true;\n      source.next(42);\n      expect(numResultsReceived).to.eq(numSubscribers);\n      expect(source.observed).to.be.true;\n      for (const subscription of allSubscriptions) {\n        subscription.unsubscribe();\n      }\n      expect(numResultsReceived).to.eq(numSubscribers);\n      expect(source.observed).to.be.false;\n    });\n  });\n\n  describe('re-rentrant subscribers', () => {\n    it('should handle re-entrant subscribers', () => {\n      const seenValues: number[] = [];\n      const source = new Subject<number>();\n      source.subscribe((value) => {\n        seenValues.push(value);\n        source.subscribe((nestedValue) => {\n          seenValues.push(nestedValue);\n        });\n      });\n      source.next(1);\n      source.next(2);\n      source.next(3);\n      expect(seenValues).to.deep.eq([1, 2, 2, 3, 3, 3]);\n    });\n  });\n\n  it('should behave properly when subscribed to more than once by the same operator subscriber returned by `operate`', () => {\n    const subject = new Subject<number>();\n    const destination = new Subscriber();\n    const results: any[] = [];\n    const subscriber = operate({\n      destination,\n      next: (value) => {\n        results.push(value);\n      },\n      error: noop,\n      complete: () => {\n        results.push('complete');\n      },\n    });\n\n    subject.subscribe(subscriber);\n    subject.subscribe(subscriber);\n    subject.next(1);\n    subject.next(2);\n    subject.complete();\n\n    expect(results).to.deep.equal([1, 1, 2, 2, 'complete']);\n  });\n});\n\n```"}]}
{"messages": [{"role": "system", "content": "You are an AI agent expert in writing unit tests. Your task is to write unit tests for the given code files of the repository. Make sure the tests can be executed without lint or compile errors."}, {"role": "user", "content": "### Task Information\nBased on the source code, write/rewrite tests to cover the source code.\nRepository: rxjs\nTest File Path: rxjs\\timeoutProvider-spec.ts\\timeoutProvider-spec.ts\nProject Programming Language: typescript\nTesting Framework: jest\n### Source File Content\n### Source File Content:\nimport type { TimerHandle } from './timerHandle.js';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n\n### Source File Dependency Files Content\n### Dependency File: timerHandle.ts\nexport type TimerHandle = number | ReturnType<typeof setTimeout>;\n\nOutput the complete test file, code only, no explanations.\n```typescript\n<complete test code>\n```\n### Time\nCurrent time: 2025-04-02 07:42:05"}, {"role": "assistant", "content": "```ts\n/** @prettier */\nimport { expect } from 'chai';\nimport { timeoutProvider } from 'rxjs/internal/scheduler/timeoutProvider';\n\ndescribe('timeoutProvider', () => {\n  const originalSet = global.setTimeout;\n  const originalClear = global.clearTimeout;\n\n  afterEach(() => {\n    global.setTimeout = originalSet;\n    global.clearTimeout = originalClear;\n  });\n\n  it('should be monkey patchable', () => {\n    let setCalled = false;\n    let clearCalled = false;\n\n    global.setTimeout = (() => {\n      setCalled = true;\n      return 0 as any;\n    }) as any;\n    global.clearTimeout = () => {\n      clearCalled = true;\n    };\n\n    const handle = timeoutProvider.setTimeout(() => {\n      /* noop */\n    });\n    timeoutProvider.clearTimeout(handle);\n\n    expect(setCalled).to.be.true;\n    expect(clearCalled).to.be.true;\n  });\n});\n\n```"}]}
